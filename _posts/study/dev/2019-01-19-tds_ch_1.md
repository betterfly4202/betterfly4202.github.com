---
title: "[Think Data Structures]ArrayList와 LinkedList"
categories: "dev"
tags:
  - Think Data Structures
  - data structure
  - list
---

![tds_book](/assets/images/study/dev/2019/tds_book.jpg){: .center}
>이 포스팅은 한빛미디어의 '자바로 배우는 핵심 자료구조와 알고리즘'의 내용을 참고 정리한 내용입니다.

* 목차
{:toc}

# 실습1

## ArrayList vs LinkedList

Java Collection Framework(JCF)는 List라는 interface를 통해 ArrayList와 LinkedList를 제공한다.

![jfc](http://www.nextree.co.kr/content/images/2016/09/jdchoi_20140220_JCF.png)

두 클래스의 차이는 다음의 링크에 자세히 소개되고 있다. [ArrayList와 LinkedList 차이](http://www.nextree.co.kr/p6506/)

쉽게 정리하자면 다음과 같다.

![list](/assets/images/study/dev/2019/2_list.png)
<figcaption>생활코딩의 리스트 비교</figcaption>

하나의 **회사(List의 요소)**가 **건물(메모리)**에 입주해있다. 

<code>Array List</code>는 그림과 같이 건물에 나란히 회사가 위치해 있다. 따라서 회사의 사무실이 이렇게 나란히 붙어있기 때문에 사무실의 위치를 찾기가 굉장히 수월하다.

하지만 이러한 방식은 빈 공간을 허용하지 않기 때문에, 중간의 하나의 사무실에 공실이 발생할 경우 전체 사무실이 빈 공간을 채우려 이동해야 한다.

이와달리 <code>Linked List</code>는 사무실이 산발적으로 위치해 있다.

우리는 사무실의 위치를 찾기 위해 각각의 사무실 주소(예: 201호, 304호, 408호 등)를 각각 찾아가야하기 때문에 사무실을 찾아가는 것이 꽤나 번거롭다.

하지만 나란히 있는 것이 아니기 때문에 중간에 사무실에 공실이 발생하여도 전혀 상관없다. 어차피 우리는 각자의 위치(주소)를 갖고 있기 때문이다.


---

다시 본론으로 돌아와 List Interface를 살펴보자.

## List Interface
ArrayList와 LinkedList는 <code>List</code>를 구현(implements)하여 사용하는 클래스이다.

따라서 다음과 같은 구조로 사용할 수 있다.

~~~java
public class ListClientExample {

    @SuppressWarnings("rawtypes")
    private List list;

    @SuppressWarnings("rawtypes")
    public ListClientExample() {
        list = new LinkedList();
    }

    @SuppressWarnings("rawtypes")
    public List getList() {
        return list;
    }

    public static void main(String[] args) {
        ListClientExample lce = new ListClientExample();
        @SuppressWarnings("rawtypes")
        List list = lce.getList();
        System.out.println(list);
    }
}
~~~

이 클래스의 구성은 유용하진 않지만, List를 캡슐화하는 클래스의 필수 요소를 가지고 있다.

위 클래스는 생성자를 통해서만 LinkedList를 초기화하고, getList를 통해 List객체애 대한 참조를 반환한다.

경우에 따라 ArrayList를 사용하고자 한다면, 생성자를 통한 초기화만 바꾸어주면 된다.

이와 같은 방식을 **인터페이스 프로그래밍**이라고 하는데, 필요한 경우가 아니라면 LinkedList나 ArrayList를 직접 구현하지 않고 생성자를 통해 구현함으로써, 필요에 따라 생성자의 초기화만 변경하여 유연한 대처를 할 수 있다. 

> 여기서 말하는 '인터페이스'는  자바의 인터페이스가 아닌, 일반적인 의미의 인터페이스를 말한다.

그러면 다음부터 본격적으로 List에 대해서 파해쳐보자.

## [생각해보기]
1. 앞선 <code>ListClientExample</code> 클래스 생성자에서 ArrayList객체를 List 인터페이스로 교체하면 어떻게 될까?
    - 생성자에서 인스턴스를 생성하지 않고, 인터페이스로만 선언한다면, getter로 쓰이고 있는 함수(getList())에서 반환할 수 있는 list의 실체(인스턴스)가 없으므로 컴파일이 제대로 되지 않는다.

2. 왜 List 인터페이스로는 인스턴스가 생성되지 않을까?
   - 자바의 interface는 인스턴스를 생성하는 객체로 사용되지 않는다. interface를 사용해서 어떠한 클래스를 디자인할 것인지 명세만을 제공한다.

   따라서 List가 interface로 설계된 이유 역시, List라는 전체 구조를 필요애 따라 구현(ArrayList or LinkedList)할 수 있도록 가이드라인만 제공해준 것이 아닐까.

   (사실 질문 자체는 *인터페이스는 왜 인스턴스가 생성되지 않을까* 였는데, 사실 자바의 인터페이스는 인스턴스로 생성할 수 가 없다. 그래서 왜 인터페이스로 설계 했을까에 대해서 생각해 보았다.)


[참고]
- https://www.holaxprogramming.com/2014/02/12/java-list-interface/
- http://www.nextree.co.kr/p6506/
- https://opentutorials.org/module/1335/8821