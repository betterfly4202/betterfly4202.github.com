---
title: "HTTPS과 SSL"
categories: "NETWORK"
tags:
  - HTTP
  - HTTPS
  - SSL
  - Secure
---

최근 보안에 대한 관심이 생기면서 놓치고있던 보안의 기본개념들을 하나씩 되짚어보려 한다.

그 중 흔히 듣는 용어이지만, 정확한 개념이 잡히지 않던 <code>SSL</code>에 대한 이야기이다.

![https](/assets/images/study/dev/2018/12_HTTPS.png)

<code>HTTP</code>는 우리가 웹을 이용하며 가장 흔히 접하는 프로토콜이다.

HTTP는 용어에서 볼 수 있듯이, **Hypertext****. 즉, Hypertext(Hypertext Markup Language; HTML)을 Transfer 해주는 Protocol이라는 것이다.


## 프로토콜(Protocol)이란?

![protocol_img](/assets/images/study/dev/2018/10_protocol_img.gif)

대부분의 프로그래밍에서 사용하는 용더들이 그러하듯, **프로토콜**이라는 단어 역시 개발자들에만 국한되는 단어가 아니다. 나무위키에 검색해보면 프로토콜은 다음과 같이 소개되고 있다.

![protocol_means](/assets/images/study/dev/2018/10_protocol_means.png)
<figcaption class="caption">출처 : 나무위키</figcaption>

말이 결국 어려워지지만, '통신규약' 정도로 해석하는 것이 가장 자연스러워 보인다.

> HTTP는 HTML문서를 우리 일반 사용자들이 볼 수 있게끔 변환해주는 통신 규약 정도로 정리할 수 있을 것 같다.

---

그러면 <code>HTTPS</code>는 무엇이며, **왜** 필요할까?

>HTTPS; Hypertext Transfer Protocol Secure

HTTP에 <code> Secure </code>가 추가되었다.

HTTP통신에 Secure(보안)이 추가된 프로토콜인 것이다.

우리가 사용하는 웹환경은 일반적으로 클라이언트와 서버간 패킷을 주고 받으며 통신한다. 클라이언트에서 입력(전달)한 정보는 서버에 전달되며, 그 입력값 등을 통하여 다양한 서비스를 즐길 수 있는 것이다.

이를테면 네이버에서 검색창에 특정 키워드를 검색한다면, 우리는 클라이언트 입장에서 어떤 *요청(Request)*을 보낸것이며, 네이버 서버는 우리가 입력한 키워드에 대한 결과를 *응답(Response)*해 줄 것이다. 이 과정에서 서로 간에 주고 받는 데이터 단위를 '패킷'이라 한다.

문제는 HTTP은 기본적으로 이 패킷을 '평문(Plain Text)'로 주고 받는다. 

여기서 맹점이 발생하는데, 로그인 또는 물건 구입시 입력하는 신용정보와 같은 민감한 정보들을 이와 같은 평문으로 주고 받을때, 누군가 우리의 개인정보를 **스니핑**한다면?

윈도우의 경우 [Fiddler](https://www.telerik.com/fiddler)를 통해서, 맥의 경우 [WireShark](https://www.wireshark.org/download.html)라는 툴을 통해서 손쉽게 스니핑하여 우리의 개인정보를 탈취할 수 있다는 것이다.
(해당 툴들은 위처럼 해킹을 위한 목적으로 사용하면 철컹철컹된다. 웹 개발시 서포팅해주는 툴 정도로만 사용해야한다.)

![snipping](/assets/images/study/dev/2018/12_snipping.png)

이처럼 보안에 대한 중대한 문제를 해결하기 위해 HTTP위에 보안 프로토콜인 **SSL**을 얹혀서 <code>HTTPS</code>로 재탄생한것이다.

>**SSL과 TLS**<br/>
같은 말이다. 네스케이프에 의해서 SSL이 발명되었고, 이것이 점차 폭넓게 사용되다가 표준화 기구인 IETF의 관리로 변경되면서 TLS라는 이름으로 바뀌었다. TLS 1.0은 SSL 3.0을 계승한다. 하지만 TLS라는 이름보다 SSL이라는 이름이 훨씬 많이 사용되고 있다.

SSL의 핵심은 **암호화**이다.

## 암호화 - 대칭키와 공개키

![대칭키](/assets/images/study/dev/2018/12_2.png)
### 대칭키
- '암호화'란?<br/>
어떤 문자를 암호화(Encrypt)하기 위해 사용하는 일종의 '비밀번호 키'의 개념이다.<br/>
앞서 언급했던 HTTP와 같이 평문으로 데이터를 주고 받을 경우, 중간에 데이터를 가로챈다면 우리의 개인정보가 노출될 우려가 있다. 이와 같은 경우에서 '평문'의 데이터를 특정한 패턴의 알고리즘(SHA256, RSA 등)으로 암호화하여 데이터를 보호할 수 있다.

예를들어, 
- 입력한 비밀번호 : 1234
- 암호화 키 값 : AAbb
인 경우 우리가 입력한 '1234'라는 비밀번호는 암호화 키 값(AAbb)과 특정한 알고리즘에 의하여 => 'ODPS'와 같은 전혀 다른 문자로 치환되는 과정을 '암호화' 라고 한다.

위와같이 암호화된 (ODPS)문자를 원래의 문자(1234)로 복원하는 과정을 '복호화'라고 하며, 이 복호화를 위해 필요한 키가 바로 <code>대칭키</code>이다.

하지만 대칭키에 치명적인 문제가 있는데

중간에 대칭키를 가로챌 경우 모든 데이터를 복호화할 수 있기 때문에, HTTPS를 사용하는 이유가 없어진다.

이와 같은 문제를 극복하기 위하여 나온 것이 <code>공개키</code>기법이다.

![공개키](/assets/images/study/dev/2018/12_3.png)
### 공개키
공개키 방식은 대칭키와 달리, 2개의 키를 가지고 시작한다.

이를 <code>공개키(Public key)</code>와 <code>비공개키(Private key, 개인키/비밀키)</code>라고 한다.

비공개키(Private key)는 자신만 가지고 있고, 공개키(Public key)는 타인에게 제공한다.

공개키를 전달받은 타인은 공개키를 이용하여 데이터를 암호화하여 전달한다. 전달받은 수신자는 자신이 보유한 비공개키를 통하여 복호화한다.

이 방식은 중간에 누군가 공개키를 탈취하여도, 비공개키를 모르기 때문에 데이터를 복호화할 수 없기 때문에 높은 보안을 유지할 수 있다.

그림에서 우측을 서버(데이터 수신자)라고 가정할 때, 서버는 공개키, 비공개키를 가지고 있다. 

클라이언트는 공개키 저장소에 등록된 공개키를 이용하여 자신의 데이터를 암호화하여 전달하고, 서버는 자신의 개인키를 통하여 암호화된 데이터를 복호화할 수 있다.

---

그림을 통해 SSL의 흐름을 먼저 살펴보자.
![ssl_flow](/assets/images/study/dev/2018/12_SSL_2.gif)

### Handshake
우리도 일상에서 누군가를 처음 만나면, 악수를 하며 서로의 안부를 묻곤한다.

통신에서도 마찬가지다.

Client - Server 간 handshake를 통해서 서로의 상태를 확인하고, 서로간의 신뢰 또는 자신이 찾는 상대방이라는 것이 확인되면 믿고 서로간의 소통을 시작하는 것이다.

이 과정은 총 4개의 단계로 구분되는데,

### 1단계. Hello
먼저 Client가 Server에 인사(client Hello)를 하고, 서버 역시 인사에 대한 응답(server hello)을 하며 서로의 상태를 확인한다.

이 과정에서 client는 다음의 정보를 제공해준다.
- 클라이언트가 지원하는 암호화 방식들 : 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 **암호화 방식**을 전송한다.
- 세션 아이디 : 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이 때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

이에 대해 서버는 다음과 같은 정보를 응답한다.
- 서버가 선택한 클라이언트의 암호화 방식 : 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환하게 된다.
- 인증서

### 2단계. 서버 인증서
서버는 클라이언트에게 **인증서(CA)**, 사용할 **서버키**를 교환하며, 인증요청을 보내준다.


### 3단계. 클라이언트 인증서
클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력한다. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것이다. 인증서를 전송한 서버를 믿을 수 있게 된 것이다.

클라이언트는 1단계 <Hello>과정에서 생성된 클라이언트/서버간의 랜덤데이터를 조합하여 pre master secret 이라는 키를 생성한다. (이 키는 서버/클라이언트외에 절대 노출되어선 안되는 '암호화된 키'이다.)

### 4단계. Session Key생성
마지막으로 서버는 클라이언트로부터 전달받은 pre master secret키 값을 자신의 <code>비공개키</code>로 복호화한다.

이로써 클라이언트/서버간에 인증을 통하여 pre master secret키 값을 master secret값으로 가공한다.

최종적으로 master secret을 통해 <code>session key</code>를 생성하게 되는데, 이 **session key**가 바로 <code>대칭키</code>방식으로 암호화하여 주고 받는데 사용된다.



[참고]
- https://opentutorials.org/course/228/4894
- https://jongampark.wordpress.com/2009/11/11/ssh-vs-ssl-%EB%B0%94%EB%B3%B4-%EA%B0%99%EC%9D%80-%EC%84%A4%EB%AA%85/
- https://wayhome25.github.io/cs/2018/03/11/ssl-https/
- https://developer.android.com/training/articles/security-ssl?hl=ko
- http://jimmyfactory.blogspot.com/2015/12/ssl.html
- https://wiki.kldp.org/HOWTO/html/SSL-Certificates-HOWTO/x70.html
- http://korea07.tistory.com/26
- http://aileen93.tistory.com/119