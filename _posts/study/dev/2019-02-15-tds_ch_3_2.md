---
title: "[Think Data Structures]List 인터페이스의 구현과 알고리즘 분석 #3"
categories: "dev"
tags:
  - Think Data Structures
  - data structure
  - linked list
---

![tds_book](/assets/images/study/dev/2019/tds_book.jpg){: .center}
>이 포스팅은 한빛미디어의 '자바로 배우는 핵심 자료구조와 알고리즘'의 내용을 참고 정리한 내용입니다.

* 목차
{:toc}

# INTRO

이전글 [[Think Data Structures]List 인터페이스의 구현과 알고리즘 분석#2](https://better-dev.netlify.com/dev/tds_ch_3_1/)

이전에 ArrayList에 대해서 다루었다면, 이번엔 LinkedList를 살펴보자.

우선 LinkedList의 개념부터 살펴봐야하는데, 사실 필자의 경우 실무에서 대부분(이라곤 하지만 100%) ArrayList만을 사용해왔기 때문에 `LinkedList`는 조금 낯설게 느껴진다.

>**LinkedList** <br/>
순차적으로 연결된 ArrayList와는 달리, LinkedList의 핵심은 Node라는 객체들이 다른 노드에 대해서 '참조'하고 있다는 것이다.
이것은 자료구조에서 매우 큰 차이를 보이는데, 
LinkedList 설명 첨부

[ArrayList와 LinkedList](https://better-dev.netlify.com/dev/tds_ch_1/)

---

자 이제 본격적으로 LinkedList를 파헤쳐보자.

## MyLinkedList 와 MyArrayList

~~~java
public class MyLinkedList<E> implements List<E>{
    private int size;  // 요소의 개수를 추적
    private Node haed; // 첫 번째 노드에 대한 참조

    public MyLinkedList(){
        haed = null;
        size = 0;
    }
}
~~~

클래스 분석에 앞서, ArrayList와 비교해보자.

~~~java
public class MyArrayList<T> implements List<T> {
    private int size;
    private T [] array;
    private final int DEFAULT_CAPACITY = 10;

    @SuppressWarnings("unchecked")
    public MyArrayList(){
        array = (T[]) new Object[DEFAULT_CAPACITY];
        size = 0;
    }
}
~~~

각 클래스의 멤버 변수를 비교해보면 size라는 요소의 개수를 확인할 수 있는 변수는 공통으로 사용된 모습이다.

하지만 ArrayList는 타입 파라미터의 배열을 변수로 사용하여, 생성자를 통해 해당 배열을 초기화 해주는 모습이다.

그래서 최초 크기가 **10**인 배열을 생성한다.

그리고 앞선 ArrayList구현시 set(), indexOf() 등의 메서드를 구현시 `array`라는 변수의 배열을 핸들링했다.

하지만 LinkedList는 다르다. Node라는 객체를 선언하여, 해당 객체는 LinkedList의 생성자를 통해 null로 초기화된다.

정리하면 ArrayList는 `배열` 을, LinkedList는 `Node` 라는 객체를 다룬다는 것이다.

어떻게 활용되는지 하나씩 짚어보도록 하자.

--- 

## MyLinkedList

다시 MyLinkedList로 돌아오자.

우선 `Node` 라는 클래스의 구성이 궁금하다.

책에는 다음과 같이 MyLinkedList에 대한 기본 정보를 제공해준다.

~~~java
public class MyLinkedList<E> implements List<E>{
    private int size;  // 요소의 개수를 추적
    private Node haed; // 첫 번째 노드에 대한 참조

    public MyLinkedList(){
        haed = null;
        size = 0;
    }

    private class Node{
        public E data;
        public Ndoe next;

        public Node(E data, Node next){
            this.data = data;
            this.next = next;
        }
    }

    public boolean add(E element){
        if(head == null){
            head = new Node(e);
        }else{
            Node node = head;

            for(; node.next != null; node = node.next){

            }
            node.next = new Node(e);
        }
        size ++;
        return true;
    }
}
~~~

MyLinkedList 클래스 내부에 inner class로 `Node` 클래스가 존재한다.

~~특히 눈여겨볼 것은 이 이너클래스가 `private`으로 설계된 것인데, 이것은 LinkedList안에 종속되어 사용한다는 것을 명시적으로 알 수 있다.~~
(내용 보완)

그리고 add(E) 메서드를 제공받았다.

자 이제 기본 정보는 제공되었다.

테스트 코드의 적신호를 제거하며 본격적으로 구현해보자.

---

# MyLinkedList 구현하기

## indexOf()
처음 진행해볼 것은 `indexOf` 메서드이다.

앞서 ArrayList에서 [google docs의 명세](https://docs.oracle.com/javase/8/docs/api/java/util/List.html#indexOf-java.lang.Object-)는 살펴보았기 때문에 해설은 생략한다.

>**HINT** <br/>
*null 을 어떻게 처리할지 고민해보세요.*

### Test Code
테스트 코드는 ArrayList에서 진행했던 것과 동일한 내용이다.

당연히 `List`라는 동일한 인터페이스를 구현하는 것이기 때문에 구현 결과는 동일해야 한다.

~~~java
public class MyLinkedListTest {
    protected List<Integer> mylist;

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {
		mylist = new MyLinkedList<Integer>();
		mylist.add(1);
		mylist.add(2);
		mylist.add(3);
	}

    @Test
    public void testIndexOf() {
        assertThat(mylist.indexOf(1), is(0));
        assertThat(mylist.indexOf(2), is(1));
        assertThat(mylist.indexOf(3), is(2));
        assertThat(mylist.indexOf(4), is(-1));

        assertThat(mylist.indexOf(7), is(-1));
    }
}
~~~
