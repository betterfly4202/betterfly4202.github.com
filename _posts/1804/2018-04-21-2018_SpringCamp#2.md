# 이벤트 기반 분산 시스템을 향한 여정(building, event-driven distribute system with spring, aws)

우아한 형제들 : 박용권

## 배민찬 서비스?
주문 > 요리 > 픽업 > 포장 > 배송 > 전달완료

## SCM(Supply Chain Management) 시스템
>고객에게 제품을 배송하기 위한 일련의 업무 프로세스를 지원하고, 처리하기 위한 시스템

### 지난 1년간 SCM 시스템을 운영, 개발하며 주어졌던 고민과 생각했던 아이디어 그리고 결과물에 대한 이야기

* 독립적으로 실행가능한 애플리케이션을 '서비스' 라고 부름
* 1개이상의 서비스와 공유 인프라가 모여 하나의 시스템을 구성

## 지난 2016년의 배민찬 시스템은
- 사용자 서비스와 백 오피스 모듈로 구성된 모놀리식 시스템
- 상용 온라인 커머스 솔루션을 사용자화
- AWS 에서 운영

이 당시는 오프라인 중심으로 배민찬 서비스를 진행함
- 물류 과정을 엑셀로 수기화 하였기 때문에 오프라인으로 진행할 수 있었음
- 사용자가 많아지고 서비스가 커지면서 더 이상 수작업으로 진행할 수 없었음 >> 자동화 시스템 도입 필요
- 2016년 말, 물류 시스템 도입 결정

기존의 두 시스템을 통합하는 것이 큼

기존 시스템과 새로운 시스템을 연결해주는 어댑터를 생성했음
(스프링 부트기반, AWS Elastic Beanstalk 에서 운영)

- 두 시스템간 이질적인 용어와 모델을 번역하는 역할을 수행
(물류 시스템이 이해할 수 있도록) 두 모델이 통합할 수 있는 역할

- 메세징 기반을 통해 비동기로 시스템간 결합 제거
    - 현재 스토어 시스템은 잘 작동중인데 외부의 다른 시스템이 도입시 비동기로 처리해야 사용자들의 느낄 수 없음
     >수신된 메시지에 대해 역동성을 보장하도록 기능해야함
     
## 어댑터 서비스는 왜 새로운 서비스로 만들어야 했을까
기존 서비스에 적절한 계층으로 만들수있었을텐데?
기존에 배민찬에는 레거시시스템이 복잡하게 꼬여 있다. 오래된 시스템으로 너무 많은 불필요한 기능이 얽혀있었다.
기능 변경시 어떤 수준까지 접근해야하는지 리소스가 너무 많이 발생하고, 사이드 이펙트들이 심화되었다

레거시의 반부패 계층을 제거하고자, 계속해서 오르는 트랜잭션, 쌓여있는 기술부채들 등의 개선을 위해 확장성 있는 시스템 도입 필요했음

### 새로운 기능은 새로운 아키텍처 위에 올리자 >> 어댑터 서비스

**불어나는 기능, 커지는 서비스, 쌓이는 도메인 지식**
새로운 기능이 추가될때마다 모델이 추가되고 작은 계층의 어댑터의 덩치가 커지게 됐다...
업무 지식(도메인 지식)이 쌓이기 시작하면서 점점 그 안의 경계가 보이기 시작했다. 그런 도메인의 경계를 이해하며 SCM 시스템이라는 이름을 붙일 수 있었다.


- 응집력 있는 도메인 개념을 묶어라
    > 패키지 단위로 모듈을 구성했음
    
    도메인의 경계를 따라서 패키지를 분할하고 그 안에서 도메인/애플리케이션/인프라스트럭처 역할인지 등을 나누었음
    
    즉 이런 분할을 통해 DDD에서 말하는 바운디드 컨텍스트라는 개념을 기대했음
    
    
### 왜 모듈화인가?

MSA가 잘 알려져있고 도입하면 되는데 왜...?

그럼에도 왜 했냐면, 도메인을 충분히 이해했지만, 확실하게 도메인을 분리시키기에 이해도가 조금은 부족하다 생각했음 > 리스크가 크다고 생각함 > 잘못수행시 복원하는 위험을 감당하기 위험했음

모듈을 통해 도메인의 경계를 뚜렷하게 만들어가다보면 추후에 MSA로 할 수 있을것이란 기대를 하게됨

이는 추후 서비스의 독립성을 보장할 것이라 기대

#### 모듈을 통한 기대
- 모듈간의 상호작용은 내부 프로세스로 처리
- 단일 트랜잭션 관리로 인해 강력한 일관성확보
    - 함께 변경해야할 데이터는 함께 변경되고, 예외 발생시 함께 롤백되는 트랜잭션을 보장
- IDE 통한 손쉬운 리팩토링 작업
    - 단일 프로젝트/ 단일 코드끼리 객체기반으로 참조하기 때문에 IDE를 통해 일관적으로 리팩토링이 가능했음
    
### 또 다른 모놀리식 시스템화 현상
모듈화를 통한 도메인 구성이 어느정도 성공되었다고 평가함
그럼에도 계속해서 기능이 추가되면서, 모듈간에 직접참조시 서로가 너무 연관성이 크게됨
입출하에 재고관리 기능 추가시 > 재고관리는 구매/생산 연관 
등등 서로간에 강하게 결합성이 높을 수 밖에 없음

상호간의 의존관계를 단순하게 만들기위해서 어떻게 해결해야할까?

이벤트를 통해 모듈간의 결합을 낮출 것이라 기대함

이벤트 기반 아키텍처..??

이벤트 ㅐㅇ산과 소비를 통한 느슨한 결합(Loose coupling)

이벤트 기반으 ㅣ아키텍처는
이벤트를 생산 / 소비 / 이벤트를 전달하기 위한 채널
생산 : 이벤트 발행
소비 : 관심 이벤트가 오면 소비
채널 : 생산자와 소비자의 역할을 전달해주는 역할

스프링은 이러한 이벤트를 손쉽게 사용할 수 있도록 도와줌
### 스프링 애플리케이션 이벤트 매너키즘
<pre>
    @EventListener
    void handle(OrderCompleted order){}
</pre>

-- 이벤트 기반의 모듈을 통해 결합도를 낮출 수 있었다. 의존성도 단순해짐

도메인의 지식을 넓히기 위해 경영학 서적을 읽기 시작함

### 원격 시스템의 ㅈ등장, 통합을 위한 숙제거리..
SCM시스템 외에도 주문/상품 ㅣ시스템 등 서비스가 확대되었다

분산된 시스템을 결합할 아키텍처를 새롭게 형성할 필요가 있었음

객체지향에서 중요한 2가지 요소
- 강합응집력, 느슨한 결합

시스템에서도 마찬가지였음

### 시스템 또는 서비스를 통합하기 위한 세가지 방법
1. 원격 프로시저 호출(Remote Procedure Call)
2. 레스트풀(RESTful API)
3. 메시징(Messaging)

- 원격 프로시저 호출(Remote Procedure Call)
    - 시스템간의 연결을 위해서 공유된 라이브러리가 필요함 > 결합도 상승
    
    
- 레스트풀(RESTful API)
    - 웹이 가진 장점을 가질 수 있는 기술, 분산 시스템에서 적합한
    - 네트워크를 넘어서 넘어가는 과정에서 장애가 발생할 수 있는 통제 시스템 / 트랜잭션 분기시 예외처리 등 관리가 필요함
    
- 메시징(Messaging)
    - 메시징 시스템을 통해 견고한 시스템을 반들 수 있음
    - 비동기 메시지를 통해 전달되기 때문에 결합도도 낮출 수 있고 
    - 시스템이 커질 수록 메시지를 파악하기 힘들 수 있음


기술 외적으로.. 컨텍스트(시스템,서비스)간 협업을 위한 두가지 방식
- 동기(요청 후 응답을 기다림) / 비동기(응답과 상관없이 역할 수행)

## 배민찬은 각 방법의 특성을 고려하여
    - 메시징과 레스트풀 API를 적용한 아키텍처 적용
    
어떤 메세징을 쓸 것인가
- 카프카와 같은 강력한 오픈소스가 존재함, 그밖에도 AWS SQS등

메세징 요구사항
1. 최소한의 운영 비용으로 사용
2. 메시지 전달 신뢰성을 가지고 있는가
3. 단일 메시지가 여러 소비자에게 전달될 수 있는가
4. 수평 확장성
5. 사용하기 쉬움
6. 모니러팅 유무

아래와 같은 메시징 기술 
>Amazon SQS
- 최소 1회 이상 메시지 전달 보장, 최대 14일 유지
- 무제한 확장 가능, 빠른 읽기 처리량

>Amazon SNS
- 발행/구독 모델 지원1;1, 1:N
- 무제한 확장 가능

>Amazon Kinesis


결국 Amazon SNS + Amazon SQS 협업
SNS 발송 > SQS 발행하여 각 서비스에 전달

SNS는 ORDER 시스템에만 존재
SQS는 SCM System에서 존재

시스템 내부에 과한 메시지가 돌아다니지 않도록 필터링의 역할



메시지를 받기 위해 가장 적합한 모듈
Spring Messaging 모듈, 메시징 통합 지원
Spring Messaing
- Message
- MessageChannel
- MessageConverter
- MessageHandler

>> Spring Cloud AWS가 존재함

