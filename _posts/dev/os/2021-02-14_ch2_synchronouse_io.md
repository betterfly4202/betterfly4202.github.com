---
title: "[Operating System] Ch2. Synchronouse I/O & Asynchronouse I/O"
categories: "OS"
tags:
  - Operating System
  - System Structure
  - Program Execution
---

# Synchronouse I/O & Asynchronouse I/O
## Synchronouse I/O
I/O요청 후 입출력 작업이 완료된 후에 제어가 사용자 프로그램에 넘어가는 것

-> 내가 작업한 요청의 결과를 받은 후 그 후속작업을 순차적으로<sub>sequential</sub> 진행하는 경우 사용하는 방식 (일반적으로 `read`에 따른 결과를 처리하는 경우)

### Synchronouse I/O 구현 방법

- I/O가 끝날때까지 CPU를 대기함
- 매시점 하나의 I/O만 일어날 수 있음
-> 동기식 I/O를 처리할 경우 CPU가 I/O요청을 한 후 I/O 결과가 나올때까지 기다려야 한다. 마찬가지로 동시에 하나의 I/O장비에게만 요청을 하기 때문에 다양한 I/O요청이 필요한 경우에도 I/O 장비를 하나밖에 활용하지 못하게 된다.

- I/O요청 후 다른 프로세스에게 CPU를 넘겨준다(이런식으로 해당 프로세스에서 I/O요청이 발생할때마다 다음 작업이 대기 타기 때문에 다른 프로세스에게 계속해서 CPU를 이관함)
- CPU가 쉬지않고 계속 작업을 수행하며, 동시에 CPU의 요청을 받은 I/O장비도 각각 역할을 수행할 수 있음
- I/O가 완료 후  device controller가 interrupt를 발생시켜, CPU는 I/O 후속 작업을 이어서 진행함

## Asynchronouse I/O
I/O가 시작된 후 입출력 작업이 끝나길 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

-> I/O요청을 했지만, 그 결과와 상관없이 프로그램을 가장 효율적으로 활용하기 위해서 사용하는 방식(일반적으로 `write`를 하는 경우)

**Sync & Async 모두 I/O완료 후 Interrupt로 알려줌**

## Sync I/O vs Async I/O 흐름 비교
![](/assets/images/study/dev/2021/os/ch1_sync_async_io.jpg)

그림을 참고하여 Sync I/O와 Async I/O를 비교해보면, `동기식 I/O`는 **user의 요청부터 kernel에서 처리 과정까지 모든 작업 결과를 기다려야 한다.**  
반면에, `비동기식 I/O`는 **user는 자신의 I/O요청을 kernel에게 요청 후 작업 결과를 기다리지 않고 CPU의 제어권을 얻게되어 내가 하던 작업을 이어서 할 수 있다.**  kernel에게 위임했던 I/O작업이 완료되면 위에 언급한대로 interrupt가 발생되며, I/O가 완료됐음을 확인하여 그 후속작업을 이어서 할 수 있게 되는 것이다.

**동기식 입출력 구현예제**  
1. CPU가 낭비되는 방법(`Single Thread` 구현 방식)
   1. 프로그램이 I/O를 요청 후 I/O작업이 끝날때까지 기다린다.
   2. I/O작업이 끝난 후 I/O결과에 따른 다음 작업을 실행한다.

2. CPU를 효율적으로 사용하는 구현 방법(`Multi Thread` 구현 방식)
   1. 프로그램이 I/O를 요청 후 사용하지 않는 CPU를 반환한다.
   2. 반환된 CPU를 다른 프로세스(혹은 스레드)에서 획득하여 자신의 프로세스를 실행한다.
   3. 1~2 반복 -> CPU를 효율적으로 활용

# DMA(Direct Memory Access)
기본적으로 컴퓨터 메모리에 접근할 수 있는건 CPU밖에 없다.  
그런데 I/O가 발생하는 모든 작업들을 하나씩(예를들어 하나의 키를 입력받는데 1byte를 사용하는 경우) 인터럽트를 받게 되면, CPU의 오버헤드가 커지며 효율성이 떨어질 수 밖에 없다.  
때문에 DMA도 메모리에 접근할 수 있도록 하여, I/O장비에서 블록(페이지)단위의 작업을 local buffer에 담아 두고, 작업이 완료되는 시점에 DMA가 local buffer의 데이터를 메모리로 복제 후 CPU에게 알려주어(interrupt)효율적으로 CPU를 활용할 수 있도록 도와주는 것이다.

## 저장장치 계층구조
최상위에 CPU 아래로 다음과 같은 구조로 하드웨어들의 계층을 볼 수 있다.  
![](/assets/images/study/dev/2021/os/ch1_memory_structure.png)

> Primary : CPU에서 직접 접근하는 영역(즉시 실행가능)  
> Secondary : CPU에서 직접 접근하지 못하는 영역

그림과 같이 아래에서 위의 영역(Secondary -> Primary)으로 갈수록 속도가 빠르고, 비용이 비싸고, 휘발성이 강하다는 특징이 있는데 이를 다시 풀어서 보면

- Speed : 저장된 데이터의 처리속도가 빠르다.
- Cost : 단위 공간당 가격이 비싸다.(소프트웨어에서 가격이 비싸다는 것은, 많은 리소스를 필요로 한다 = 귀하다) 떄문에 공간이 작다.
- Volatility : 휘발성이라는 의미는, 세컨더리 영역의 하드디스크(magnetic disk)나 tape에 저장된 데이터는 전원이 종료되어도 디스크내에 보관(*비휘발성*)되지만, DRAM이나 캐시메모리에 사용되는 SRAM, Register에 보관되는 데이터는 전원을 종료하거나 재부팅하는 경우 데이터가 소멸된다(*휘발성*)
## 프로그램의 실행(Memory Load)
![](/assets/images/study/dev/2021/os/ch1_program_execute.png)

그림을 참고하여 **프로그램의 실행**과정을 살펴보자  

1. 일반적으로 프로그램은 디스크(HDD)안에 파일 형태로 저장되어 있다.
2. 프로그램의 실행파일을 실행시, 해당 프로그램의 메모리 공간<sub>address space</sub>이 생성이 된다.
   - 프로세스의 메모리 공간은 각각 code/data/stack 영역으로 구성되어 있다.
      - code : 프로그램 동작을 담당하는 코드 영역
      - data : 프로그램에 사용되는 전역 변수/static변수 등 프로그램에 사용되는 자료구조
      - stack : 지역변수, 매개변수 혹은 함수의 호출 또는 리턴시 데이터를 쌓아두었다가 필요시 사용되는 영역
3. 위 생성된 프로그램의 메모리 공간은 가상공간(Virtual memory)안에서 보관된다.
4. OS를 실행(부팅)시 커널 주소 공간은 메모리에 항상 기본적으로 상주해 있지만, 사용자 프로그램은 실행/종료 시점에 메모리 영역(Physical memory)에 할당되거나 소멸된다.  
  - 프로그램 실행시 vm 메모리 영역을 모두 메모리 영역에 올리는 것이 아니라, 현재 사용되거나 필요한 부분만 효율적으로 메모리에 적재된다.  
  - 위와같이 메모리를 효율적으로 활용하기 위서 필요한 부분은 메모리에 올려두고, 그 외의 데이터는 디스크 `swap area` 영역에 옮겨 놓는다.
    - 위의 경우 디스크가 2가지 영역(File System, Swap area)으로 분리되는데 각각의 용도가 다르다.
      - File System : 프로세스 실행 여부와 상관없이 디스크에 저장되는 **비휘발성 데이터**
      - Swap area : 메모리에 상주중인 프로세스에 대한 swap data를 다루기 때문에, 프로세스 종료시 제거되는 **휘발성 데이터** (메모리의 확장)

## 커널 주소 공간의 내용
프로그램 실행 과정에서 살펴본 내용 중 커널 영역은 운영 체제의 실행을 담당한다.  
그림을 참고하여 커널의 내부가 어떻게 성되어 있는지 화인해보자.
![](/assets/images/study/dev/2021/os/ch1_kernel_address.png)

- code 영역
  - 커널의 핵심 요소 중 하나인 컴퓨팅 자원 관리를 위하여, 자원을 관리하기 위한 코드
  - 사용자가 사용하기 위한 인터페이스를 관리하는 코드(앞서 살펴보았던 파일 I/O 등)
  - 운영체제는 인터럽트가 들어오면 CPU를 얻게된다. 따라서, 각 인터럽트마다 어떻게 처리할것인지에 대한 코드가 구성되어 있다.
- data 영역
  - 운영체제는 기본적으로 CPU, memory, disk등의 자원을 관리하므로, 각 영역의 데이터를 자료구조로 관리하고 있다(그림상 사각형 영역, 직육면체는 물리적인 공간)
  - 현재 실행중인 프로세스가 무엇이고, 얼마나 리소스(cpu, memory 등)을 사용 중인지에 대한 데이터 역시 관리하기 위한 자료구조 => `PCB`<sub>Process Controll Block</sub>
- stack 영역
  - 운영체제 역시 프로그램과 같이 함수구조로 프로그램되어있기 때문에, 함수의 호출 또는 리턴되는 데이터를 보관하는 영역
  - 운영체제는 여러 사용자 프로그램들이 호출하여 실행할 수 있는데(System call), 각 프로세스마다 각자의 커널 영역을 할당하고 있다.

## 사용자 프로그램이 사용하는 함수
OS프로그램, 사용자 프로그램 등 모든 프로그램은 어떤 프로그래밍 언어(Programming Language)를 사용하더라도 함수 기반으로 구성되어 있다.  

### 함수(Function)
- 사용자 정의 함수(User Define Function, UDF)
  - 자신의 프로그램에서 정의한 함수
- 라이브러리 함수
  - 자신의 프로그램에서 정의하지 않고 외부에서 구성된 함수를 포함하여 가져다 씀
  - 자신의 프로그램에 실행 파일을 포함하고 있음
- 커널함수
  - 운영체제 프로그램의 함수
  - 커널 코드의 함수 = 시스템 콜


---

*Reference*

- Operating System Concepts (Paperback / 9th Ed.) Books
- http://www.kocw.net/home/search/kemView.do?kemId=1046323