var store = [{
        "title": "시작",
        "excerpt":"나는 오늘 무슨 일을 했는가.   주 5일, 8시간씩 매일같이 일을 한다. 주말에도 시간이 나는대로 책을보기도, 코딩을 하기도, 웹 어딘가를 방황하기도 한다.   근데 그냥 보면 재미없으니까   뭘 봤고, 뭐가 문제였고, 무엇을 느꼈는지, 무엇을 잘못했는지   뭐라도 써보자.  ","categories": ["notes"],
        "tags": ["개발일기"],
        "url": "http://localhost:4000/notes/diary-start/",
        "teaser":null},{
        "title": "빌드",
        "excerpt":"2018.8.21 오전 10   현재 작업 중인 프로젝트는 국내 운영쪽 서버와 해외에서 운영되는 서버 2가지 버전으로 빌드해야 한다.   리눅스의 웹로직 서버하에 배포되는데 서버 환경이 다르다보니 properties 쪽에 약간의 차이가 있어 따로 빌드를 한다.   그러던 중 문제가 발생했다.   정적인 이미지 파일의 경우 서버에 별도로 저장하여 관리중인데, 루트 경로가 다르다보니 해외서버에서 이미지 경로를 찾지 못하는 이슈이다.   예를들어, 국내는 /home/weblogic/~ , 해외는 /home/oracle/~   이와 같은 경로에 위치하는데,   &lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?&gt; &lt;weblogic-web-app         xmlns=\"http://www.bea.com/ns/weblogic/90\"         xmlns:j2ee=\"http://java.sun.com/xml/ns/j2ee\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://www.bea.com/ns/weblogic/90 http://www.bea.com/ns/weblogic/90/weblogic-web-app.xsd\"&gt;        &lt;container-descriptor&gt;         &lt;show-archived-real-path-enabled&gt;true&lt;/show-archived-real-path-enabled&gt;     &lt;/container-descriptor&gt;      &lt;virtual-directory-mapping&gt;         &lt;local-path&gt;/home/weblogic/v2_webresource_file/&lt;/local-path&gt;         &lt;url-pattern&gt;/webresource/*&lt;/url-pattern&gt;     &lt;/virtual-directory-mapping&gt;      &lt;context-root&gt;/v2&lt;/context-root&gt;      &lt;!--     &lt;session-descriptor&gt;         &lt;timeout-secs&gt;7200&lt;/timeout-secs&gt;     &lt;/session-descriptor&gt;     --&gt; &lt;/weblogic-web-app&gt;   이 중  부분을 빌드시 프로파일 환경에 따라 동적으로 구분해줄 필요가 있다.   사실 maven의 dependency 같은거야 mvn-repository 에서 가져다 쓴게 대부분이고, 간단한 프로파일 설정 정도만 수정해봤지   이렇게 빌드 환경을 구체적으로 커스터마이징해본적이 없어서 여전히 삽질 중이다.   일단 힌트는   &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;warSourceDirectory&gt;${basedir}/src/main/webapp&lt;/warSourceDirectory&gt;                     &lt;webResources&gt;                         &lt;resource&gt;                             &lt;filtering&gt;true&lt;/filtering&gt;                             &lt;directory&gt;src/main/webapp/WEB-INF&lt;/directory&gt;                             &lt;includes&gt;                                 &lt;include&gt;weblogic.xml&lt;/include&gt;                             &lt;/includes&gt;                         &lt;/resource&gt;                     &lt;/webResources&gt;                     &lt;warSourceDirectory&gt;src/main/webapp/WEB-INF&lt;/warSourceDirectory&gt;                     &lt;webXml&gt;src/main/resources-${environment}/weblogic.xml&lt;/webXml&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;   이렇게 설정하니까 /resource-{profile}/weblogic.xml 의 파일이 ~wepapp/WEB-INF/web.xml 로 떨궈지는 것을 확인했다.   그렇다면 저 환경을 통해서  /resource-{profile}/weblogic.xml 의 파일이 web-inf 아래 web.xml로 떨궈졌다는 거니까…   일단 weblogic.xml파일을 읽어 들이는거 까지는 됐다면, 저걸 web.xml 파일로 떨굴 것이 아니라,   web-inf/weblogic.xml 파일로만 떨구는 방법을 찾으면되지 않을까     삽질      자바스크립트내 배열을 초기화하는데 단순히 array = []; 로 초기화가 안돼서 Array.clear(), for loop 으로 빈 객체 삽입, index 별 splice 등 별 짓을 다했는데 리스트의 데이터가 지워지질 않았다.   알고보니 데이터 로딩시 다른 함수가 호출되면서 값을 계속 넣어주고 있었던 것이다.   프로그래밍은 거짓말하지 않는다. 내가 사용한 문법이 확실하다고 생각이 들면, 어디서 문제가 났을지 천천히 되짚어 보자. 하나에만 빠져서 삽질만 하지말고      메이븐 빌드시, 빌드환경에 따라 property 파일을 동적으로 사용해야 했다. maven 설정에 대한 삽질을 거듭하며 조금은 그 원리가 이해되었다. 그리고 마침내 얼추 된 것 같다.   &lt;!-- weblogic 환경 파일 복사--&gt; &lt;plugin&gt;         &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;         &lt;executions&gt;             &lt;execution&gt;                 &lt;id&gt;copy-resources&lt;/id&gt;                 &lt;phase&gt;validate&lt;/phase&gt;                 &lt;goals&gt;                     &lt;goal&gt;copy-resources&lt;/goal&gt;                 &lt;/goals&gt;                 &lt;configuration&gt;                     &lt;overwrite&gt;true&lt;/overwrite&gt;                     &lt;outputDirectory&gt;${basedir}/target/${war.filename}/WEB-INF&lt;/outputDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;directory&gt;src/main/resources-${environment}/&lt;/directory&gt;                             &lt;filtering&gt;false&lt;/filtering&gt;                             &lt;includes&gt;                                 &lt;include&gt;weblogic.xml&lt;/include&gt;                             &lt;/includes&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/execution&gt;         &lt;/executions&gt; &lt;/plugin&gt;   해당 plugin을 배포시 설정하는 프로파일안에 넣어주면 해당 프로파일 빌드시마다 적용된다  ","categories": ["notes"],
        "tags": ["maven","삽질"],
        "url": "http://localhost:4000/notes/build/",
        "teaser":null},{
        "title": "현위치",
        "excerpt":"2018.8.22   오늘은 코딩보다는 다른 곳에 집중해야 했다.   redmine에 등록된 이슈를 분배해야 했고, 그 과정에서 각 담당자들한테 발생한 이슈를 함께 고민했고   무엇보다 내일 가득 잡힌 면접과 코딩테스트에 긴장 + 걱정 + 혼란함으로 일이 손에 잡히질 않았다.   하루에 5군데의 회사를 방문해야한다.   오전 9시부터 4시간동안 코딩테스트가 진행될 것이고   그 후 대략 1시간에서 2시간 간격으로 4군데의 면접을 진행한다.   사실 한군데만이라도 연락왔으면 했는데, 어쨋거나 나를 불러주는 곳이 있다는 것은 정말 반가운 일이다.   1년 반 전. 처음 신입으로 입사 도전을 했을때 50여군데의 지원서를 냈지만 나에게 돌아온 피드백은 5군데도 되지 않았다.   특히 내가 원하던 스타트업이나, 젊은 회사에선 더더욱 나에게 관심이 없었다.   심지어 나에게 QA를 해보는 것은 어떻겠냐고 제의한 곳은 아직도 잊혀지질 않는다. 그 답변을 받은 후 더 좋은 자극을 받은 것 같다.   연초부터 취업을 준비하는 과정에서 엄마의 갑작스러운 입원으로 참 탈도 많았지만, 그 중 운좋게 지금의 회사와 인연이되어 1년 반동안 나름 성실하게 근무했던 것 같다.   정말 아무것도 모르는 멍청이를 데려다 놓고, 월급을 주며 내가 개발자의 길로 들어왔다는게 잘못되지 않았다는 것을 느끼게 해준 고마운 첫 직장이지만,   그 감사함을 뒤로한채, 새로운 도전을 앞두고 있다.     작년에 지원했을때 전혀 피드백도 없던 곳에서 나에게 면접의 기회가 주어진다는 것 자체가 큰 성과이기도 하다.   참 보잘것없는 스펙이고 아직도 너무나 모르는 주니어개발자이지만, 나의 어떤 모습에 궁금함을 느껴 귀한 시간을 내주는 것이다.   그 귀한 시간과 소중한 기회를 쉽게 놓쳐버리고 싶지는 않다.   좋은 결과를 보고 얼렁뚱땅 회사를 옮길 것은 아니지만, 내 현재의 위치를 확인하고자 중간 점검차원에서 하는 것이라는 스스로의 위안을 삼으려 한다.   아마 내일 이시간쯤이면 거의 멘탈이 소멸되어 넋을 놓고 있을 것이다.   잡설은 그만하고 공부하러가자.  ","categories": ["notes"],
        "tags": ["준비"],
        "url": "http://localhost:4000/notes/find-myself/",
        "teaser":null},{
        "title": "도전",
        "excerpt":"2018.8.23   이게 하루에 다 있었던 일인가 믿기지 않을 정도로 너무나 정신 없이 흘러간 하루다.   오늘의 일정은 이러했다.      오전 4시간 코딩 테스트   2시 면접   4시 면접   6시 면접   7시 면접   생각을 잘못했다.   면접 보는 곳의 위치가 비슷비슷해서 차를 갖고가는게 유리할 것이란 생각을 했다. 면접 후 이동하는 것도 그렇고 일찍 끝나면 차에서 좀 쉴 수 있으니까.   하지만 오늘 일정은 내 생각처럼 그리 순탄치 않았다.   오전 9시까지 코딩 테스트를 참석해야하는데, 차를 주차하고 나오니까 8시 40분이었다. 최소 10분전에는 가야지 하는 마음에 서둘러 간 덕분에 늦지 않게 도착했고   코딩 테스트를 볼 수 있었다.   4시간, 5문제. 그리고 인터넷 사용금치. 내 뒤에는 감독관이 지켜보고 있다.   이런 환경 자체가 처음이었고, 당황스러웠다. 물론 구글링을 할 정도의 난해한 내용은 아니었지만(그럼에도 모든 문제를 풀지 못했다.)   항상 구글에 의지하며 코딩하는 습관때문인지 검색을 할 수 없다는 것에 당황했고,   무엇보다 내 뒤에 누군가 내가 코딩하는 것을 보고 있다는 것은 정말 숨이 막혀왔다!   주어진 문제를 다 풀지도 못했고, 여전히 알고리즘에 취약한 내 모습을 보며 확실히 부족한 나의 모습.   몇 주전 내가 가장 희망하던 곳의 온라인테스트를 했을때 문제를 제대로 풀지 못한것이 떠오르면서 1년이 지난 지금도 내 알고리즘 실력은 별로 발전이 없었다는 것에 큰 위기감을 느끼며 오전 테스트를 마쳤다.   서둘러 나와서 2시 면접 장소로 이동했다. 서초구라고 해서 조금 인적이 드문 장소인 줄 알았는데 강남역 사거리 근방이었던 것이다.   아 강남역이 서초구지…   여기 부랴부랴 아주 어렵게 주차를 마치고 서둘러 면접장으로 향했다.   다행히 10분전에 입장을 했고, 면접 담당자에게 연락을 했는데 20분 정도 늦을것 같다고 한다.   어차피 면접 준비도 부족했는데 공부나 하고 있어야지 하는 생각으로 그 회사 탕비실에 앉아 열심히 서칭을 하고 있었다   그런데 시간이 40분이 지났다. 그리고 50분.   다음 면접이 4시까지 입장이고 여기서 30분정도 걸리니까 적어도 3시에는 움직여야 차를 빼고, 주차하고, 이동하는 시간까지 맞을 것 같다.   2시 면접에 2시 55분까지 기다렸지만, 처음 들어와서 20분 늦을거라는 말 이후로 그 어떤 연락도 오지 않았고,   한시간여를 기다린 후 다음 면접일정때문에 들어가보겠다는 문자를 남겼지만 답장 조차 오지 않았다.   아까는 너무 바쁘고 정신이 없어 미처 생각하지 못했는데 지금 생각해보면 정말 분하다.   그 곳에 가기 위해서 애썼던 것과 휴가를 내서 그 자리를 참석했는데, 담당자는 어떤 연락도 오지 않았다.   상식적으로 약속된 면접이 진행이 안되면 최소한 ‘죄송하다’ 또는 ‘다음에 기회가 되면 다시 하자’ 정도의 인삿말 정도는 해야하는게 도리가 아닌가.   너무 괘씸해서 그 회사명을 언급하고 싶지만 똑같은 사람이 될 것 같아 참아야 한다.     그리고 이어서 4시와 6시 면접은 모두 정상적으로 진행했다.   결론적으로 매우 나에게 필요한 시간이었다. 면접이라는 압박감 덕분에 다시 한 번 이론적인, 원론적인 내가 놓치고 있던 부분을 다시 살필 수 있었고   1년 또는 주니어 개발자에게 회사에서 요구하는 기본 실력과 개념. 내가 무엇을 놓치고 있는지 깨달을 수 있던 시간이다.   특히 4시에 진행한 면접은 너무나 인상적인 자리었는데, 마지막 면접관님과 단순히 면접관과 면접자 입장이 아닌, 개발자 선배와 후배의 입장으로   내가 앞으로 어떤 방향으로 공부할지, 젊은 개발자들이 간과하고 있는. 소중한 정보를 많이 구할 수 있었다.     마지막으로 오늘 면접에서 받았던 질문들을 다시 곱씹으며 개념을 쌓아야겠다.      무작위로 나열된 수를 정렬할 수 있는 알고리즘을 설명하시오   이진 트리는 무엇인가요   ‘SPRING’ 이라는 글자를 거꾸로(‘GNIRPS’) 출력하려면 어떻게 할까요   in-order / post-order / pre-order 의 개념을 아시나요? pre-order를 in-order로 표현하는 방법은 무엇인가요? (hint : stack)   spring framework 에서 어떤 모듈을 사용해 보셨나요?   DB에서 DML, DDL, DCL 의 개념        DB에서 index는 무엇인가요       자바에서의 this 와 자바스크립트에서의 this를 설명해주세요   커피숍이라는 클래스를 설계해보세요     위에 질문 묶음은 사실 교과서 적인, 그리고 기본적으로 알아야할 개념들이었다.   부끄럽게도 꽤 많은 것들에 좋은 대답을 하지 못한게 너무나 마음에 걸리지만, 무엇보다 ‘커피숍 클래스 설계’에 대한 질문은 지금까지도 그 충격이 남아있다.   문득 빈 종이와 펜을 주며 커피숍 클래스를 설계하라고 했다.   나는 단순히 이 질문을 역할에 따른 객체의 분리 정도로만 생각을 했다.   물론 역할에 따른 분리가 그 모든 구체적인 것을 포함하겠지만 내가 그려낸 것은 그저 ‘손님객체’, ‘직원객체’, ‘메뉴객체’, ‘매장객체’ 등 으로 나누어 어설픈 UML다이어그램을 그려보였다.   그리고 그 클래스 안에 기본적으로 어떤 메서드를 구현할 것인지 간단히 적어 넣었다.   그러자 질문이 들어왔다.   “메뉴라는 클래스를 조금 더 세부적으로 표현해볼 수 있나요?”   질문의 의도를 파악하려 애썼지만, 나는 그저 메뉴를 커피/빵/쥬스 그리고 제조 방법 등 기능을 분리하는 것만 떠올랐고 썩 괜찮은 대답을 못했다.   내가 어려워하자, 정답은 없는 질문이라고 편하게 생각하라고 시간을 충분히 줬지만 만족할 만한 답을 내지 못했다.   그리고 조심스럽게 질문의 의도를 설명해줬다.   예를들어 이런 것이다.   메뉴를 구체화 하다보면 커피안에 여러가지 커피의 종류가 있기 때문에 이것은 템플릿 메서드 디자인 패턴을 통해 구현 가능할 것이고,   커피에 샷을 추가할지, 시럽을 추가할지 등 옵션이 계속 붙는 것은 데코레이터패턴으로 구현이 가능할 것이고   전체적인 구조는 어떻게 가져갈 것이며, DB 스키마는 어떻게 정리하는 것이 좋을 것이고 등등..   처음 듣는 얘기가 아니다. 내가 면접 직전에 보았던 빌더패턴으로 메뉴에 포함되는 매개변수들을 나여할 수도 있는것이다.   내 머리가 트이는 질문을 받고 꽤 큰 충격에 아직도 어안이 벙벙하다.     많은 면접은 진행하지 못했지만 무엇이 부족한지, 내 위치가 어디에 있는지 충분히 느낄 수 있었다.   새로운 기술, 그럴싸해보이는 것들은 그만 좇고 본질을 다시 돌아가자.   기본부터..  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/challenge/",
        "teaser":null},{
        "title": "Life Cycle(...?)",
        "excerpt":"2018.8.24   구성은 이러했다.   A라는 컴포넌트가 있다.      A컴포넌트에서 생성한 모달창에서 save가 성공적으로 이루어지면, B라는 컴포넌트의 화면으로 전환되며, 해당 컴포넌트에 속한 dataLoad 함수를 호출하는 것이다.    머릿속에 그려지는대로, A 컴포넌트의 save 이벤트가 성공하면 router를 통해 B컴포넌트로 이동했고, B컴포넌트의 메서드를 호출해야하기 때문에 EventBus를 태웠다.   정확한 소스는 기억나지 않지만 대략 이런식이다       // A component     EventBus.$emit(\"data-load\");       // B component     mounted (){         EventBus.$on(\"data-load\", function() {             this.dataLoad();         });     }   대략 이런 방법으로 이벤트를 발생시켰는데 여기에는 많은 문제가 있다.   내가 이해한 것이 정확한것인지 모르겠지만   A에서 보낸 EventBus가 B에 도착할때, 과연 B 컴포넌트의 인스턴스는 완전히 생성이 된 후 실행되는 것인가?   우선 위와 같이 메서드에 접근하면 실행이 되지 않는다.   EventBus를 통해 접근하는 dataLoad라는 메서드는 this로 접근할 수 없다.   임시 변수로 this를 받아서 접근하면 가능하다.       mounted (){         var temp = this;         EventBus.$on(\"data-load\", function() {             this.$nextTick(function () {                 temp.dataLoad();             )}         });     }   접근을 굳이하자면 위와같이 접근이 가능한 것으로 보인다.   nextTick을 통해 화면이 랜더링된 후 메서드를 접근했는데, 중요한건 dataLoad()라는 함수를 호출한다고 끝나는 것이 아니다.   그 안에 바인딩되는 데어터들도 모두 B컴포넌트에 직접 접근해야했는데(this) 위와 같이 접근해서 결과를 반환한다고 해도 B컴포넌트의 데이터셋에 바인딩되지 않았다.   EventBus를 통해 보내는 시점에 내가 접근하고자 하는 B component의 인스턴스가 생성되지 못한 상태인 것으로 보인다.   사실 지금 이시점에도 이렇게 접근하는 것이 정확히 왜 잘못됐는지 이해되지 않는다.   하지만 안되는것을 계속 붙잡고 있을 수 없었고 다른 방법을 고민하던 끝에 처음했던 별로 훌륭해보이지 않는(?) 방식으로 해결했다.     이벤트 버스를 보내는 것이 아니라, $Router를 통해 이동할때 parameter를 함께 전달하여 해당 문자가 있을때 내가 호출하고자 하는 메서드를 호출 한다.   기본 URI가 ‘/move-component’ 라면      this.$router.push(‘/move-component/dataLoad’) –&gt; ‘dataLoad’라는 문자를 넘겨주며 B 컴포넌트 이동   B컴포넌트에서 mounted()시 라우팅 props 값 확인 ( if(this.value == ‘dataLoad){} )   가장 심플하고 쉬운 방법이다.   단순히 이벤트를 호출한다는 생각에 빠져 이벤트버스를 태우겠다는 집념으로 3시간여를 삽질을 하다가 결국 10분도 안돼서 저 방법으로 해결되었다.   삽질해보는건 좋은데, 뭘 모르는지 꼭 점검하자      vue.js Life cycle   this   rendering   ","categories": ["notes"],
        "tags": ["vue.js"],
        "url": "http://localhost:4000/notes/vuejs/",
        "teaser":null},{
        "title": "element...?",
        "excerpt":"오늘의 삽질   A component 안에 A-1 이라는 component를 import 하여 사용중이다.   대략적으로 아래와 같은 구조이다.    &lt;template&gt;     &lt;div&gt;     &lt;button @click=\"nextPage()\"/&gt;     &lt;tiny-slider ref=\"slider\"/&gt;     &lt;/div&gt; &lt;/template&gt;    “template” 는 현재 주 Component이며, “tiny-sldier” 라는 외부 Component를 import 한 형태이다.   이 상황에서 tiny-slider의 이벤트를 발생시키기 위해서는  this.$refs.slider.goTo(); 와 같이 실행한다.   실제로 tiny-slider의 goTo 메서드는 슬라이더 내의 페이징처리를 해주는 역할을 한다.   내가 할 일은 이제 저 페이지가 현재 몇페이지인지만 찍어주면되는 아주 간단한 작업이다.   그래서 다음과 같이 구현했다.    &lt;template&gt;     &lt;div&gt;     &lt;button @click=\"nextPage()\"/&gt;     &lt;p&gt;  /  &lt;/p&gt;     &lt;tiny-slider ref=\"slider\"/&gt;     &lt;/div&gt; &lt;/template&gt;   &lt;sciprt&gt; // Vue 선언부 data : {     currentPage : 1,     totalPage : '' }  method : {     nextPage(){         if(this.currentPage &lt; this.totalPage){             this.currentPage += 1;         }          this.$refs.slider.goTo();     } }  &lt;/script&gt;   현재 페이지가 전체페이지보다 작을때 페이지의 값을 +1 해주는 아주 단순한 함수이다.   그런데… nextPage() 함수를 호출되며 currentPage의 값이 1씩 계속 증가하지만 tiny-slider의 페이지는 넘어가지 않고 제자리에서 돌기만 한다. 그리고 currentPage &gt; totalPage 상태가 되어서야 tiny-slider의 페이징이 이루어 진다.   다시 말해 if문을 통해 this.currentPage 변수에 변화가 일어나지 않을때, 그제서야 화면이 슬라이드된다.   오전에 계속 문제를 해결하지 못했고, 과장님이 담배를 태우러 나가실때 따라나가 여쭤봤다.   늘상 말씀하시듯, ‘잘해봐… 잘생각해봐…’ 라는 짧은 대답과 함께 엘리먼트가 생성이 제대로 됐는지 확인해보라고 하신다.   엘리먼트가 생성이 안됐다…? 버튼 엘리먼트가 생성이 안되었던 것일까   왜 현재의 컴포넌트에서 이벤트가 일어날때 참조된 컴포넌트의 이벤트가 작동되지 않는것일까   이것말고도 오늘은 webpack 빌드시 less파일을 compile하는 이슈도 있었지만 이것 역시 해결하지 못했다.   오늘은 아주 찜찜한 퇴근을 했다.   심지어 키보드에 커피를 쏟아서 고장난 상태이다.   어제부터 계속해서 비가 내리고, 핸드폰에선 비를 조심하라는 재난문자가 폭주한다.   내 마음에도 비가 내리는 적적한 하루다.  ","categories": ["notes"],
        "tags": ["vue.js"],
        "url": "http://localhost:4000/notes/vue-js_2/",
        "teaser":null},{
        "title": "Component의 힘",
        "excerpt":"오늘의 메인작업은 전체 검색필터의 수정이었다.   1차 프로젝트가 거의 막바지에 왔을때, 페이지마다 별도의 필드를 갖고있는 검색 필터를 구현해달라는 요청이 있었다.   ‘필요한 화면이 10개는 족히 넘을텐데 이제와서 이걸 만들어 달라니…’ 혀를 차며 두 손, 두 발 다 들어야할 지경이었다.   하지만 또 안하고 버틸 수 없는 노릇이니 방안을 구색하던 중, 검색필터의 조건이 화면별로 다르지만 그 중 공통되는 영역이 있었다.   그러면 이 공통되는 영역과 기본 틀을 갖고 있는 컴포넌트를 하나 만들어 놓고, 필요한 곳에 이 컴포넌트를 가져다가 필요한 필드만 추가해서 사용하도록 구현했다.   컴포넌트 이것이 vue.js를 쓰며 체감했던 강력한 장점 중 하나이다.  일반적인 jsp 방식으로 했다면, 많은 중복된코드와 각 화면별로 지저분한 코드를 양상하며 많은 시간을 투자하여 개발했을 것이다.   Vue.js를 통해 서비스별로 컴포넌트를 분리하여 필요한 곳에 알맞게 붙여 사용한다.   물론 jsp에서 include를 하거나 moudle화 하여 사용할 수 있겠지만, Vue.js와 같은 front-end framework 들은 이러한 작업의 수고를 덜어주고 코드 관리가 용이하다.     과거 그렇게 컴포넌트화 하여 구현했던 검색필터에 수정 작업이었다.   필터에 새로운 필드가 추가되었고, 다중 선택이 가능한 조건임에도 기존에 ‘=’ 쿼리로 되어 있는 것을 ‘IN’쿼리로 변경했다. 그리고 중간에 저장이 안되는 필드도 존재했다.   이처럼 버그가 산발적으로 일어나는 상황이지만, 결국 하나의 컴포넌트만 처리하여 모든 문제가 말끔히 해결되었다.   혹시 모를 예외상황을 위해서 이 컴포넌트가 적용된 상위 컴포넌트에 테스트가 필요하겠지만, 꽤 오랜 작업이 될 수 있는 것을 수 시간만에 해결했다.   ","categories": ["notes"],
        "tags": ["vue.js","components"],
        "url": "http://localhost:4000/notes/component/",
        "teaser":null},{
        "title": "slash & back slash",
        "excerpt":"새로운 삽질을 했다.   작업 내역은 Log4j를 통해 기록하는 로그들의 로그레벨을 변경하고(DEBUG -&gt; INFO) 해당 로그파일을 롤링하는 작업이다.   워낙 가이드가 많기 때문에 설정에는 큰 어려움이 없다.   로컬 개발환경은 윈도우니까 내 환경에 맞는 로컬 경로를 설정하면 될것이고, 배포될 웹로직 서버는 리눅스니까 해당 경로만 잡아주면된다.   파일 롤링은      log4j.appender.logfile=com.wily.org.apache.log4j.DailyRollingFileAppender log4j.appender.logfile.DatePattern=’.’yyyy-MM-dd    위 설정과 필요에 따른 설정값을 세팅해주면되는데,      &lt;appender name=\"dailyLog\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt;         &lt;param name=\"Append\" value=\"true\"/&gt;         &lt;!--&lt;param name=\"ImmediateFlush\" value=\"true\"/&gt;--&gt;         &lt;param name=\"Threshold\" value=\"INFO\"/&gt;         &lt;param name=\"File\" value=\"D:\\logs\\dailyLog.log\"/&gt;         &lt;param name=\"DatePattern\" value=\"'.'yyyy-MM-dd\"/&gt;         &lt;param name=\"MaxFileSize\" value=\"1MB\"/&gt;         &lt;param name=\"MaxBackupIndex\" value=\"1\"/&gt;         &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt;             &lt;param name=\"ConversionPattern\" value=\"%d{HHmmss.SSS} [%-5p] %c{1}.%M():%L %m%n\"/&gt;         &lt;/layout&gt;     &lt;/appender&gt;   대략 위와 같이 설정을 했다.   그런데 아무리 해봐도 파일 생성이 안되는 것이다.   설정값이 잘못되었나 싶어서 구글링해서 나오는 거의 모든 서로 다른 설정은 다 적용해본 것 같다.   문제의 근본적인 원인을 모르니 계속 삽질은 거듭되었다. 몇시간동안 그렇게 사투끝에 다시 한 번 자세히 들여다 보았다.   혹시나 싶었다.       &lt;param name=\"File\" value=\"D:\\logs\\dailyLog.log\"/&gt;   위 경로설정을 아래와 같이 바꾸어 주었다.       &lt;param name=\"File\" value=\"D:/logs/dailyLog.log\"/&gt;   기존에 왜… 굳이 왜 역슬러쉬를 사용했는지 모르겠다. 역슬러쉬를 써야 컴파일하면서 슬러쉬로 인식된다는 이상한 착각에 빠져있던 것 같다.     역슬러쉬의 문제였다.   늘 그렇듯 이런 삽질끝에는 큰 자괴감이라는 쓰나미가 몰려온다.   그래서 조사했다. 역슬러쉬와 슬러쉬의 차이점을…   이건 포스팅 자료에 등록해야겠다…   ","categories": ["notes"],
        "tags": ["log4j","path"],
        "url": "http://localhost:4000/notes/1809_1/",
        "teaser":null},{
        "title": "Webpack Memory Leak",
        "excerpt":"웹팩 환경 아래에서 Vue.js 작업을 하며 소스코드를 변경하여 저장하면, 핫 리로드가 되면서 가끔씩 서버가 죽어버리는 현상이 발생한다.   아니 가끔이 아니라, 꽤 자주. 그리고 점점 더 빈번하게.   그리고 콘솔에는 다음과 같은 로그가 찍힌다.   Security context: 0000023290225879      1: fromString(aka fromString) [buffer.js:314] [bytecode=0000028B95FE9031 offset=164](this=00000066F9F822D1 ,string=0000026B6ACAC8C9 &lt;Very long string[44331659]&gt;,encoding=0000023290235001 &lt;String[4]: utf8&gt;)     2: from [buffer.js:177] [bytecode=0000028B95FE8B39 offset=11](this=0000001BB8136359 &lt;JSFunction Buffer (sfi = 000002329027BF81)&gt;,value=0000026B6ACAC8C9 &lt;Very long string[4...   FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory  1: node_module_register  2: v8::internal::FatalProcessOutOfMemory  3: v8::internal::FatalProcessOutOfMemory  4: v8::internal::Factory::NewRawTwoByteString  5: v8::internal::Smi::SmiPrint  6: v8::internal::StackGuard::HandleInterrupts  7: v8::String::WriteUtf8  8: v8::internal::wasm::AsmType::Extern  9: node::Buffer::New  …   사실 정확히 어디서 메모리 누수가 발생하는지 원인은 파악하지 못했지만 (아마도 Node.js 서버환경이 최적화되거나 힙 메모리 초기화를 하지 않은 문제이지 않을까…?)   위와 같이 Memory Leak 현상이 발생했다.   해결법은 의외로 간단했다.   현재 webpack 빌드 환경(package.json)은 다음과 같이 선언되어있다.       \"dev\" : \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\"   위 빌드 환경에 옵션을 조금만 추가해주면 이 문제를 해결할 수 있다.       \"dev\": \"node --max_old_space_size=8000 node_modules/webpack-dev-server/bin/webpack-dev-server.js  --inline --progress --config build/webpack.dev.conf.js \",   대략적으로 Node.js의 힙 메모리가 OS에서 할당하는 메모리를 초과하면서 발생하는 현상으로 강제로 할당량을 늘려버려서(node –max_old_space_size=8000) 문제를 해결한 것으로 보인다.   이게 근본적인 문제를 해결한 것이 아닌 것 같아 영 찝찝한 기분이 남는다.   자바스크립트의 메모리 관리를 찾아보며 Javascript의 GC 프로세스 및 메모리 관리하는 것에 대한 좋은 블로그들을 만날 수 있었다.   자바스크립트는 어떻게 작동하는가: 메모리 관리 + 4가지 흔한 메모리 누수 대처법    Node.js의 GC는 어떻게 동작하는가?   ","categories": ["notes"],
        "tags": ["webpack","memory leak"],
        "url": "http://localhost:4000/notes/1809_2/",
        "teaser":null},{
        "title": "그냥은 없다",
        "excerpt":"Request processing failed; nested exception is org.springframework.jdbc.UncategorizedSQLException: Error setting null for parameter #1 with JdbcType OTHER . Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. Cause: java.sql.SQLException: 부적합한 열 유형: 1111     mybatis를 사용해봤다면 수도없이 많이 봤을 에러.   부적합한 열 유형: 1111   정말 흔하게, 사소한 또는 부주의한 실수로 발생하는 에러다.   대부분 오탈자 또는 데이터타입이 맞지 않아 발생하는 경우다. 사실 이런 에러는 처리하기 그리 까다롭지 않다.   쿼리시 어떤 파라미터가 전달되는지만 꼼꼼히 따져보면 금방 나올 수 있기 때문이다.   이경우는      Error setting null for parameter #1 with JdbcType OTHER    첫번째 파라미터 타입이 null 이라는 것으로 보인다.     그런데…   아무리 뒤져봐도 파라미터 타입이나 내용에 문제가 보이지 않았다.   어떤 컬럼을 접근할때 문제가 발생했는지도 파악했는데 전혀 문제가 없어 보인다.   너무나 답답했다. 분명 별것도 아닌건데… 이런걸로 헤매고 있는 것 자체가 스스로 답답했다.   계속 같은 부분을 테스트하면서 같은 작업을 수도없이 반복했던 것 같다.   그러다 문득 생각이 들었다.   설마…?   이 쿼리는 어떤 필터항목을 저장 후 불러오는 쿼리인데, 저장하는 과정에서 이 컬럼에 엉뚱한 값이 들어가고 있었던 것이다.   애초에 저장자체가 잘못되고 있는 것을 확인하지않고, 너무나 당연하고 기본적으로 먼저 확인할 부분을 안보고 현재 일어나는 현상만 붙잡고 있었던 것이다.   사실 약간 마음이 떠 있어서, 급한 마음에 ‘대충’ 처리하고 싶었던 것 같다.   그 안일한 생각 덕분에 몇시간을 오히려 더 큰 고통을 받으며 시간을 허비해버렸다.   프로그래밍의 가장 큰 매력은 ‘그냥’ 이 없다는 것이다.   ‘그냥’되거나, ‘그냥’ 안되는건 없다.   정말 정확한 input과 output만 있을 뿐이다.   내가 input한 만큼만 output된다.   더 되지도, 덜 되지도 않는다. 정확히 내가 하는 행동에 덜하거나 더해지는 행위를 하지 않는 아주 솔직하고 정확한 작업이다.   중요한건 마음가짐이겠지.  ","categories": ["notes"],
        "tags": ["삽질"],
        "url": "http://localhost:4000/notes/1809_3/",
        "teaser":null},{
        "title": "난 놈",
        "excerpt":"   넌 난 놈이니까 어디가서든 잘할거야      일년 반.   절대 길지 않은 시간이다. 짧게 그리고 나름 굵게 한 첫 회사를 마무리하게 되었다.   개발자라고 들어온 (뇌가)뽀송뽀송한 신입이 이제서야 써먹을만큼 가르쳐놨더니 이직을 한다고 하니, 회사 입장에선 큰 손실이고 배신감을 느낄 수 밖에 없을 것이다.   아마 팀장님이 그러한 감정이 가장 심하셨던 것 같고 사실 퇴사를 얘기할때부터 끝까지 협조적이지 않아 원망을 한 시간도 있었다.   하지만 공식적으로 마지막 출근을 마치고 왔다.   회사에서 사용했던 모든 물품들(개인적으로 사용한 다이어리를 제외한)은 회사의 동료들에게 모두 나누어주었다.   주변에선 나름 비용도 나가고 이직해서도 쓸만한 것들인데 왜 안가져 가느냐 했지만   “빈 손으로 왔으니까 빈 손으로 간다” 라고 너스레를 떨면서 동료들에게 나누었지만 사실 그게 내 마지막 감사함의 표현이었다.   특별히 선물을 준비하지 못하고 고작 사용했던 그 물건 몇개로 대신하는게 치사하지만, 내 나름의 감사함을 대신 표현한 것이었다.   인수인계를 다 마치고, 서류 결재도 모두 마무리되고 할 일이 없어졌다.   기술 블로그를 뒤적거리는 중에 자연스럽게 창천향로님의 블로그를 방문하게 되었다.   그리고 정말 우연히도 그 많은 글 중에 2년 전 글인데, 자신의 면접관으로 참관했던 팀장님이 구글로 이직했다는 이야기 였다.   자신이 그분과 함께 있는 2년 가까이 동안 나름 열심히해서 분명 실력이 늘었다는 것을 느꼈고, 조금은 그 분과 가까워 지지 않을까 생각했는데 그 분은 자신의 성장 보다 더 큰 성장을 하여 구글로 입사를 했 그 격차가 더 크게 벌어졌다는 것을 느끼며 자신이 한 노력이 작게 느껴진다는 내용이다.   너무나 공감이 되기도하고 한편으론 조심스럽기도하다.     내가 개발을 하며 가장 크게 마음 먹은 것이 ‘남들이 걸을때 나는 뛰어가자’ 는 생각이었다.   주위에서 보면 조금 조급해보일수도 있고 허둥지둥대는 것으로 보일 수 있겠지만 이것이 내가 개발자로 인정받고 성장하고 싶어 발버둥 치는 것이었다. (사실 발버둥 치는 것에 비해 실속없이 보낸 시간이 많은 것은 함정)   나는 주로 창천항로님의 블로그를 보며 자극 받는다.   창천항로님의 블로그를 보며 매일 새로운 것을 공부하고, 그것을 공유하고 끊임없이 자신을 발전시키고자 노력하는 그 열정이 나에게도 느껴질 정도라면 본인은 정말 얼마나 치열하게 살아가는 것일까 생각이 들기도 한다.   그렇게 치열한 하루 하루를 보내고 있는 분도 자신의 노력이 작게 느껴진다고 회의감을 느끼는걸 보면서 내 모습에 스스로 회의감이 들기도 했다.   여기까진 공감이 되는 부분이다.   하지만 조심스러운 부분은 기준이 ‘남’이 되는 순간 회의감과 자책감, 자괴감들이 몰려온다.   창천향로님이 말했듯 어제의 ‘나’, 연초의 ‘나’와 비교했을때 성장했다면 그걸로 된거다.   나도 열심히 한다고 했지만, 주변에 나보다 더 일취월장하는 사람을 보면 조급해지는 것도 당연하고, 내가 엄한 곳에 삽질을 하고 있나란 생각이 들기도 할 것이다.   하지만 냉정히 그들의 출발선이 나와 다를 수 있을 것이고. 그들이 내가 보이지 않는 곳에서 얼마나 더 큰 노력을 했는지 알 수 없다.   나 스스로 조급하지 않으려고 이렇게 마음속으로 생각을 하곤 한다.   그렇다고 나태해지면 안된다. 이 모든 것은 내가 치열하게 준비해가고 최소한 남들 만큼, 또는 그 이상을 노력했다는 것을 전제로 한다.     그 동안 말을 아끼시던 팀장님이 오늘 퇴사를 앞둔 시점에 마지막으로 악수를 하며 이렇게 말씀하셨다.      넌 난 놈이니까 어디가서든 잘할거야    근래에 내가 들었던 말 중 가장 큰 칭찬이었고, 저 한마디로 내가 지난 1년 반동안 그래도 틀리진 않았구나 라고 보상 받은 기분이었다.   ‘난 놈’ 이란 표현을 좋아한다. 특별하다는 의미일 것이다.   더 열심히 노력해야겠다.   10월부터 개발자로서 두번째 삶이 시작된다.   더 날고 싶다. 더 날기 위해서 훨씬 더 많은 노력이 필요하다. 남들이 걸을때 뛰어야 한다.   일주일간 잘 정비하여 10월부터 새로운 도약을 준비해야겠다.  ","categories": ["notes"],
        "tags": ["퇴사"],
        "url": "http://localhost:4000/notes/1809_5/",
        "teaser":null},{
        "title": "개발 2막",
        "excerpt":"기다리던, 한편으론 걱정스럽기도 했던 첫 출근이었다.   걱정보단 설레임이 컸는지 내심 출근이 기다려지기도 했다.   오전 시간은 가볍게 오티로 시작을 했고, 프로필 사진도 찍었다.   그리고 잠시 후 멘토라는 분들이 와서 우리를 데리러 왔다. 1:1 매칭된다는 멘토는 다름아닌 내 ‘사수’ 이다.   어색한 인사와 함께, 궁금한게 무엇이냐고 하는데 뭐가 궁금한지도 모른다. 가서 무슨일을, 어떤 환경인지도 모르기 때문에.   일단 많은 말은 하지 않았다. 바로 팀으로 이동했다.   이동하여 실장님과 우리 팀분들 그리고 나와 인터뷰를 진행했던 우리 팀장님께 인사를 드렸다.   전체적으로 인상들이 너무 좋았고, 특히 팀장님은 ‘잘 왔어요’ 라며 반겨주셨다. 굉장히 인상적인 인사였다.   그리고 무엇보다 마음에 들었던 것은, 내가 그토록 원하던 개발환경이었다.   내 자리에는 맥북이 있었고, 해상도 좋은 모니터 두 대와 매직 마우스와 키보드까지 세팅해 주었다.   그리고 cloud platform을 이용한 개발.   다 내가 꿈꾸던 개발환경과 구성이다.   첫 날이니 만큼, 기본 환경을 세팅할 것을 주문했고, 무엇보다 사용할 물건들과 소프트웨어들에 대한 권한 요청이 최우선이었다.   각종 계정 접근 권한 및 라이센스 발급에 필요한 결재만 2시간 이상 작성했던 것 같다.   결재라인도 손에 익지 않고, 아직은 헷갈리는 VPN, VDI등과 JIRA와 Confluence와 같은 atlassian 제품을을 사용한 것도 즐거웠다.   모든 과정들이 마냥 즐겁기만하다.   새로워서 좋은 것도 있지만, 이제서야 내가 원하던 밥상이 차려진, 내가 좋아하는 고기만찬들이 상에 올라온 기분이다.   모든 것이 순조롭고, 내가 할 일도 명확하다. 나만 잘하면 된다.   하지만 역시, 기대도 되고 걱정도 된다.   앞으로 할 일이 무엇일까 기대도 되고, 잘할 수 있을까 그리고 잘해야 된다는 걱정도 된다.   잘 할거다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_1/",
        "teaser":null},{
        "title": "Back-end 개발자",
        "excerpt":"Back-end 개발자  내가 무엇을, 무슨일을 하게 될지 꽤 명확헤 졌다.   우리 실의 역할은 사용자 별 추천서비스를 제공해준다.   사용자의 데이터를 수집하여, 행동을 분석하고 그들에게 필요한 상품을 예측하여 추천해주는 것이다.   궁극적으로는 위처럼 간단하지만 그 안에서 꽤 많은 업무 프로세스가 필요하다.   데이터를 분석하여 예측 및 추천해주는 일련의 과정은 분업화되어 추천서비스팀 등에서 업무를 관할한다.   우리팀의 역할은 레거시 데이터는 제외시키고 유효한 토큰값을 판별하고, 데이터를 가공하여 그들이 분석 및 활용에 사용할 수 있도록 처리하는 Back-end개발 중에서도 Back-end개발이다.   결국은 이 과정에서 많은 데이터를 관리하고 처리해줄 수 있는 성능 좋은 서버 또는 미들웨어가 필요하다.   그러한 미들웨어 역할을 해주는 것으로 우리는 GCP를 사용하는 것이고, 우리팀의 업무는 회사의 업무를 관장하기 위해 필요한 중간 지점의 데이터를 처리하는 미들웨어 역할을 하는 것이다.   개발자 중에서도 무수히 많은 다양한 직군들이 존재하지만  보통 웹개발자라고 하면 프론트엔드-백엔드로 분리가되어 진로를 결정한다.   첫 회사에서는 사실 이러한 경계가 없는 풀스택이라고 하기도 모호한 ‘웹 개발자’였다.   하지만 자바의 매력을 느끼고, 왜인지 모르겠지만 낯선 리눅스 환경에서의 개발 환경을 동경하고 서버 구축등에 관심을 가지며 백엔드개발자가 되리라는 막연한 목표만 갖고 있었다.   하지만 요즘 하나씩 회사에서 업무를 접하며 새로운 개념들, 말로만 듣던 서비스들을 눈 앞에서 목격하면서 조금씩 나의 역할이 무엇인지 눈에 보이고 내가 무엇을 담당하게 될지 알아가는 과정에서 더욱 욕심이 나기 시작한다.   항상 섣부른 의욕이 앞서는 것을 경계해야하지만, 지금 갖고 있는 이 설레임과 열정은 오래 간직하고 싶다.  ","categories": ["notes"],
        "tags": ["gcp"],
        "url": "http://localhost:4000/notes/1810_2/",
        "teaser":null},{
        "title": "미션-1",
        "excerpt":"첫번쨰 임무   열흘정도 분위기를 파악할 수 있는 시간이 있었다.   우리는 GCP라는 클라우드 플랫폼을 사용하며 서비스를 진행했고, 생소했던 커맨드를 이용한 개발 작업, 쉘 스크립트 그리고 많은 작업이 배치 스케줄을 돌리기 때문에 크론 잡 그 중, embulk라는 훌륭한 오픈소스까지 접해볼 수 있었다.   대부분 말로만 듣던 환경 위에서 작업한다는 설레임과 항상 웹개발(스프링과 메이븐)위주로 작업의 싫증을 느끼던 때 단비같은 이런 작업들은 너무나 즐거웠다.     그러던 중 마침내 첫번째 입무가. 아주 뜬금없이 떨어졌다.   오전에 알 수 없는 스케줄 관련 메일이 전달되었다.   15일 : 푸시 배치 작업   17일 : 연동 테스트   ~~   22일 : 리얼 배포   나랑 상관없는 일인가 싶어 별로 신경을 쓰지 않고 있었는데, 잠시 후 팀장님이 잠깐 회의를 하자고 하신다.   아니나다를까 방금 받은 메일 스케줄을 언급하시며, 15일까지 푸시 배치 프로그래밍 작업이 필요하다고 하셨다.   그리고 작업에 필요한 환경 구성과 전체적인 비지니스 로직에 대해서 설명해주셨다.   사실 그리 복잡한 작업은 아니다.      A서버 a테이블의 정보를 가져와서, B서버 a,b,c 테이블에 분기시키는 작업이다.    위 작업을 위해 다음의 과정이 필요했다.           embulk를 통해 A서버 a테이블을 B서버 a테이블로 데이터 이관 -&gt; cron-job            Google App Engine을 이용한 개발       embulk를 통해 데이터 이관하는 작업은 A서버의 접근이 구글 클라우드 서버를 통해서만 접근이 가능하여, 클라우드 서버에 잡을 돌려 데이터를 이관시키는 작업이 필요했고, 잡을 통해서 가져온 데이터를 프로그래밍하여 B서버의 각 테이블에 적재시키면 된다.   우선 업무 프로세스와 필요한 환경은 얼추 이해되었다.   낯선 개발환경에서 어떻게 개발을 시작해야할지 쉽게 떠오르진 않지만, 열흘만에 주어진 업무도 즐겁고 작업해야하는 내용도 기대된다.   하지만 한편으론 역시 걱정된다. 나는 이해했다고 생각했는데 막상 작업의 진전이 없거나 분명 어느정도 한다고 생각하고 맡겼는데 결과를 내지 못한다면 내 첫 인상, 그리고 신뢰를 쌓을 수 없을 것이다.   처음 맡는 작업이니만큼 더 각별하게 신경써서 작업해야겠다.   ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_3/",
        "teaser":null},{
        "title": "미션-2",
        "excerpt":"첫번쨰 임무 두번째 이야기   embulk를 통해 A서버 a테이블을 B서버 a테이블로 데이터 이관 -&gt; cron-job   embulk는 굉장히 훌륭한 오픈소스이다.   기본으로 제공해주는 docs에도 아주 상세하고 친절하게 사용방법이 나와있어서 어렵지 않게 작업할 수 있었다.   특히 인상싶었던 것은, embulk를 통해 디비 작업을 하면 mysql 기준으로 스스로 merge를 해준다.   예를들어,     A서버 a테이블의 a-1,a-2,a-3의 필드를 B서버 b테이블의 b-1, b-2, b-3 테이블로 이관하고 싶다면,    보내는 서버(in)의 정보와 쿼리, 그리고 받는 서버(out)의 정보와 테이블명을 기입해준다면,   만약에 B서버에 입력받을 b테이블에 대한 스키마 정보가 없다면, 입력하는 스키마 정보(A서버의 a테이블)와 동일한 테이블이 생성되며 데이터까지 적재된다.(단순 insert 뿐만 아니라, merge처리까지 자동으로 됨)   아주 효율적이고 강력한 기능이 아닐 수 없다!   덕분에 첫번쨰 작업 embulk를 이용한 크론잡은 해결됐다.   Google App Engine을 이용한 개발   이제 본격적인 작업이다. GAE(Google App Engine) 사용도 처음이고, 그보다 거의 모든작업은 Spring Framework/Boot 환경을 통해서 작업했는데 스프링을 사용하지 않고 Maven과 servlet환경으로 처리한다는 것 자체가 처음에 감이 잡히질 않는 것이다.   너무나 맹목적으로 ‘Maven-Spring’을 한 세트처럼 사용해왔기 때문에 이 둘을 분리하여 어떤 작업을 한다고 생각도 하지 못했다.   한편으론 이것이 가장 즐거운 일이기도 하다.   servlet만을 사용하여 웹 개발을 한 것은 개발을 거의 처음 배울때 잠시 스쳐지나갔기 때문에   doPost/doGet 이라는 메서드도 정말 오랜만에 본 것이다.   하지만 너무나 즐거운 일인 것이, 사실 Spring이라는 프레임워크들을 사용하는 이유가 바로 이런 불편한 개발환경을 개선하고 효율적인 작업을 위해서 등장했을 것이다.   그러면 무엇이 불편하지를 알아야, 스프링의 참 가치를 느낄 수 있다.   servlet 또는 그것보다 low한 환경에서 개발하지 않고 스프링만 사용하는 사람이 어떻게 스프링이 좋다고 말할 수 있을까?   그러한 물음에 조금이라도 접근할 수 있을 것 같아 아주 즐거운 경험이었다.(물론 초기 프로젝트 환경 구축조차 제대로 하지 못한걸 뺀다면…^^;;)   기계적으로 사용하던 Maven을 통한 라이브러리 구축, web.xml과 dispatcher-servlet을 통한 웹 환경 구축 및 디비커넥션처리 등 작업들은 수동으로 처리하여   JDBC를 직접 컨트롤(커넥션부터 클로즈까지)하고, doGet/doPost로 받는 파라미터도 직접 처리하고, Response type 설정, json 파싱 등등 직접 처리한다.   그래서 어려웠다.   그래서 유익했다.   초안 작업은 되었지만, 단순한 작업인데 mybatis를 쓰지 않다보니 쿼리 관리도 불편했고,   특히 무엇보다 결과를 받아 처리하는 과정이 너무나 비효율적이었다.   또한 급급하게 작업이 될 수 있도록 구현에 집중하다보니 클래스 구조나 로직 자체가 뒤엉킨 느낌도 많이 든다.   처음 작업이니만큼 지속적으로 리팩토링하여 쓸만한 코드로 닦아야 겠다.   이것이 내가 가장 원하던 작업이다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_4/",
        "teaser":null},{
        "title": "Maven Dependency Plugin",
        "excerpt":"Maven과 빌드이야기   현재 작업하는 프로그램은 최종적으로 jar파일로 배포하여 실행해야한다.   항상 웹개발을 했기때문에 jar를 패키징하는 것도 처음이었고, 프레임워크의 도움없이 레거시시스템으로 개발하는것도 처음이었다.   그리고 사실 그동안 메이븐은 그저 라이브러리를 디펜던시해주는 역할로만 사용했을 뿐 그 이상의 많은 환경을 손대지 않았었다.   그러다보니 스터디하는 대부분의 내용들은 단순히 코딩을 잘할 수 있는 것에 집중되었고 외부의 환경이나 흐름에 대한 고찰은 하지 못했었다.   무식하면 용감하다고, 이런 모든것들이 결국 프로그래밍이라는 것. 그리고 궁극적으로 이 모든 과정들이 어떻게 빌드되어 구동되는지에 대해서 깊이 알아보지도 않았다.   그러던 중 이렇게 스프링을 제외시키고 순수 메이븐 빌드환경을 구성해서 작업하며 정말 새롭게 깨닫고 배운 부분들이 많아 하나씩 기록해두려한다.     일반적으로 웹 개발에서 메이븐 사용시 빌드환경에 필요한 모듈을 얹어주면 패키징할때마다 필요한 모듈을 가져와서 라이브러리에 jar파일을 준비해준다.   하지만 데몬에서는 어떨까? 웹에서 모듈을 준비하지 못한다면?   때문에 데몬에서 실행되는 jar파일을 생성시 필요한 메이블 설정이 있다.      이와 같은 설정인데,   결과적으로 maven-plugins에 해당 옵션을 삽입해준다.      이처럼 설정 후 패키징을 해주자      clean package    /target 디렉토리에 패키징된 jar파일이 생성된다.   위 설정이 정상적으로 적용되었다면, 기본 artifact-id.jar 파일과 더불어,   [artifact-id]-[descriptorRef].jar 이와 같은 형식으 파일이 떨어진다.   이 파일은 메이븐에 주입해놓은 모든 모듈을 포함한 jar 파일이기 때문에 데몬에서 실행시 해당 jar파일을 실행하면된다.   [참고]     http://javafactory.tistory.com/1490   https://www.lesstif.com/display/JAVA/Maven+Dependency+Plugin  ","categories": ["notes"],
        "tags": ["maven"],
        "url": "http://localhost:4000/notes/1810_5/",
        "teaser":null},{
        "title": "공동체",
        "excerpt":"E05.181019.알쓸신잡3   알쓸신잡이라는 프로그램은 여러모로 너무나 많은 영감과 그 이상의 깊은 울림을 주는 가장 사랑하는 프로그램이다.   알쓸신잡을 한 편 보고나면, 책을 한 권 읽은 듯이 새로운 세상을 간접적으로 접하기도 하고, 전혀 몰랐던 역사적, 과학적 또는 그 밖의 세상의 많은 잡다한 지식들을 얻을 수 있다.   건강에 좋은 식사를 한 끼 마친것과 같은 포만감을 준다.   이번 에피소드에서 최근 내가 고민하던 또는 내가 걱정하던 주제에 대한 이야기가 얼핏 나왔다.     건축과 관련된 이야기를 하던 중 유럽의 광장 문화에 대한 이야기가 나왔다.   유럽에는 광장 문화가 발달하여 대부분의 큰 도시마다 광장들이 존재한다.   개인들이 모여서 합을 이루는 공간이다.   하지만 우리나라에서 광장을 찾아보기란 그리 쉽지 않다.   우리나라는 광장이라는 공간의 모임 보다는 인간적인 공동체 문화가 너무 많이 형성되어 있다.   우리가 속해 있는 집단은 항상 어떤 모임을 형성하여 새로운 그룹문화를 만든다.   그 속에서 우리는 ‘나’에 대해 집중하기 어려워진다. 이런 조직(공동체) 문화는 개인이 무시되는 경향으로 번지기도 한다.   우리는 관계망(network) 속에서 존재한다. 그 관계망을 벗어나는 순간 우리는 사회적으로, 사회적인 시선에서 인정을 받지 못한다.      형성된 관계망을 벗어나는 순간 우리는 곱지 못한 눈총을 받기도하고, 남들과 같지 않다는 것을 느끼며 스스로 괴롭다는 생각이 들기까지 한다.   유럽 문화와 우리 문화의 차이 중 하나는,   유럽은 개인이 있고, 그 위에 관계망들이 존재한다.   그들은 자발적으로 관계망을 형성하고, 그런 관계망을 표현하는 것이 광장 또는 무대로 이어진다.   우리는 어떨까?   우리는 항상 어딘가에 속해있다.   초등학교 동창회, 중학교 동창회 … 군대 동기 모임, 대학 동기 모임, 동호회 등등….   이미 우리는 너무나 많은 공동체에 속해있다. 그리고 그 공동체 속에서 쉽게 피로갊을 느끼기도 한다. 하지만 아이러니하게도 내가 공동체에 속해 있지 않다고 느끼는 순간, 주변과 비교하며 큰 소외감을 느끼기도 한다.   한편으론 공동체라는 틀 안에서 안정감을 느끼기도 하지만, 때로는 그 울타리를 벗어나고 싶억하기도 한다.   이러한 사회적인 성격때문에 굳이 우리는 광장이라는 공간에 모이지 않는다. 오히려 도망치고 싶어한다.     사실 이 이야기는 내가 그간 고민하던 것에 대한 대답과도 같이 들렸다.   원래 그러했지만, 최근들어 더욱. 사람들을 만나는 것에 허망함(?)을 느끼던 떄가 있었다.   누군가를 만난다는 것에 의미를 부여하며 하나씩 따지는 것은 피곤한 일이겠지만, 가끔은 어떤 만남을 가진 후 허무하게 느껴지기도, 이 시간이 정말 내가 좋아서 함께한 시간인가 하는 쓸쓸함마저 몰려올때가 있다.   이런 생각이 들면서도 그런 공간에 있는 다는 것은, 어쩌면 나의 그릇된 행동들이 이 관계망을 해치진 않을까에 대한 두려움이 있을 것이다.   그래서 늘 눈치를 보고, 관계를 살피며 쉽게 피로감을 느끼곤 한다.   답이 없는 고민이지만, 공동체라는 관계망에 너무 큰 의미를 부여하는 것은 나 스스로를 잡아먹는 피로감만 증폭시킬 것이다.   그 다음 재미있는 이야기가 있었는데 내일 이어서 써야겠다.   ","categories": ["notes"],
        "tags": ["알쓸신잡"],
        "url": "http://localhost:4000/notes/1810_6/",
        "teaser":null},{
        "title": "협업",
        "excerpt":"첫 푸시   처음 푸시를 한 날이다. 간단한 api를 수정했다.   화면의 정렬을 바꾸고, 노출되지 않던 데이터를 노출시키는 것 등 사실 크게 무리도 없는 작업이고, 늘 하던 작업이다.   그런데 처음해보는 작업이다.   그동안 했던 일은 사실 프론트/백엔드 구분이 없다. 내가 다 해야했으니까.   대게의 작업 흐름은 이러하다.      사용자의 요청(Request)를 받는다.   서버에서 해당 요청을 받아 DB에 쿼리를 날린다.   쿼리 결과를 담아 다시 사용자에게 전달/응답(Response)한다.   결과가 사용자의 브라우저에 랜더링된다.   특히나 내게 어려웠던 것은 화면단인데,   아이콘 위치의 차이, hover, 색상 등등… 퍼블리셔가 기본은 잡아주지만 보통 작업하다보면 모든 작업이 그렇게 말끔히 분업화되긴 힘들다.   난 이 작업들이 너무 즐겁지 않았다. 미적인 감각도 없었을 뿐만 아니라, 사용자들 저마다 서로 다른 요구를 하기 때문에 그 합의점을 찾는 것은 보통 어려운 일이 아니다.   그것이 결국 내가 back-end 개발자가되리라 굳게 마음먹은 이유 중 하나였지만.   다시 본론으로 돌아와서 오늘 내가 한 작업은 단순히 기존 화면에 1. 검색 기능이 추가되고 결과 정렬을 바꾸는 간단한 작업이었다.   사실 api 작업은 금방 끝났다. 크게 고민할게 없을 정도의 간단한 일이다.   그런데 문제는 그게 아니다.   먼저 처음 애를 먹었던 것은 Git의 사용이다.   그전까지 svn으로만 작업을 했던 것. 그리고 무엇보다 브랜치와 같은 기본 기능은 쓰지 않는다. 그저 main trunk를 고정으로 하여 그 메인 브랜치에 update/commit 이 외에는 거의 다른 작업은 하지 않았기 때문에.   브랜치가 분리되어 있고, 깃은 commit/push 까지 이어져야 하는 모든 과정들이 쉽지 않았다.   혼자 이렇게 블로그에 글을 남기고, 개인 작업을 하는 것도 그저 혼자 개인 깃헙에 날려버리는 것이기 떄문에 소스가 꼬일일도, 브랜치를 따로 따서 사용할 일도 없었다.   작업은 완료되었는데 내 로컬환경에서만 작업이 완료된건 전혀 완료된게 아니였다.   또 하나의 문제.   이렇게 완벽하게 백엔드와 프런트앤드가 분리된 경우 서버에서 제공하는 API는 정확한 명세가 필요하다.   어떤 파라미터를 요청받을 것이며, 어떤 결과를 리턴할것인지 정확한 명세.   우리는 이 api 명세를 Atlassian의 confluence라는 위키와 같은 공간에 공유한다.   이런 작업 역시 처음이었다.   상당히 재미있었다. 명확하게 각자의 포지션에서 정해진(약속된) 결과만 전달해주면 되는 것이다.   익숙했다면, 1시간도 채 안돼서 마무리 될 작업을 거의 반나절을 했다.   그래도 즐겁다. 내가 무엇을 놓치고 있었는지 하나씩 보인다. 그런 과정들을 스스로 찾아가면서 매꾸어 나가는 과정이 꽤 보람차다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_7/",
        "teaser":null},{
        "title": "Google Cloud Summit in Seoul",
        "excerpt":"1st. Google Cloud Summit…   기다리던, 그리고 기대했던 구글 클라우드 서밋 행사가 있는 날이다.   팀에서 함께 하는 행사이기 때문에 약간 소풍(?)가는 듯한 느낌도 들었고, 어쨋든 회사에서 권장해서 참여한다는것도 고무적이었다.   Google Cloud Summit은 이번에 한국에서 처음 열리는 행사라고 한다.   올 4월에 AWS Summit을 참석했었는데, AWS에 비해선 조금 작은 규모로 진행됐지만 전체적인 세션 구성은 오히려 더 흥미로웠다.   AWS는 전체적인 세션 구성이 서비스를 소개하고 홍보하는 느낌이 강했다면, 이번 구글 서밋은 이 서비스를 어떻게 적용할 수 있는지에 대한 사례 위주의 세션들로 구성되어 있어서, 실제로 개발자들이 어떻게 활용할 수 있는지 좋은 가이드를 제시해준다는 느낌이었다.   사실 세션에 크게 집중하지 못하여 많으 내용을 기록하지 못했다.   하지만 가장 인상깊었던 2가지 세션이 있다.   가장 먼저 기조연설을 했던 구글의 임직원분들의 발표였는데 그 중 구글 IoT 부사장을 맡고 있는 ‘이인종’ 이라는 분의 연설이었다.   사진을 담아두지 못해 아쉽지만, 굉장히 우리가 생각하는 ‘구글’ 그 자체였다.    출처 :http://news1.kr/photos/view/?3360340   자유분방한 헤어스타일, 기존연설의 연사임에도 후드티를 입고 있는 캐주얼한 복장, 여유있는 모습과 유머러스한 말투들.   겉으로 보여지는 모습만 봐도 절대 평범하지 않다.   그리고 다루는 이야기들은 더욱 흥미로웠는데, 특히 LG전자와 함께 스마트시티를 계획하고 있다는 소식이다.   도심에 설치된 CCTV를 분석하여 교통량을 예상하고, 더 나은 길을 제시해주기도 하고,   동네의 슈퍼, 세탁소 등에 모두 IoT를 결합하여 실시간으로 내가 방문하고자 하는 매장의 정보를 얻을 수 있다는 것이다.   참 멋있다는 생각이 들었다.   아직은 스스로 개발자라고 하기에도 부끄러운 위치이지만, 같은 개발자들이 하는 일들이 세상을 바꾸는데 기여한다는 것이 멋지고 대단하단 생각이 들면서도, 한편으론 나는 무엇에 기여할 수 있을까. 어떻게 하면 저런 고민들을 실천으로 옮길 수 있을까에 대한 막연한 혼자만의 고민속에 빠져들며 나 혼자 진지해지곤 했다.   기조연설을 마친 후 잠시 뒤 점심식사를 했다.   안내받은 공간에 정갈한 도시락들이 놓여있었고, 식사를 하던 중 스트리밍되는 화면에서 아주 흥미로운 화면을 볼 수 있었다.   [주제가 있는 런치] 라는 주제로 진행된 이 행사는,      3D프린터로 만드는 전자 의수   시각장애인을 위한 모바일 어플리케이션   음성을 통한 파킨슨 병 진단 디바이스   잘다니던 일류기업을 나와 3D프린터로 ‘의수’를 만들어 전세계 시장에 뛰어다니며 발품을 파는 멋진 개발자분의 발표로 시작했다.   말씀도 잘하셨고, 아주 멋지고 의미있고 그리고 상당히 가치있는 일을 하는 것에 큰 감명을 받았다.   그리고 다음 주제는 ‘시각장애인을 위한 모바일 어플리케이션’ 이라는 주제로 발표가 이어졌다.      그리고 아주 놀랍게도 고등학교 2학년의 학생이 무대에 올라섰다.   고등학교 2학년이 이 수백명 이상의 개발자들이 모인 공간에서 발표를 한다. 자신이 만든 서비스를.   그리고 그 주제와 실천은 더욱 참신했다.   ‘요즘은 자동차도 사람의 손을 쓰지 않고 움직이는데, 어떻게 사람은 하다못해 안내견의 도움이라도 없으면 가까운 동네조차 다니지 못한다는 것’ 에 착안하여 개발을 시작했다고 한다.   그리고 실제로 이런 어플리케이션을 만들기 위해선 동네의 위치 정보를 제공해주는 api가 있어야 만들 수 있는데, 참고할 만한 데이터가 존재하지 않아 직접 자전거에 카메라를 설치하여 동네 구석구석 직접 촬영하고 누비며 본인이 직접 서비스에 이용할 데이터를 수집했다.   그리고 이 과정에서 검정색은 ‘차도’, 흰색,빨간색,초록색 등의 색상이 있으면 ‘인도’ 라는 패턴을 머신러닝으로 학습시켜 어플리케이션이 스스로 모든 데이터를 분석하여 서비스를 제공하도록 구현해냈다고 한다.   그 과정에서 쓰레기더미, 장애물 등의 변수가 있을때 겪었던 문제들을 어떻게 처리했는지를, 조금은 긴장한채로 조심스럽게 풀어나갔지만 부모님뻘되는 사람들이 수백명 모인 공간에서 자신의 이야기를 풀어나간다는 것 자체만으로도 대단했고 그 모습들이 하나같이 너무나 인상적이었다.   고등학교 2학년의 나이에 그런 생각을 했다는 것도 너무 대단했고, 단순히 생각이나 상상으로 그치는 것이 아니라 실천으로 옮겼고, 실제로 그것을 완성시켰다.   적어도 나에겐 그것이 완벽하게 작동하는 어플리케이션인지는 중요하지 않았다.   지금 나에게 그런 어플리케이션을 만들어보라고 아이디어를 제공해줘도 만들어내기 힘들 것이다.   그 학생이 단순히 그런 어플리케이션을 만들었다는 것이 놀라운 것이 아니라,   그런 생각을 하는 과정과 실천력이 가장 존경스럽기까지 했다.   그 학생의 발표가 끝난 후 약간은 벙찐채로 로비로 나왔다.   여러가지 낯선 감정들이 교차했다. 아주 긍정적이고 가슴 깊은 곳에서 벅차오르는 기분이었다.   그런데 여기서 끝이 아니다.   로비로 나와 1층으로 이동 후 다음 세션을 위해 미리 들어가 있으려 했는데, 그 무대위에 교복을 입은 여자 학생이 발표를 하고 있었다.   말을 너무나 잘했다. 기술적인 용어들도 그렇고 자신이 겪은 문제, 그것 해결 하는 과정 등등 모든 표현이 너무나 정갈하고 정리되어있었다.   처음엔 어떤 기업에서 홍보차 나온 엔지니어라고 생각했지만, 그 학생은 고등학교 3학년의 여학생이었다.   초입에 어떤 계기로 어떻게 시작했는지를 놓쳤지만, 내가 들은 부분은 파킨슨병이 음성의 떨림 정도로 판별이 가능하여 이를 발견할 경우 초기에 조치가 가능한데, 우리나라에 이런 기술이 보급되지 않아 직접 구현해낸 것이다.   그리고 그 과정을 역시 머신러닝 ai를 통해 그 판별해 낼 수 있도록 구현하는 과정을 아무 멋지게 설명해나갔다.   그리고 이 학생은 자신이 소프트웨어만을 개발해왔기 떄문에, 이 소프트웨어를 사용하기 위해서 목소리를 담을 수 있는 디바이스가필요했다고한다.   정확한 모임은 기억나지 않지만, 개발자들이 모이는 캠프에 참여하여 자신의 소프트웨어를 소개한 후 팀을 꾸려서 디바이스와 소프트웨어를 결합시켜 이 도구를 만들어 낸 이야기였다.   그 팀에는 10여명의 팀원이 함께했고, 그 팀원들은 현업에 종사하는 개발자이거나 대학원생 등으로 구성된 전문 인력들이었다.      앞에 남학생과 또 다른 아주 대단한 학생이었다.   혼자의 힘이 아닌, 자신이 무엇이 부족한지를 알고 자신에게 도움을 줄 수 있는 사람을 정확히 찾아냈고, 그들과 아주 좋은 콜라보를 이루어 근사한 어플리케이션을 완성했다.   연속으로 이 두 학생의 이야기를 듣고 나니 정말 망치로 얻어마진 기분이었다.   좌책감이나 좌절감이 아니라, 내가 꿈이 없이 맹목적으로 개발만 잘하고 싶다는 생각으로 살고 있었다는 것을 깨닫게되었다.   사실 ‘개발을 정말 잘하고 싶고, 개발을 잘해서 인정받고 필요한 사람이 되기 싶다’ 정도만 생각했지 궁극적으로 어떤 개발자가 되겠다는 생각은 하지 못했던 것 같다.   오늘 컨퍼런스의 취지는 GCP의 특징이나 서비스의 고도화 등등을 소개하는 자리였을테지만, 내가 느낀 것은 세상에 기여하는 개발자들의 모습을 통해 나는 과연 무엇을 할 수 있을까를 돌아보는 시간이었다.   거창하고 대단해보이는 개발자가 아니라, 어떤 방식으로든 사회에 기여하고, 내가 하는 일에 더욱 가치를 부여할 수 있는 사람이 되고 싶다. 그런 철학이 있고, 생각을 하는 사람이 되어야 한다.   ","categories": ["notes"],
        "tags": ["Google Cloud Summit"],
        "url": "http://localhost:4000/notes/1810_8/",
        "teaser":null},{
        "title": "category : db",
        "excerpt":"https://mmistakes.github.io/minimal-mistakes/collection-archive/   내용을 입력합니다  ","categories": ["DB"],
        "tags": ["content"],
        "url": "http://localhost:4000/db/2/",
        "teaser":null},{
        "title": "우선 순위",
        "excerpt":"벌써 한달이 지났다.   꽤 많은 일들이 있었다.   내가 작업한 모듈이 서비스에서 활용되기도 한다.   그리고 최근엔 embulk를 통해 bigquery -&gt; vertica 의 etl 작업을 진행하고 있다.   정확히는 저번주 목요일부터 진행을했다.   noSQL이라는 데이터도 처음 다루어 보았다.   여전히 많은 것들이 새롭고 낯설기만하다.   그런데 이제 그 낯섬에 대해선 극복이 필요할 것 같다.   이슈가 터졌기 때문이다   그것도 양방향에서…   ‘이충일’이라는 스레드는 동시 작업이 들어와서 병목을 겪었다.   이전에 push 모듈을 만들었던 A 라는 프로세스와   현재 진행 중인 빅데이터 etl 하는 B 라는 프로세스의 충돌이다.   나라는 스레드를 관리하는 사람은 나의 사수이다. 나의 사수분께서 내 스레드의 스케줄을 관리한다. 우선순위를 선정하고, 둘 중 무엇을 해야할지 몰라서 작업이 멈춰있는 나는 사수님이 설정한 스케줄대로 잡을 진행한다.   A라는 모듈의 이슈를 먼저할 것으로 스케줄링되었다.     A모듈의 문제는 원 서버에서 보내는 데이터가 제대로 업데이트가 되지 않는 이슈였다.   이 이슈를 겪으며 가장 치명적이고 기본적인 문제를 파악했는데, 다름아닌 작업을 할때 이 일이 어떻게 돌아가는 지 모르고 시작했다는 것이다.   개발자가 개발을 하는데 내가 무엇을 만드는지 모르고 시작한 것이다.   그저 ‘돌아가기만 하는’ 모듈을 만들어 놓은 것이다. 특별히 에러는 발생하지 않았고 로그도 잘 찍혔으며, 입력한 데이터가 제대로 들어온다.   사실 쉽게 생각하면 그것이 전부다.   하지만 디비 각 필드마다 어떤 역할을 하고, 어떤 값을 키 값으로 할것인지. 또 이 디비를 사용하는 클라이언트 개발자는 어떤 필드를 필요로 하는지 등등   참 생각없이 개발했다. 그저 자바코드를 어떻게 짤까. 객체지향적으로 하려면 어떨까. 중복은 어떻게 제거할까.   틀리진 않지만. 우선순위가 잘못됐다.      내가 무엇을 만들어야 하는지   이 서비스를 사용하는 사람은 무엇을 필요로 하는지   그것을 어떻게 만들 것인지   로그는 어떻게 찍을 것인지   등등   당연한 이야기지만, 모든 일에는 순서가 중요한 것 같다.   그 순서를 고민하고, 어떤 방향으로 어떻게 진행할지를 설계하는 모든 과정이 아키텍트겠지.   급하게 결과만을 좇아서 만들어 놓은 결과를 놓고 돌아보면, 결국 처음으로 다시 돌아간다.   처음 시작할때 쫓기는 마음으로 일단 코딩부터 해야겠다고 IDE를 켜는 순간 제대로 세우지 못한 계획 때문에 다시 처음부터 고민해봐야할때가 많다.   아마 그런 훈련이 몸에 익은 사람들을 시니어라고 하지 않을까 싶다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_1/",
        "teaser":null},{
        "title": "paintComponent",
        "excerpt":"Java Swing component를 이용해서 간단한 음악게임을 만들고있다.   화면을 그리는 중인데   paint 와 paintComponent 간의 순서 또는 버퍼문제로 이미지가 제대로 뜨지 않는다.   백그라운드 이미지 위에 JLabel 또는 JButton이 위치해야하는데,   참고하고 있는 곳에서는 paint()를 이용해서 백그라운드 이미지를 그리고,   paintComponent() 를 이용해서 이미지 위에 버튼이나 레이블같은것을 뿌려준다고 하는데,   이 과정이 이중버퍼를 통해서 이루어지는 것으로 이해했는데   안된다.   아… 답답해        public void paint(Graphics g){         screenImage = createImage(Main.SCREEN_WIDTH, Main.SCREEN_HEIGHT);         screenGraphic = screenImage.getGraphics();         screenDraw(screenGraphic);         g.drawImage(screenImage, 0, 0, null);     }      public void screenDraw(Graphics g) {         paintComponents(g);         g.drawImage(introBackground, 0, 0, null); //        this.revalidate(); //        this.repaint();     }   paintComponents()를 올리면, introBackground가 나오고   내리면 버튼이나 레이블이 나오고 어쩌라는거…  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_2/",
        "teaser":null},{
        "title": "ideation",
        "excerpt":"누군가의 한마디가 큰 울림, 새로운 시발점을 불러오는 경험은 누구나 다 있다.   조금 전 대화의 희열 - 아이유 편을 보는데,   아이유가 일반적인 음원 시장의 규칙을 깬 이야기를 했다.   음원 시장은 암묵적으로 오후 12시부터 6시까지 발표하는 것을 관행으로 한다고 한다. 이유인즉슨,  그 시간에 스트리밍 집계를 하여 음원 순위에 반영되기 때문에 그 이전/이후에 스트리밍 하는 것은 꽤 큰 손실(Time-loss)가 있을 수 밖에 없다.   하지만 아이유는 ‘가을 아침’ 이라는 곡을 발매할때, 이건 누가봐도 아침 노랜데 오후에 낼 수 없다는 신념으로 모두가 반대하는, 그리고 경제적인 손실을 감수하고 아침에 발표했다고 한다.   그리고 아이유는 이러한 형식적인 관행은 누군가 깨지 않으면 계속해서 같은 패러다임안에서 굴러가기 때문에 새로운 창의적인 것이 실현되지 않을 것이라 한다.   평소 그 생각의 깊이가 얼마나 큰 지 모르겠지만, 아티스트라고 칭하는 사람들은 꽤 다른 영역에. 그리고 아이돌이라는 껍데기에 씌여져 조금은 ‘평가절하’되고 있는(어쩌면 나만 그러고 있을지 모르겠지만) 아티스트들이 많은 것 같다.   ‘어린 친구들이 뭘 알아’ 라는 꼰대식 마인드는 사실 나에게도 있다.   삶의 지혜, 세상을 보는 식견은 어느정도 세월에 비례한다고 생각했지만.   10대 어린 나이부터 활동해온 한 가수가 정신없이 시달리는 스케줄 속에서도 세상을 바라보는 통찰과 자기 내면의 훈련을 해내가는 과정이 대단하다고 생각한다.   말이 샜는데,   난 스터디를 좋아한다. 특히 여러 사람이 모여 이야기 나누는 것을 좋아한다.   특히 사람들이 모였을떄 재미난 경험은.   내가 불현듯 내뱉은 한마디에 옆에서 한마디씩 살을 붙여주어 풍성한 가지가 달린 나무가 되기도 한다.   예를들어, 스터디 이름을 정하는데 있어서 고민을 하던 중   누군가 ‘우리는 토요일마다 모이니까…’ 라는 한마디에   ‘토모’라는 스터디명이 탄생했다.   1차원적이고 직관적인 이름이라고 무시할 수 있지만, 우리는 이 이름이 너무 만족스러웠고 가장 우리다운 이름이었다.   또, 스터디 주제에 대한 아이디어를 고민할때도 아무 얘기나 내뱉은 한마디에 불씨가 지펴져 꽤 뜨거운 토론으로 이어지기도 한다.   그 불씨를 누가 집히느냐 이다.   [어떻게, 무엇을]과 같은 형식은 중요하지 않다.   불씨만 집혀주면된다. 판 만 준비해주면 된다는 것이다.   그것이 어떤 형태이든 그 새로운 불씨는 누군가의 심지에 불이 붙을 수 있다.   세상을 조금 더 주의깊게 바라보고 누군가의 소리에 귀기울이고 산다면.   그리고 내 마음 속에 언제든지 불이 붙을 수 있는 심지를 준비해 놓는다면.   언제든지 큰 폭발력을 낼 수 있지 않을까.      2018.11.10 새벽 6시에 뻘글…   ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_3/",
        "teaser":null},{
        "title": "category : JAVA",
        "excerpt":"JAVA  ","categories": ["JAVA"],
        "tags": ["content"],
        "url": "http://localhost:4000/java/1/",
        "teaser":null}]
