var store = [{
        "title": "마크다운 기본 사용법",
        "excerpt":"Summary:  마크다운을 위한 기본 문법 익히기   Comum Elements     강조   헤딩   리스트   문단 구분   링크   수평줄   이미지   코드 삽입     강조  가장 먼저 강조는 다음과 같이 사용할 수 있다.   가장 먼저 **강조**는 다음과 같이 사용할 수 있다.    헤딩  헤딩은 다음과 같은 단계로 표현할 수 있다.   자라나라 헤딩   자라나라 헤딩   자라나라 헤딩   자라나라 헤딩   자라나라 헤딩   ##### 자라나라 헤딩 #### 자라나라 헤딩 ### 자라나라 헤딩 ## 자라나라 헤딩 # 자라나라 헤딩    리스트   정렬 리스트     순서정렬_첫번째   순서정렬_두번째 아이템   순서정렬_3번   1. 순서정렬_첫번째 2. 순서정렬_두번째 아이템 3. 순서정렬_3번  비정렬 리스트     비정렬_첫번째   비정렬_두번째 아이템   비정렬_3번   1. 비정렬_첫번째 2. 비정렬_두번째 아이템 3. 비정렬_3번    문단 구분   인용구      인용구 입력 부분. 마크다운 기본 문법 알아보기    &gt; 인용구 입력 부분. 마크다운 기본 문법 알아보기    링크연결  링크 연결은 다음과 같이 3가지 방법으로 표현할 수 있다.     내 블로그 링크 넣기 betterFly’s ghpages.   내 블로그 링크 넣는 다른 방법 betterFly’s ghpages   링크 바로 넣기 http://betterfly88.github.io/   * 내 블로그 링크 넣기 [betterFly's ghpages][2]. * 내 블로그 링크 넣는 다른 방법 [betterFly's ghpages](http://betterfly88.github.io/) * 링크 바로 넣기 &lt;http://betterfly88.github.io/&gt;    수평줄  현재 계속 사용하던 수평줄 구분 선은 다음과 같이 표현할 수 있다.   ---    이미지     기본 이미지 삽입   ![Markdowm Image][/image/url]     이미지 붙임말   ![Markdowm Image][/image/url] &lt;figcaption class=\"caption\"&gt;sample image&lt;/figcaption&gt;    sample image  이미지 늘리기   ![Markdowm Image][/image/url]{: class=\"bigger-image\" }       코드 삽입   A HTML Example:   &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt;     &lt;meta charset=\"UTF-8\"&gt;     &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt;     &lt;h1&gt;Just a test&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt;  A CSS Example:   pre {     padding: 10px;     font-size: .8em;     white-space: pre; }  pre, table {     width: 100%; }  code, pre, tt {     font-family: Monaco, Consolas, Inconsolata, monospace, sans-serif;     background: rgba(0,0,0,.05); }  A JS Example:   // Sticky Header $(window).scroll(function() {      if ($(window).scrollTop() &gt; 900 &amp;&amp; !$(\"body\").hasClass('show-menu')) {         $('#hamburguer__open').fadeOut('fast');     } else if (!$(\"body\").hasClass('show-menu')) {         $('#hamburguer__open').fadeIn('fast');     }  });    ##프로그래밍 언어      한 줄, 단어 정도의 짧은 표현 :        String sample;   &lt;pre&gt;     String sample; &lt;/pre&gt;       코드 블럭 : ``` 또는 ~~~  + 언어 선택       function sum(a,b){         return a+b;     }       public int sum(int a, int, b){         return a+b;     }   ```javascript     function sum(a,b){         return a+b;     } ```  ~~~java     public int sum(int a, int, b){         return a+b;     } ~~~  ","categories": ["ETC"],
        "tags": ["markdown"],
        "url": "http://localhost:4000/etc/%EB%A7%88%ED%81%AC%EB%8B%A4%EC%9A%B4-%EC%82%AC%EC%9A%A9%EB%B2%95(%EA%B8%B0%EB%B3%B8)/",
        "teaser":null},{
        "title": "당신은 행복한 개발자입니까?",
        "excerpt":"   아직 당신의 코드에 만족감을 얻지 못했다면, 이 내용이 도움이 될 것입니다!        Are you a happy developer? 의 내용을 번역한 내용입니다. 번역 과정에서 미흡한 문맥/오역이 있을 수 있는점 양해바랍니다.      저는 훌륭하거나 유명한 개발자가 아닙니다. 하지만 하루하루를 배우고 나의 일을 정말로 사랑하고 즐기는 개발자입니다.   당신의 직업에서 만족감을 얻기 위한 특별한 방법(magic recipe)은 무엇일까요?  그런 마법 공식은 존재하지 않습니다. 개발 세계에서, 특히 프론트엔드 개발자들이라면 프로젝트를 조금 더 쉽고 즐겁게 수행하기 위해선 일련의 과정을 따라야 합니다.     이 팁은 이미 개발자이거나, 프론테엔드라고 불리는 신비롭고 성장의 붐이 일고 있는 세계에 진입하고자 하는 사람들이 도달할 수 있지만, 개발자이든지 아니든지 어떤 영역에서도 확실히 적용할 수 있습니다.     1.매일 새로운 것을 배워라  새로운 언어, 새로운 화법, 새로운 기술, 새로운 프레임워크 또는 당신이 알고 있는 것을 새롭게 하는 방법 등 당신의 뇌를 훈련하십시오.   그것은 당신의 건강뿐만 아니라 경력에도 도움이 됩니다. 신체의 근육과 같이, 당신의 뇌는 운동 루틴을 필요로 합니다. 당신의 지식을 최대화하고 새로운 발견을 뛰어 넘어, 구체적이고 지향적인 검색을 통해 Aline Bastos의 깃헙과 같은 많은 코드를 직면할 수 있습니다.   2. 진행과정을 기록하라  우리는 떄때로 오래된 프로젝트를 보며 생각합니다. “이걸 어떻게 했지?” - 다른 한 눈으로 돌아보고 과거 시점에서 지금까지 당신이 얼마나 많이 진화했는지 분석해보십시오!   이 작은 과정에서 각각의 새로운 성취를 성과를 축하하고, 당신의 현재 위치와 앞으로 무엇을 원하게 되는지 명확한 시각을 갖게 됩니다.   스프레드시트, 리스트 깃-플로우와 같은 것에서 당신의 상상력을 자극하고 기술을 제공하는 도구는 무엇이든 사용하십시오.   3. 커뮤니티를 지켜보아라  포럼, FAQs, 스터디그룹(페이스북, 텔레그램), 깃헙, 스택오버플로우 등 그 곳엔 항상 누군가의 도움을 필요로 하거나 도움을 원합니다. 그들에게 당신이 알고 있는 부분을 전달하십시오. 그런 활동들은 당신의 새로운 성향, 도구, 방법론에 관심을 갖도록 도움을 줍니다. 이 과정에서 우리는 “배움의 가르침” 을 인용할 수 있습니다. 배우기 위한 최고의 방법은 그것에 대해 누군가에게 가르치는 것이기 때문입니다.   4. 사용자의 신발에 당신을 맡겨라  당신의 상품 또는 서비스를 사용하는 사용자가 있어 당신이 할 일이 있다는 것은 좋은 신호입니다 - 상품 또는 서비스가 좋을 수록 당연히 더 많이 쓰이게 될 것입니다. 그래서 항상 사용하기 쉽고 접근하기 쉬운 좋은 인터페이스를 통해 사용자에게 좋은 경험을 제공해야 합니다. 만약 사용자가 그 제품을 좋아한다면, 당연히 다시 찾을 것이고 당신의 브랜드를 추천하기도 합니다.   인바운드 마케팅 전략을 사용하여 방문자를 고객으로 전환하면, 그는 당신 상품 또는 서비스를 홍보하게 될 것입니다. 이것을 달상히기 위해서 항상 양질의 품질과 더 나은 가치를 제공해야 할 것입니다.      당신은 당신이 개발한 상품 또는 서비스를 사용하십니까?    5. 사람 다루는 방법을 알아라  세상 속에서 당신은 코드만이 아닌, 많은 사람들을 상대할 것입니다 - 그들은 변덕스럽고 예측이 어렵습니다. 이 분야에서 좋은 대인관계를 갖는 것은 기본입니다 - 당신의 팀원, 고객, 가족, 동료.. 이 모두가 저마다의 다양한 방식으로 당신에게 제공합니다. 당신은 그것을 흡수하는 것이 핵심입니다.   언어, 글, 그리고 바디랭귀지는 이 시점에서 깊은 연관이 있습니다.   많은 개발자들은 저마다 좋은 아이디어를 갖고 있습니다. 그러나 대부분 그들의 동료와 원활한 소통이 되지 않습니다. 이것을 해결하기 위해서, 당신의 의견이나 생각을 표현할 때 훌륭한 어휘력과 간결하고 직관적인 표현이 필요합니다. 좋은 언사가 되는것뿐만 아니라, 좋은 청취자가 되어야 합니다.      말할때는 당신이 이미 알고 있는 것만 반복해서 말하지만, 상대의 말에 귀를 기울인다면 새로운 것을 배울 수 있다   - 달라이 라마    6. 당신의 자아를 다루어라  잘 완료된 작업에 대하여 칭찬을 받는 것은 매우 기쁘고 긍정적인 일입니다. 그러나 칭찬을 받는 것이 목적이 되면 안됩니다. 목적은 오직 당신의 작업 결과가 되어야 합니다.   기술 분야에서 뛰어난 인재만을 좋아하는 사람은 없습니다. 겸손함이 당신을 좀 더 먼 곳으로 데려다 줄 것입니다. 당신의 성공으로 가는 길에 당신의 자아를 흔들리게 내버려두지 마십시오! 그것은 좋은 대인관계를 형성하는데 매우 깊은 관련이 있습니다.     사람은 오고 가지만, 지식은 남아 있는다.    7. 유연하고 부드럽게  매일 새로운 자바스크립트 프레임워크가 탄생합니다 - 농담이 아닙니다. 세계는 강한 것이 아닌 빠르게 적응 하는 사람들에게 유리합니다! 모든 것을 알려고 하지 마십시오. 하지만 각각의 도구가 당신에게 제공하는 기능과 그렇지 못한 것을 알아야, 새로운 프로젝트를 시작할 때 최선의 선택만을 고려할 수 있습니다.     당신의 동료/팀원들의 이야기를 듣고, 필요하다면 브레인스토밍과 다이어그램도 만들어 보십시오. 도움을 구하는 것에 부끄러워하면 안됩니다. 항상 당신을 둘러싼 좋은 인상과 가능성을 두십시오 - 이 방법은 당신이 올바른 길로 갈 수 있는 방법입니다.     ","categories": ["ETC"],
        "tags": [],
        "url": "http://localhost:4000/etc/%EB%8B%B9%EC%8B%A0%EC%9D%80-%ED%96%89%EB%B3%B5%ED%95%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%9E%85%EB%8B%88%EA%B9%8C/",
        "teaser":null},{
        "title": "AssertJ in joda-time",
        "excerpt":"   AssertJ assertions for Joda-Time   왜 joda-time을 사용해야 하는가     java.util.Date의 한계                     불변 객체가 아니다( not immutable)    불행히도 Java의 기본 날짜, 시간 클래스는 불변 객체가 아니다. 앞의 코드에서 Calendar 클래스에 set 메서드를 호출해서 날짜를 지정하고, 다시 같은 객체에 set(int,int) 메서드를 호출해서 수행한 날짜 연산 결과는 같은 인스턴스에 저장되었다. Date 클래스에도 값을 바꿀 수 있는 set 메서드가 존재한다. 이 때문에 Calendar 객체나 Date 객체가 여러 객체에서 공유되면 한 곳에서 바꾼 값이 다른 곳에 영향을 미치는 부작용이 생길 수 있다. 『Effective Java 2nd Edition』(2008)의 저자 Joshua Bloch도 Date 클래스는 불변 객체여야 했다고 지적했다.  이를 안전하게 구현하려면 이들 객체를 복사해서 반환하는 기법을 권장한다.               int 상수 필드의 남용                calendar.add(Calendar.SECOND, 2);            첫 번째 파라미터에 Calendar.JUNE과 같이, 전혀 엉뚱한 상수가 들어가도 이를 컴파일 시점에서 확인할 방법이 없다. 이 뿐만 아니라 Calendar 클래스에는 많은 int 상수가 쓰였는데, 이어서 설명할 월, 요일 지정 등에서도 많은 혼란을 유발한다.               헷갈리는 월 지정               calendar.set(1582, Calendar.OCTOBER , 4);            그런데 월에 해당하는 Calendar.OCTOBER 값은 실제로는 ‘9’이다. JDK 1.0에서 Date 클래스는 1월을 0으로 표현했고, JDK 1.1부터 포함된 Calendar 클래스도 이러한 관례를 답습했다. 그래서 1582년 10월 4일을 표현하는 코드를 다음과 같이 쓰는 실수를 많은 개발자들이 반복하고 있다.              @Test        public void shouldGetDate() {            Calendar calendar = Calendar.getInstance();            calendar.set(1999, 12, 31);            assertThat(calendar.get(Calendar.YEAR)).isEqualTo(2000);            assertThat(calendar.get(Calendar.MONTH)).isEqualTo(Calendar.JANUARY);            assertThat(calendar.get(Calendar.DAY_OF_MONTH)).isEqualTo(31);                              }                   1999년 12월 31일을 지정하려 했으나, 12월의 상수값은 11이므로 직접 숫자 12를 대입하면 2000년 1월 31일로 넘어간다. 숫자 12 대신 11 혹은 Calendar.DECEMBER 상수로 지정해야 1999년 12월 31일이 된다.           13월을 의미하는 12를 넣어도 Calendar.set() 메서드가 오류를 반환하지 않기 때문에 이런 실수를 인지하기 더욱 어렵다. calendar.setLenient(false)  메서드를 호출하면 잘못된 월이 지정된 객체에서 IllegalArgumentException을 던져 준다. 그렇게 지정해도 Calendar.set() 메서드가 호출되는 시점이 아니라,  Calendar.get() 메서드가 호출될 때 Exception이 발생한다는 점도 주의해야한다.                        일관성 없는 요일 상수   Calendar.get(Calendar.DAY_OF_WEEK) 함수에서 반환한 요일은 int 값으로, 일요일이 1로 표현된다. 따라서 수요일은 4이고, 보통 Calendar.WEDNESDAY 상수와 비교해서 확인한다. 그런데 calendar.getTime() 메서드로 Date 객체를 얻어와서 Date.getDay() 메서드로 요일을 구하면 일요일은 0, 수요일은 3이 된다. 두 개의 클래스 사이에 요일 지정값에 일관성이 없는 것이다.  Date.getDay() 메서드는 요일을 구하는 메서드로는 이름이 모호하기도 하다. 현재는 사용하지 않는(deprecated) 메서드라서 그나마 다행이다.              @Test        @SuppressWarnings(\"deprecation\")        public void shouldGetDayOfWeek() {            Calendar calendar = Calendar.getInstance();            calendar.set(2014, Calendar.JANUARY, 1);                       int dayOfWeek = calendar.get(Calendar.DAY_OF_WEEK);            assertThat(dayOfWeek).isEqualTo(Calendar.WEDNESDAY);            assertThat(dayOfWeek).isEqualTo(4);            Date theDate = calendar.getTime();            assertThat(theDate.getDay()).isEqualTo(3);                          }                   Calendar.get(Calendar.DAY_OF_WEEK) 함수에서 반환한 요일은 int 값으로, 일요일이 1로 표현된다. 따라서 수요일은 4이고, 보통 Calendar.WEDNESDAY 상수와 비교해서 확인한다. 그런데 calendar.getTime() 메서드로 Date 객체를 얻어와서 Date.getDay() 메서드로 요일을 구하면 일요일은 0, 수요일은 3이 된다. 두 개의 클래스 사이에 요일 지정값에 일관성이 없는 것이다.  Date.getDay() 메서드는 요일을 구하는 메서드로는 이름이 모호하기도 하다. 현재는 사용하지 않는(deprecated) 메서드라서 그나마 다행이다.                   Joda-Time 사용   maven dependency   &lt;dependency&gt;     &lt;groupId&gt;joda-time&lt;/groupId&gt;     &lt;artifactId&gt;joda-time&lt;/artifactId&gt;     &lt;version&gt;2.9.9&lt;/version&gt; &lt;/dependency&gt;  &lt;!-- assertj-test--&gt; &lt;dependency&gt;     &lt;groupId&gt;org.assertj&lt;/groupId&gt;     &lt;artifactId&gt;assertj-core&lt;/artifactId&gt;     &lt;version&gt;3.9.1&lt;/version&gt;     &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;   gradle  compile group: 'joda-time', name: 'joda-time', version: '2.9.9'  testCompile group: 'org.assertj', name: 'assertj-core', version: '3.9.1'      java.utils.Calendar vs jodatime            java.utils.Calendar               @Test     public void 자바_캘린더_기본(){         Calendar calendar = Calendar.getInstance();         calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);          SimpleDateFormat sdf =                 new SimpleDateFormat(\"yyyy-MM-dd E HH:mm:ss.SSS\");         calendar.add(Calendar.DAY_OF_MONTH, 90);         System.out.println(sdf.format(calendar.getTime()));     }      jodatime       @Test     public void 조다타임_기본(){         DateTime dateTime = new DateTime(2018, 4, 13, 0, 0, 0, 0);         System.out.println(dateTime.plusDays(90).toString(\"yyyy-MM-dd E HH:mm:ss.SSS\"));     }   AssertJ in joda-time      데이터타입을 커스터마이징 하여 원하는 조건으로 비교       @Test     public void 패턴비교(){         DateTime nowTime = DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\").parseDateTime(\"2018-04-13 00:23:54\");         String result = DateTimeFormat.forPattern(\"aa\").withLocale(new Locale(\"ko\")).print(nowTime);         assertThat(result).isEqualTo(\"오전\");          String result2 = DateTimeFormat.forPattern(\"MM월dd일 HH:mm\").withLocale(new Locale(\"ko\")).print(nowTime);         assertThat(result2).isEqualTo(\"04월13일 00:23\");     }      UTC타임과 해당 지역을 비교       @Test     public void 타임존(){         DateTime utcTime = new DateTime(2013, 6, 9, 17, 0, DateTimeZone.UTC);         DateTime cestTime = new DateTime(2013, 6, 10, 2, 0, DateTimeZone.forID(\"Asia/Seoul\"));          assertThat(utcTime).as(\"in UTC time\").isEqualTo(cestTime);     }      기준시간 이전 혹은 이후 검증            @Test     public void 시간검증_기본(){         assertThat(new DateTime(\"1999-12-30\")).isBefore(new DateTime(\"2000-01-01\"));         assertThat(new DateTime(\"2000-01-01\")).isAfter(new DateTime(\"1999-12-30\"));          assertThat(new DateTime(\"2000-01-01\")).isBeforeOrEqualTo(new DateTime(\"2000-01-01\"));         assertThat(new DateTime(\"2000-01-01\")).isAfterOrEqualTo(new DateTime(\"2000-01-01\"));     }      상세 시간을 무시하여 검증       @Test     public void 시간무시(){         // ... milliseconds         DateTime dateTime1 = new DateTime(2000, 1, 1, 0, 0, 1, 0, UTC);         DateTime dateTime2 = new DateTime(2000, 1, 1, 0, 0, 1, 456, UTC);         assertThat(dateTime1).isEqualToIgnoringMillis(dateTime2);         // ... seconds         dateTime1 = new DateTime(2000, 1, 1, 23, 50, 0, 0, UTC);         dateTime2 = new DateTime(2000, 1, 1, 23, 50, 10, 456, UTC);         assertThat(dateTime1).isEqualToIgnoringSeconds(dateTime2);         // ... minutes         dateTime1 = new DateTime(2000, 1, 1, 23, 50, 0, 0, UTC);         dateTime2 = new DateTime(2000, 1, 1, 23, 00, 2, 7, UTC);         assertThat(dateTime1).isEqualToIgnoringMinutes(dateTime2);         // ... hours         dateTime1 = new DateTime(2000, 1, 1, 23, 59, 59, 999, UTC);         dateTime2 = new DateTime(2000, 1, 1, 00, 00, 00, 000, UTC);         assertThat(dateTime1).isEqualToIgnoringHours(dateTime2);     }      기준 시간내에 포함여부 검증      기준시간.isIn(A, B) -&gt; 기준시간이 A~B시간 사이에 해당하는지 검증       @Test     public void not_in(){         assertThat(new DateTime(\"2000-01-01\")).isIn(new DateTime(\"1999-12-22\"), new DateTime(\"2000-01-01\")); //A~B까지의 시간안에 포함         assertThat(new DateTime(\"2000-01-01\")).isNotIn(new DateTime(\"1999-12-31\"), new DateTime(\"2000-01-02\")); //B가 기준 날짜보다 크므로 not in 임                  assertThat(new LocalDateTime(\"2000-01-01\")).isIn(\"1999-12-31\", \"2000-01-01\").isNotIn(\"1999-12-31\", \"2000-01-02\");     }   참고     http://d2.naver.com/helloworld/645609   http://joel-costigliola.github.io/assertj/assertj-joda-time.html   https://www.lesstif.com/display/JAVA/Joda-Time   http://jojoldu.tistory.com/26  ","categories": ["JAVA"],
        "tags": ["assertJ","joda-time"],
        "url": "http://localhost:4000/java/AssertJ-in-joda-time/",
        "teaser":null},{
        "title": "DEV Seminar : 좋았을걸; Front-end' 후기_section 1",
        "excerpt":"   내용에 앞서…  패스트 캠퍼스에서 주관하는 ‘DEV Seminar, 좋았을걸; Front-end’ 세미나를 다녀왔다.   조금은 비싸게 느껴지는 참가비와 프론트엔드보다는 백엔드를 준비하는 입장이지만, 다음 두가지 매력에 이끌려 신청하게 되었다.       1. 상대적으로 취약한 프론트엔드(자바 스크립트)기술의 조언을 구하고자       2. 세미나 연사 중 3분 중 2분이, 항상 내 마음속 1순위 ‘우아한형제들’의 시니어라는 점     사실 2번에 대한 비중이 더 크지만, 어쨌든 이런 네트워크는 강의 내용 뿐만 아니라, 참석한 동료 개발자들을 보면서도 긍정적인 자극을 구해가는 좋은 시간이 된다는 것을 잘 알기 때문에 큰 망설임 없이 신청할 수 있었다.   강연장은 ‘마루180’이라는 역삼역 1번출구로 나가 도곡동 방향으로 향하는 길에 위치해있다. 마루180은 아산재단에서 운영하는 스타트업 기업을 상대로 공간을 대관해주는 곳인 것 같다.    건물 로비 카운터에서 볼 수 있는 다양한 스타트업 스티커들    귀여운 입구 전경        실전 프론트엔드 개발 취직 &amp; 이직 이야기  첫번째 발표는 취직&amp;이직에 앞서 발표자님의 이직하는 과정을 생생하게 들려주었다.   강의는 크게 다음의 3가지의 메세지를 전달한다고 했다.     프론트엔드 면접이야기   프론트엔드는 어디까지 개발해야 하는가   프론트엔드 개발자는 어떤 작업   본격적인 강의 내용에 앞서 강연자님은 자신의 지난 회사생활(인턴쉽 포함)을 회고하며, 자신이 어떤 기술 스택을 쌓아왔고 어떤 과정을 거쳤는지 객관적으로 자신을 분석했다.   각각의 포지션에서 자신이 어떤 능력을 발휘할 수 있었고, 무엇이 아쉬웠으며, 무엇을 깨달았는지도 잘 정리된 모습이 인상적이었다.      특히 이 중 기술적으로 기억에 남는 내용은 ‘Progressive Web App(PWA)’ 에 관한 내용이다. 간단히 표현하면 사용자는 간단한 설치를 통해 웹 앱에서도 모바일 앱과 같은 사용자 경험을 느낄 수 있는 기술이다. 최적화된 웹 성능에 모바일 Native 기능을 결합한 최신 웹 기술이라고 하는데, 이건 최근 프로젝트에서도 반응형 웹이지만 모바일 앱에서 크고 작은 이슈로 골치를 썩어봤기 때문에 반드시 자세히 조사해봐야겠다.    아마 이런것이 경력관리가 아닐까.   발표 중간중간에 “이력서는 항상 가슴에 품고 살아라” 라는 말씀을 하셨던 것이 기억에 남는다.   이 말은 항상 이직할 준비를 하라는 메세지라기 보다는, 항상 자신의 이력을 관리하여 자신의 상태를 체크하고 객관적으로 자신을 바라보라는 얘기일 것이다. 특히 개발자는 하이프 사이클 중 ‘고원’의 단계를 빗대며, 이를 탈피해야 한다고 강조했다.     가트너의 Hype-Cycle     가트너에서 발표한 기술의 성장 주기 그래프 중 ‘Plateau of Productivity’ 단계는 기술의 성장주기 마지막 단계로 기술이 자리잡아 관망하는 단계로, 개발자에게 이 단계는 더이상 기술적 발전이나 성숙의 단계가 아닌 ‘정체되는 시기’를 의미하는 것 같다.    이처럼 이력관리를 통해 자신이 ‘고원(Plateau of Productivity)’의 상태로 나타난다면 준비된 이력서를 갖고 본격적으로 자신을 발품하는 활동을 하면 된다고 한다.   지피지기면 백전불태 : 적을 알고 나를 알면 100번 붙어도 위태롭지 않다   이직준비에 앞서 자신이 어떤 스탠스로 이직을 준비했는지 상세히 설명해주었다. 특히 ‘백전불태’가 흥미로운 대목이다. 백전백승 필승 전략이 아닌, 어떤 상황에서도 위태롭지 않을 유연한 전략을 준비했다.      지피지기 : 개발자 그리고 회사 / 나는 어떤 회사에 가고 싶은가 / 이력서 / 티타임   면접 라이브 코딩 실습   면접 그리고 연봉협상   5전불태 : 5가지 면접 문제 함께 풀기 + 해설   맺음말   Digging Deep(x), List(o) - 다양한 내용, 홀로 학습하기   하나를 깊이 파는 것 보다는, 다양한 내용을 리스트업하여 준비했다고 한다.     회사가 뽑고 싶은 사람은 누구일까   내가 생각하는 좋은 회사는 무엇일까   이렇게 자신만의 기준을 스스로 확립하여 이력서를 준비 다음과 같이 준비했다고 한다.   이력서 Tip     자유 양식 이력서            이름       Email, github, Blog       사진 x           Summary 2~3줄   경력 : 최신순 DESC   Personal Project : 직무와 연관성 있거나 기술적 난이도가 있는 것 넣기(너무 오래전에 한 것이나, 완성도가 현재 개발하는것보다 많이 떨어지는 것은 제외)        발표 슬라이드 (기술발표 기회 있으면 참여)              Summary                    지금까지의 경험           관심사           하고 싶은 것  eg.백엔드 개발을 좋아하는 프론트엔드 개발자입니다 ~~~                       이력                    어떤일을 / 어떤기술로 / 왜 했는지           그 일이 어떤 결과를 이끌어 냈는지 (성과나 성취 중심)           1,2를 한 문장으로                           이와 같은 방법으로 SNS에 공개 이력서를 기재하자 총 30여 곳에서 메일이 왔다고 한다.   면접계획     가고싶은 회사를 1~5순위까지 (면접난이도 고려 X)   처음보는 면접이라면, 정말 가고 싶은 회사는 조금 미루어 두자. 감을 잡기 위한 면접 우선   면접 실제     A 회사            준비                    전 회사의 기술 경험           자바스크립트 기본           리액트                       실제 질문                    전 회사의 겪은 기술적 경험 + 내소개 = 10%           자바스크립트 기분 = 90%           리액트 X                           B 회사            지난 회사의 질문과 반이상 겹치는 부분이 있었음           C 회사            준비                    코딩 테스트 : 해커랭크 10문제 정도 미리 풀기                       실제 문제                    평소에 종종 풀던 codewars 난이도 및 특징이 비슷           javascript 로 간단한 코딩 문제. 연산 수행시간 체크                              Q. 머지소트를 화이트보드에 짜보세요    내용을 보면, 리액트를 개발하며 리액트에 집중해서 준비했지만 실상 프론트앤드 개발자라면 자바스크립트의 본질을 얼마나 이해하고 있는지를 중점적으로 생각하는 것이 눈에 띈다.   실상 너무나 빠르게 급변하는 프론트엔드 프레임워크들에 집중하는 것이 아닌 본질을 얼마나 잘 이해하여 빠른 트렌드의 흐름을 주도할 수 있는지, 보다 긴 호흡으로 개발자를 선발하는 것 같다.   강연 중간에 ‘바닐라 스크립트로 아날로그 시계 만들기’ 문제가 주어졌다. 바닐라스크립트로 시간을 가져와서 계산하는 것은 조금만 고민해보면 됐지만, 역시나 아직 CSS를 유연하게 사용하지 못하여 한참 헤맸던 기억이 난다. 다시 처음부터 만들어보는 훈련을 해야겠다.   퀴즈출처     이어서 이직에 빠질 수 없는 연봉에 대한 이야기가 나왔다.   일반적인 연봉 상승률     기존 회사 +1년 : 5%   이직할때 보통 10%, 패기있게 20% 불러도됨   거짓말하면안됨 » 3달간의 월급명세서 그리고 작년의 원천징수영수증 제출하면 탄로남 » 하지만 일단 MAX 불러라(어차피 조절돼서 다 깎임)            아무리 주니어일지라도 소극적이지 말고, 합당한 자신의 매력을 어필하여 최고의 연봉을 불러라!            면접을 보기 전에 알아두면 좋을 것들     면접 일정만 최소 한달이 소요된다. 시간 배분을 잘하라.   알고리즘 공부는 평소에 미리해두어야 함. 알고리즘에 벼락치기는 있을 수 없다.   주니어 프론트엔드 개발자라면 자바스크립트 질문이 9할.   내 장점을 살릴 수 있는 회사가 존재한다.     마지막으로 기술 면접에 도움이 되는 몇가지 질문을 남기며 강연을 마쳤다. (추후 업데이트)   마치며..  강연의 내용적인 부분을 떠나서 전반적으로 느낌은 매우 ‘개발자’스러운 발표였다. 강연자님은 내뱉는 워드 하나하나를 매우 신중히 선택하는 느낌이었다. 자신이 내뱉은 워드 하나하나를 다시 생각하며 그 워드가 자신의 메세지를 제대로 전달하는 것을 돕는지 되새기는 모습을 보며, 말할때도 스스로를 디버깅하는 개발자스러운 모습이었다. 또한 강연 내용 중 힘을 주어 말했던 ‘지피지기면 백전불태’ 라는 말이 인상 적이었다.   이것도 참 재미있게 느껴졌던 것이, 보통 ‘백전백승’이라고 표현하지만 모든것을 이기는 것이 아닌, 백전불태. 위태롭지 않을 수 있는 방법을 소개했다.   이것 또한 내가 느끼기기에는 개발에서 100% 완벽함은 없다. 항상 최선의 커버리지를 생각하며 개발하는 개발자의 마인드와 같은 느낌이었다. 완벽한 준비는 없지만, 어떤 위기나 위험이 있어도 커버리지를 최대한 높일 수 있는 준비 방법.   그 자체가 굉장히 개발자스러웠고, 새로운걸 배울 수 있는 좋은 마인드였다.   잠시 소홀했던 이력서 업데이트를 다시 시작해야겠다.  ","categories": ["CONFERENCE"],
        "tags": ["fast campus"],
        "url": "http://localhost:4000/conference/dev_seminar_1/",
        "teaser":null},{
        "title": "DEV Seminar : 좋았을걸; Front-end' 후기_section 2",
        "excerpt":"곧 시니어가 될 주니어를 위한 150분    24년 경력의 김민태님  앞서 이직하는 요령, 이력을 관리하는 노하우 등 구직자 입장에서 강연이 있었다면, 이번 강연은 베테랑 중에서도 베테랑인 24년차 개발자의 노하우를 엿볼 수 있는 시간이었다.   오늘의 주제     사수를 믿지 마라   실질적인 역량 강화를 위한 트레이닝 법   실무자가 갖추어야 할 기술 vs 신기술간의 균형   모든 세션이 그러했지만 특히나 가장 기대했던 세션이었다. 목표로 하는 기업의 시니어 개발자는 어떤 고민을 하고 있을까 대한 궁금증과 더불어, 이제 갓 새내기 주니어에 불과한 나에게 그들의 흔적을 들을 수 있는 기회가 많지 않다.   사실 주제가 굉장히 자극적이다. 강연자님도 이런 주제는 소위 약을 파는 말도 안되는 주제라며, 자신이라면 이런 주제의 강연은 듣지 않았을 거라며 농담을 하셨다.   그렇다면 과연 3시간 동안 과연 우리에게 어떤 약을 팔았는지(?) 정리해보았다.   1. 사수를 믿지 마라      5%~15%    지난 24년여를 돌아보니 자신과 근무했던 사람 중 5~15%정도의 사람만이 존경할만한 우수한 실력을 가졌더라.      A라는 일이 주어지면            1~2명은 문제가 생길만큼 일을 해내지 못한다.       6~7명은 주어진 일을 그럭저럭 해낸다.       1~2명은 주어진 일을 그 이상으로 잘해낸다.           사실 회사의 압장에서는 70~80% 이상이 주어진 일을 하기 때문에 그럭저럭 일을 하는 사람만 있어도 지장이 없다.   하지만 우리가 더 나은 개발자가 되기 위해선 그럭저럭 주어진 일만 해선 안된다. 스스로 자신을 돌이켜볼 필요가 있다.   왜 비율이 이렇게 낮을 수 밖에 없을까?          현대시대는 제품(소프투웨어)를 만드는 것이 점점 힘들고 어려워 지고있다. 고려해야할 사항이 너무나 많다.       단순히 서비스를 개발해서 끝나는 것이 아니라, 내가 만든 앱이 어떤 것들과 연동이 되고 사용자들은 어떤 패턴을 보이는지 분석도 필요하다.       개발이라는 일은 애초에 어려운 일이다   따라서 이 어려운일을 잘해내기란 어려울 수 밖에 없다.(그래서 존경할만한 우수한 실력을 가진 사람이 많지 않은 것)            좋은 습관을 갖고 시작하는 주니어가 많지 않다.       위의 이야기의 연장이다.       개발이라는 것은 굉장히 어렵고 복잡한 작업이다. 때문에 우수한 실력을 갖은 사람을 만나는 것이 그리 쉬운 일이 아니다.   우리는 회사에 입사하면 의식적으로 사수(또는 시니어)는 무조건 나보다 우월하고 잘할 것이란 기대를 하고 그들의 모든 것을 흡수하려 한다.       배움의 의지가 강한 사람일수록, 사수한테 배운 것들을 토대로 반복해서 학습하고 습득하려한다.       반복은 매우 좋은 훈련이다. 반복을 통해 우리는 습관으로 발전된다.       문제는… 주니어에 잘못 배운 습관을 반복하다여 내 몸에 습관이 된다면 그것을 떼어내는 것이 매우 힘들다.   시간이 지나야 우리는 그 습관의 옳고 그름을 판단할 수 있지만, 이미 그것은 우리의 습관으로 자리잡았기 때문에 고치는 것이 쉽지 않다.       그러면 우리는 어떻게 해야할까?      사수를 포함하여 우리가 직멱하는 것에 비판적인 사고를 잃어선 안된다.   하물며 우리는 물건을 하나 살 때도, 합리적인 선택을 위해 많은 것을 따지고 알아보는데 ‘일’에는 적용하지 않는다.   예를들어 수산시장에서 킹크랩을 산다면 &gt; A라는 매장에서 9만원에 판다 &gt; 가격이 미심 쩍다면 &gt; 주변에 불특정한 5군데 정도의 매장의 가격을 물어본다 &gt; 평균 가격을 알 수 있고, 우리는 조금 더 합리적인 결정을 내릴 수 있다.   일을 대하는 태도도 마찬가지다. 한 명의 사수에게만 확인할 것이 아닌, 다양한 사수를 통해 정보를 취득해라. 다양하고 폭넓은 사고를 익히는 것이 중요하다.   (만약 어떤 사수가 자신에게 물어봤는데 왜 못믿고 다른 사람에게 또 물어보냐고 화를 낸다면 최대한 빨리 이직하라)   습관은 관성으로 작용한다. 잘못된 관성이 든다면, 개인의 의지로 탈피하기 힘들다.   2. 실질적인 역량 강화를 위한 트레이닝 법      동기부여    잘하는 사람들은 스스로 동기부여를 만들고, 동기에 대한 힘을 유지시키는 것이 중요하다. 그 힘이 유지 된다면 10번 중 2~3번 행동으로 이어진다. 그 행동의 결과는 다시 새로운 동기부여로 이어지는 선순환이 된다면 성장하는 개발자의 모습일 수 밖에 없다.   학생이라면 좋은 대학교, 좋은 직장이라는 뚜렷한 목표들이 있지만 개발자들에겐 그런 명확한 목표지점이 없다.   때문에 스스로 동기부여를 해서 자신만의 선순환 고리를 만드는 것이 중요하다.   생활속 동기부여 팁      비개발자가 하는 일을, 또는 모든 일들에 대하여 코드적으로 접근하라.            엑셀,워드 등 문서작업 등의 모든 작업들을 소프트웨어로 처리하라.           반복되는 모든 작업들에는 일정한 *패턴이 존재한다. 개발자는 그러한 패턴을 분석하여 자동화 처리를 할 수 있다.       같은것을 계속 다르게 해보라.            일상에서 같은 코드라도 가져다 쓰지말고, 리스크를 감수하더라도 계속 수정하고 새롭게 코딩하라           단, 소스코드를 변경할 때 명백한 근거를 고민해봐야한다. 변화하는 것은 늘 필요하고 좋은 것이지만, 그에 따른 책임과 분명한 이유가 있어야 한다.   이렇게 같은 것을 하더라도 새로운 방법으로 접근하다보면, 사고가 넓어지고 자신의 코드에 자신감이 생긴다.       이것은 곧 주변의 개발자들과 코드에 대하여 생산적인 논쟁으로 이어지고, 신뢰를 쌓을 수도 있다.              Q. 나는 Stack overflow 또는 구글에 잘 짜여진 소스를 가져다 쓰는 개발자이다. 이렇게 남의 코드를 가져다 쓰는것에 자괴감이 들기도한다.     A. 코드 베이스는 어디서든지 가져다 쓸 수 있다. 그럴 수 밖에 없다. 우리가 모든 알고리즘을 만들어서 사용하기는 힘들다.    하지만 가져다 썼다면, 그 포인트를 정확히 이해하고 내 것으로 만들어야만 한다. 가져오는 것이 문제가 아닌, 그것을 어떻게 쓰고 소화하는지가 관건이다.                   Q.자바스크립트 라이브러리 중 ‘;’ 으로 시작하는 코드들이 있다. 왜 굳이 그렇게 시작할까?     A. 자바스크립트는 세미콜론(;)을 굳이 사용하지 않아도, 브라우저상에서 자동으로 처리해주기도 한다.     하지만 불특정한 경우 구분이 되지 않아 코드상에 문제를 일으킬 수 있는 위험이 있다. 이런 예외상황을 방지하기위해서 해당 라이브러리를 어떤 위치에 넣어도 작동할 수 있도록 세미콜론(;) 으로 시작한다.            동료를 위해서 코드를 써라            특히나 프론트엔드 분야는 다른 개발 분야보다 작업의 결과가 브라우저상에 즉각적으로 보여지기 때문에, 이를 적극 활용하여 가까운 동료 뿐만 아니라 오픈소스 등에 기여하며 남을 위한(동료를 위한) 코드를 작성하라                 //TODO : 회사 메일 발송 시스템, 회의실 예약하기 만들자    회사가 시니어에게 원하는 것은?      월등한 실력과 성과를 낼 수 있는 실력            당장 다음달 월급을 걱정하는 회사라면 이것이 1순위           영향력. 주니어, 주변사람들에게 좋은 영향을 퍼뜨려줄 수 있는 사람            코드의 질적인 부분뿐만 아니라, 회사의 분위기 자체를 끌어줄 수 있는 사람(어떤 형태든 에너지가 있는 사람)           feedback loop            남을 위해 코딩하여 얻게되는 피드백은 나를 더욱 신나게 코딩하게 해주는 원동력이 된다 =&gt; 동기부여 피드백           실무자가 갖추어야 할 기술 vs 신기술간의 균형     면접에서 보면 전공/비전공자 차이가 없다. 특히 일반 서비스 도메인 산업군이라면 더더욱.   5년이 지나면 차이를 나타내기 시작한다. -&gt; 부채의식의 차이   부채의식   잘하는 사람은 항상 부족함에 갈망한다. 무언가를 해야한다는 긴장감을 유지시킨다. » 습관으로 발전   내가 무언가를 인지하고 있다는 것은 나의 행동으로 이어진다. 내가 무엇을 모른다는 것을 안다는 것 만으로도 발전할 여지가 있다.   문제의식을 갖고 있는사람은 자신의 부족한 것을 알기 때문에 지나가다가 키워드를 발견하면 한 번 더 돌아 보는 습관이 생긴다.      우리가(프론트엔드 개발자) 하는 일은 화면에 렌더링하기 위해서 결국 HTML 문자열을 조각하는 일 뿐이다.   string 조작을 하는데 왜 이렇게 많은 기술과 복잡한 작업이 필요할까?    Virtual DOM, jQeury 등을 만들어 본 적 있나?   소프트웨어 기본 지식이 없다면, 남들이 만들어 놓은 소스를 사용자로서만 사용하게 된다. 결국 소프트웨어 개발자가 아닌, 소프트웨어 유저로 전이하게 된다.   코어를 의식적으로 분석하는 습관을 갖는 것. 프레임워크 등의 속을 파악해보고 간단한 오픈소스는 직접 짜보는 것도 좋은 방법이다.   비판적으로 수용하는 습관을 갖고, 트렌드에 휩싸이지 않는 것이 중요하다. 새로나온 프레임워크가 어떻게 빌드되고 어떤 특징이 있는지를 학습해보자. 그리고 나에게 적합한 것이 어떤것인지 명확한 이유를 토대로 선택할 수 있다.   이런식으로 비판적으로 받아들인다면, 신기술을 무조건 습득하는 것이 아닌 필요에 따라 주도적으로 리드할 수 있다.   본질을 알고 있으면(소프트웨어 공학적인 것) 최신 트렌드는 그 다음에 따라온다.   정리     지속적인 반복만이 살길, 꺼지지 않는 동기 유지            에너지를 얻는 길 : 외부 행사나 세미나를 적극 참여해 보기           부채의식을 갖은 자와 갖지 않은 자   주도적이고 유연한 프레임 갖기            나에게 잘못된 프레임이 씌워지기 전에 스스로 자기만의 프레임을 갖는 것도 중요하다. 무엇보다 다양한 프레임을 소화할 수 있는 유연함과 인사이트를 갖는 것.           좋은 개발자란?     (행동이 수반되는)자극을 주는 개발자.  다른 사람에게 자극 또는 영감을 줄 수 있는 개발자.    그리고 마지막으로 Q&amp;A시간으로 마무리되었다.      SI업계에서 서비스업계로 전환하고 싶다면 어떻게 넘어갈 수 있을까            자신의 부족함을 알았다면, 잘할 수 있는 길을 찾을 수 있는 길이 많다..                    커뮤니티에 적극 참여하라. 잘하는 사람을 만나서 어떤 상태에 있는지를 빨리 인지해라.           그 다음은 자신의 부족함을 발전 시키기 위해 노오력. 자신을 객관적으로 바라보고 노력하라.           내가 무엇이 부족한지를 작은 단위로 쪼개라. 우리는 코딩할 때 이미 그러한 습관이 되어있다. 그러한 행위를 코딩에서만 할것이 아니라 나 자체를 디버깅해라.                           입사 지원시 예를들어 리액트를 사용하는 조직이라면 아무래도 리액트 사용 경험이 필요하지 않을까            실상 회사에서 무조건 해당 프레임워크 사용자를 원하지 않는다. &gt; 관례적으로 회사 사용 기술을 명시할 뿐이다.       코어만 알고 있다면, 모든 프레임워크는 통용된다. 핵심만 알고있다면 어떤 프레임워크를 쓰더라도 흡수하는게 힘들지 않다.       기본기를 갈고 닦으면 그런건 큰 문제가 되지 않는다.           비전공자로서 반드시 갖추어야 할 소프트웨어 기본 지식은 무엇이 있을까            자료구조(스택,큐,리스트)       OS(운영체제) 운영체제가 어플리케이션을 어떻게 운영하는지       프론트엔드개발자라면 네트워크는 가능한 많이, 깊이 알수록 좋음(HTTP, protocol , REST client…)       알고리즘       파일시스템           ","categories": ["CONFERENCE"],
        "tags": ["fast campus"],
        "url": "http://localhost:4000/conference/dev_seminar_2/",
        "teaser":null},{
        "title": "2018 AWS Summit in Seoul",
        "excerpt":"   AWS Summit 후기   기다리던 AWS Summit이 드디어 개최되었다.   이번 AWS세미나에서 많은 세션들이 동시에 진행되어 필요에 따라 선택해서 들을 수 있었지만, 그 중 가장 기본적이고 메인(?) 세션이었던 AWSome Day을 선택했다.     입장권 발권을 담당하는 프런트의 모습  도착한 행사장에는 생각보다 훨씬 많은 사람이 참석했고, 이런 개발자들의 모임에 자리했다는 것이 아직은 어색하게 느껴졌지만 그것도 잠시. 어느덧 그 분위기즐 즐기게 되었다. 이벤트의 모든 진행은 배부 받은 명찰의 QR코드를 통해 진행되었다. 덕분에 비교적 매끄러운 진행이 유지될 수 있었지만, 각 세션이 끝날때마다 모든 인원이 2~3명의 스태프에게 QR코드를 인증받아야 해서 상당히 붐비는 불상사가 있기도 했다.     배부받은 명찰! 회사명과 내 이름이 적혀있고 하단의 QR코드를 통해 이벤트 인증이 처리된다    잠시 후 세미나장에 입장했다. 밖에서 보던 공간보다 훨씬 크고 멋진 공간이었다. 특히 입장과 동시에 햄버거 세트가 제공되었는데, 무료로 이런 멋진 간식을 나눠주는 AWS의 규모에 다시한 번 놀라움을 금치 못했다.     이런 고급진 햄버거를 마구 뿌려준다!!!    곧이어 첫번째 세션이 시작되었다.     드디어 시작된 세미나  총 6개의 파트로 나누어 진행되었다.     AWS와 함께하는 클라우드 컴퓨팅   AWS 컴퓨팅 및 네트워크 서비스 - EC2, VPC   AWS 스토리지 서비스 - EBS, S3   AWS 보안 및 접근제어 관리 서비스 – IAM   AWS의 데이터베이스 서비스 - RDS, DynamoDB   확장성 있는 아키텍처 구축을 위한 AWS 서비스   사실 세션의 모든 내용을 기록하며 전부 내용을 담고자 했는데, 막상 정리하려고보니 너무 양이 많아 엄두가 나질 않는다.   최대한 핵심적인 내용만 정리해보는게 좋을 것 같다.   AWS와 함께하는 클라우드 컴퓨팅   첫번째 세션은 왜 우리는 AWS를 사용해야하는가. AWS 서비스로부터 어떤 혜택을 누릴 수 있는지 전달했다.   AWS클라우드 컴퓨팅의 6가지 장점 및 혜택           자본비용을 가변비용으로 대체       규모의 경제로 얻게 되는 이점            AWS는 현재 한달에 천만명 이상의 유저가 사용된다. 사용자가 많아질수록 AWS는 더 나은 서비스를 제공하고자 기술적 발전과 할인 이벤트 등 폭 넓은 서비스를 제공하고자 한다.           필요한 용량을 추정할 필요가 없음            보통은 프로젝트가 끝난 후 리소스가 얼마나 필요한지 산정할 수 있지만, 클라우드서비스를 사용한다면 상황에 맞추어 필요한 만큼 유동적으로 사용할 수 있다.           속도 및 민첩성 개선            프로젝트를 진행할 때 필요한 리소스가 있다. 서버 사양, 스토리지 사양 등 벤더와 거래시 견적서를 발송하고 수 주 이상을 기다려서 피드백을 받아볼 수 있지만 클라우딩 환경에서 리소스는 EC2를 사용한다면 3~4분 안에 필요한 자원을 설치하고 사용할 수 있다.           데이터 센터 운영 및 유지 관리에 비용 투자 불필요            기존에 애플리케이션을 만들때 서버와 아키텍처를 만드는데 많은 시간이 필요하지만 클라우딩이 모두 관리해주므로, 우리는 필요한 비즈니스로직과 서비스에만 집중할 수 있다           몇 분 만에 전 세계에 배포            AWS는 전세계에 인트라 스트럭처를 가지고 있다. region을 사용하여 전세계 모든 지역에서 동일한 서비스를 할 수 있다.           ","categories": ["CONFERENCE"],
        "tags": ["aws"],
        "url": "http://localhost:4000/conference/aws_submit/",
        "teaser":null},{
        "title": "2018 Spring camp in Coupang",
        "excerpt":"   드디어 개최된 2018 스프링 캠프   티케팅이 열렸을때 1분도 채 되지 않아 300석이 모두 매진되는 것을 보고 사람들의 열정에 놀라기도 하고, 처음 참가하는 스프링캠프라는 자리가 기대되기도 했다.   평소 잠실대교를 지나며 보던 쿠팡 사옥에서 스프링 캠프가 진행되었다.      올해도 어김없이 ‘인연’, ‘공유’, ‘축제’ 라는 주제로 진행하는 스프링캠프   스프링캠프가 진행된 17층 행사장에는 다채로운 자리가 준비되어있었다.   메인 스포서인 쿠팡을 비롯하여, 야놀자, IBM 등에서 이벤트 및 기념품을 증정하기도 했고, 다채로운 다과들과 기념품들이 전시되어 있었다.     스폰서로 참석한 기업들의 이벤트    기념품 및 다과들    한시간 정도 간식타임을 갖고, 1시부터 본격적으로 세미나가 시작되었다.   Intro   강연의 시작은 쿠팡 김범석 대표님의 축사로 시작되었다.     쿠팡 김범석 대표님  쿠팡은 스타트업으로 시작한 만큼 많은 오픈소스를 기반으로 지금의 위치까지 성장할 수 있었다고 하며, 특히 스프링이라는 오픈 소스에 큰 감사의 표시를 전했다.   월마트, 코스트코 그리고 쿠팡과 같은 물류 사업의 핵심은 SCM(Supply Chain Management)을 통한 재고 관리임을 강조했다.   소비자의 수요를 예측하고, 어떤 시기에 어떤 재고를 얼마나 보유할 것인지. 이 모든 과정이 철저한 데이터를 토대로 공급망을 관리해야하고 이 모든 기술의 핵심은 오픈소스를 활용하는 것이라며, 다시한 번 오픈소스에 감사의 인사를 전하며 인사를 마쳤다.     쿠팡에서 사용하는 오픈소스들    Our Journey to find Hope Coupang MSA      첫번쨰 세션 : Lego(정재훈)    쿠팡 기술의 3가지 큰 변화     PHP &gt; Java 이관   Monolithic Architecture &gt; Micro Service Architecture(MSA) 이관   전사 서비스 &gt; 클라우드 이관   5년전 쿠팡의 서비스 아파치 웹서버 &gt; 톰캣 &gt; MySQL 전체 콤포넌트가 하나의 웹 애플리케이션 서버 =&gt; 모놀리틱 아키텍처   모놀리틱 아키텍처의 한계점     부분의 장애가 전체 서비스의 장애로 이어지다            전체 서비스 중 ‘주문’ 이라는 부분에서 작은 문제가 발생하면, 전체로 이어짐           작은 부분을 수정해도 전체서비스의 Unit Test 및 Integration Test를 진행해야 했다. 이것은 큰 서비스 비용을 차지함   예를들어..            모놀리틱한 아키텍처에서는 DB의 필드를 하나 수정하더라도 사이드 이펙트를 알 수 없다       전체 메일 또는 수많은 사람을 만나서 어떤 사용인지 알아내야 함       그럼에도 혹시 한명이라도 전달받지 못한 사람이 있다면, 장애가 발생할 수도 있다           Scale Out을 하기가 어렵다            주문-결제-배송 » 이 모든 과정이 단일 + Long Transaction       서비스가 성장의 속도를 따라갈 수 없다           배포시간에 대한 기하급수적인 증가            서비스의 규모가 커질 수록 배포 시간이 길어지며, 배포 중간에 누군가 커밋을 해버리면 문제가 발생할 수 있음       배포 깃발을 사용해서 배포시 커밋을 방지해서 빌드의 에러를 방지해야만 했다 » 소규모 인원시에는 가능함             쿠팡에서 실제로 사용했던 배포깃발  이러한 모놀리틱한프로젝트를 마이크로 서비스 아키텍처(MSA)로 변경을 시도함     이것을 비타민 프로젝트(Vitamin Project)로 부름            마이크로 서비스를 위해 모든 도메인 소스들을 모듈화 했음  각각의 비즈니스로직만 수행했다 (order, front, seller, delivery…)       모든 서비스가 api 통신을 함            예외상황등의 처리를 위해 Helper Library를 포함하여 배포했다. 다른 도메인들은 이 헬퍼 라이브러리를 통해 쉽게 접근이 가능함           메세지 큐를 통해 서비스 장애 또는 트랜잭션 실패시 자동으로 복구할 수 있도록 시스템 구성            도메인들은 이벤트를 쉽게 전달받을 수 있도록                    상품 등록시 &gt; 검색에 등록     상품 삭제시 &gt; 검색 삭제                            메시지 큐를 이용해서 가능했음       위 3가지 전략을 토대로 마이크로서비스로 발전에 기여함   Configuration Management DataBase of Coupang (CMDB)      쿠팡에는 마이크로 서비스의 갯수가 수백개 있음   서버의 인스턴스는 10000대 이상   이 많은 서비스를 수동으로 사용할 수가없음 » 자동화를 위한 가장 중요한 시스템 CMDB   Member service라고 하면 key/value storage를 갖고 있음 많은 컴포넌트 들은 그 아래 많은 인스턴스를 갖고 있는 서비스   CMDB에는 어디서 어떻게 무엇을 하는지 모든 정보를 갖고 있다.   실제로 사용중인 인스턴스, 서비스를위한 빌링정보, AWS의 어떤 리소스 등 모든 자원을 가시화 하여 관리할 수 있음     CMDB의 대시보드  클라우드 리소스, 메타데이터, 다양한 조직정보 등 모든 정보를 서비스를 기준으로 Mashup   다양한 서비스에 api를 제공해줌. 자동 복귀/배포까지 가능   Deployment System of Coupang(Bolt2)  왜 MSA에서 배포시스템이 중요할까     - 하루에 100번 이상의 배포 이슈     - 하루에 2000번 이상의 인스턴스에 배포   많은 개발자들의 하루에도 수많은 배포를 하는데 이 많은 배포를 개선하기 위해서 강력한 배포 시스템이 필요함   쿠팡의 배포시스템은 블루/그린 배포 전략사용      Bolt2 시스템    서비스 스택을 자동으로 구축해줌(어떤 EC2, VPC/Subnet 등) 장애시 10초 이내에 서비스를 복구할 수 있음     Bolt2 배포 프로세스  배포시 Lock &gt; Stage &gt; Canary &gt; All &gt; Unlock 의 절차로 배포가 진행됨   이 중 Canary 는 전체 중 하나의 서버에만 배포를 해서 트래픽을 확인하여 정상적인지 확인 후 &gt; 전체(All)에 배포   이 모든 과정이 배포시스템에서 자동으로 처리됨   쿠팡의 A/B Test  기존의 A/ 새로운 B 중 어떤것이 적합한지 어떤 기준으로 판단할 수 있을까? &gt; A/B 테스트   A/B Test 진행에 앞서, 어떤 디바이스, 어떤 비율로 사용자에게 제공할 수 있는지 선택하여 배포한다.   예를들어 아이폰의 사용자 중 20%의 비율로 배포하여 사용자의 흐름을 분삭 한 후 어떤 개선효과가 있는지 피드백을 받아볼 수 있다   API GateWay     API GateWay에서 하루에 발생하는 Api call 수 : 30억개   10,000개 이상의 Api 가 존재함   API Gateway 시스템이 없었을 때     어떤 api를 누가, 어떻게 사용하는지 확인하기 어려움   기능이 변경/추가되거나, Duplicate 또는 전달하기가 힘들었다   전체 애자일 조직에 메일을 보내서 반영통보 또는 사용하지 못하도록 일련의 과정이 메뉴얼하게 진행되었음   그래서 쿠팡은 api gateway라는 시스템을 만들었다         전체 API를 가시화하고 목록을 만듦   각각의 API가 어떤 parameter와 response를 제공하는지 모두 제공   어떤 팀들이 어떤 서비스에서 사용하는지도 가시화했음      gateway를 통해 비효율과 사용 관리가 용이해짐    라우트  모든 컨슈머들이 API Gateway를 통해서 api call 사용자가 많아지면서 트래픽이 많아짐 » API Gateway의 부화   api gateway latency 증가 함   end-to-end 전략      컨슈머들은 api gateway로부터 어떤 데이터를 통신할지 라우팅 정보를 가져오고   그 정보를 바탕으로 프로바이딩에 접근 -&gt; Elastic Load Banlancing(ELB)에 접근(인스턴스 단위로 접근할 수도 있음)   이를 통해 앞서 문제점이 해결됨   예를들어 마이 페이지에서 service api를 호출할때 기존에는 서비스 별 api를 모두 호출했음   그러나 gateway를 통해 한번만 호출함 » 이를 통해 서비스 레이턴시를 줄일 수 있었음      Confidence System of Coupang   장애는 왜 발생할까     code bug   performance issue   h/w failure   배포 단계에서 Canary배포시 새로운 Canary 서버와 나머지 다른 서버를 비교함 (cpu, memory, 주문수 등 다양한 매트릭을 비교) 신규와 다르면 다른 매트릭 값들이 나오기 시작함   이러한 매트릭값을 통해 문제의 유무를 확인할 수 있음      Circuit breaker of Coupang     상시 운영중인 서비스를 모니터링해서 복구화   서비스의 전체 장애 또는 하나의 펑션에 장애 캐시, 스터리지, 네트워크 등에 장애      이 모든 것을 모니터링하고 있다가 서킷 브레이커 시스템으로 복구            장애 발생시 &gt; 잘못된 노드를 제거시키고 &gt; 다른 노드를 자동으로 승격 시킴           상시 운영중인 모든 장애에 대해서 회피를 할 수 있음   Site Reliability Engineering(SRE)     서비스 장애시… 왜 일어났고, 어떻게 해야하고, 이것을 자동화하는 등의 작업을 개발자들이 처리하고 있다(Confidence System / Circuit breaker 등이 포함)            마이크로서비스 시스템을 도전한다면 이러한 SRE 시스템을 고려해보는 것이 좋을 것이다           앞으로 쿠팡은 이를 어떻게 활용할 것인가      MSA 테스트를 해보고싶다고 할때..            기존 모놀리틱한 서비스에서는       하나의 서비스를 테스트해보려고 해도 전체의 Service dependency가 필요하게 된다. api dependency 무결성 / 데이터 무결성 등을 모두 이해해야만 테스트가 가능하다.           하지만 우리는 API Gateway를 갖고 있다.   우리의 API Gateway를 알고 있고, 이 모든 API의 mocking data 제공한다면 테스트를 위한 모든 dependency를 쉽게 사용할 수 있다.      Dynamic Properties MSA환경에서 어떤 설정 또는 내용이 배포된다면 회피하기 힘들다 예를들어 DB connection pool의 자원은 제한적인데 트래픽이 몰리면 병목현상이 일어나기도 한다.   이러한 리소스 문제를 해결하기 위해서 동적으로 자원을 관리해줄 수 있는 properties 변경을 고민하고 있다.     Monolithic Architecture의 한계와 어떻게 MSA를 성공적으로 도입했고, 배포부터 관리하는 과정까지 아주 상세히 들을 수 있었다.   사실 MSA라는 개념을 몰라서 발표 전에 부랴부랴 개념을 확인해보고 세션을 들으니까 훨씬 이해가 잘되었다.   내가 하는 일은 작은 규모의 B2B이기 때문에 MSA를 적용해볼 일이 쉽지 않겠지만, 앞으로 계속해서 Back-end 개발의 트렌드는 이처럼 덩치 큰 모든 것을 작은단위로 쪼개어 얼마나 효율적이고 효과적으로 관리하느냐가 핵심인 것 같다.   내가할 수 있는 최선은 작은 단위의 클라우드 시스템과 자동 배포 등 다양한 도메인 지식을 습득하는 일이겠다.   ","categories": ["CONFERENCE"],
        "tags": ["Spring Camp","MSA","Monolithic"],
        "url": "http://localhost:4000/conference/2018-spring-camp/",
        "teaser":null},{
        "title": "2018 Spring camp in Coupang #2",
        "excerpt":"바쁘다는 핑계로 세미나 후기 정리하는 것을 미루고 있었다.   모든 세션을 정리하긴 힘들겠지만 인상깊었던 두번째 세션인 우아한 형제들의 배민찬 서비스로 세미나 정리를 마무리 하려 한다   이벤트 기반 분산 시스템을 향한 여정(building, event-driven distribute system with spring, aws)      우아한 형제들 : 박용권    배민찬 서비스?    주문 &gt; 요리 &gt; 픽업 &gt; 포장 &gt; 배송 &gt; 전달완료  SCM(Supply Chain Management) 시스템     고객에게 제품을 배송하기 위한 일련의 업무 프로세스를 지원하고, 처리하기 위한 시스템    지난 1년간 SCM 시스템을 운영, 개발하며 주어졌던 고민과 생각했던 아이디어 그리고 결과물에 대한 이야기      독립적으로 실행가능한 애플리케이션을 ‘서비스’ 라고 부름   1개이상의 서비스와 공유 인프라가 모여 하나의 시스템을 구성   지난 2016년의 배민찬 시스템은     사용자 서비스와 백 오피스 모듈로 구성된 monolithic 시스템   상용 온라인 커머스 솔루션을 사용자화   AWS 에서 운영   이 당시는 오프라인 중심으로 배민찬 서비스를 진행함     물류 과정을 엑셀로 수기화 하였기 때문에 오프라인으로 진행할 수 있었음   사용자가 많아지고 서비스가 커지면서 더 이상 수작업으로 진행할 수 없었음 » 자동화 시스템 도입 필요   2016년 말, 물류 시스템 도입 결정   기존의 두 시스템을 통합하는 것이 큼    기존 시스템과 새로운 시스템을 연결해주는 어댑터를 생성했음 (스프링 부트기반, AWS Elastic Beanstalk 에서 운영)   어댑터의 역할          두 시스템간 이질적인 용어와 모델을 번역하는 역할을 수행 (물류 시스템이 이해할 수 있도록) 두 모델이 통합할 수 있는 역할            메세징 기반을 통해 비동기로 시스템간 결합 제거             현재 스토어 시스템은 잘 작동중인데 외부의 다른 시스템이 도입시 비동기로 처리해야 사용자들의 느낄 수 없음                    수신된 메시지에 대해 역동성을 보장하도록 기능해야함                            어댑터 서비스는 왜 새로운 서비스로 만들어야 했을까  기존 서비스에 적절한 계층으로 만들수있었을텐데?   기존에 배민찬에는 레거시시스템이 복잡하게 꼬여 있다. 오래된 시스템으로 너무 많은 불필요한 기능이 얽혀있었다.   기능 변경시 어떤 수준까지 접근해야하는지 리소스가 너무 많이 발생하고, 사이드 이펙트들이 심화되었다   레거시의 반부패 계층을 제거하고자, 계속해서 오르는 트랜잭션, 쌓여있는 기술부채들 등의 개선을 위해 확장성 있는 시스템 도입 필요했음   새로운 기능은 새로운 아키텍처 위에 올리자 » 어댑터 서비스   불어나는 기능, 커지는 서비스, 쌓이는 도메인 지식 새로운 기능이 추가될때마다 모델이 추가되고 작은 계층의 어댑터의 덩치가 커지게 됐다…    업무 지식(도메인 지식)이 쌓이기 시작하면서 점점 그 안의 경계가 보이기 시작했다. 그런 도메인의 경계를 이해하며 SCM 시스템이라는 이름을 붙일 수 있었다.      응집력 있는 도메인 개념을 묶어라            패키지 단위로 모듈을 구성했음            도메인의 경계를 따라서 패키지를 분할하고 그 안에서 도메인/애플리케이션/인프라스트럭처 역할인지 등을 나누었음   즉, 이런 분할을 통해 DDD(Domain Driven Design)에서 말하는 Bounded Context라는 개념을 기대했음      Bounded Context  우리말로 ‘제한영역’ 이라는 의미로,  하나의 모델로 다룰 수 없어 여러개의 모델로 나누어야 한다면 개별 모델의 경계와 모델들 사이의 관계를 분명히 해야 한다.  이경우 bounded context는 개별 모델들이 적용되는 범위를 정의한다.       왜 모듈화인가?   MSA가 잘 알려져있고 도입하면 되는데 굳이 왜…?   도메인을 충분히 이해했지만, 확실하게 도메인을 분리시키기에 이해도가 조금은 부족하다 생각했음 &gt; 리스크가 크다고 생각함 &gt; 잘못수행시 복원하는 위험을 감당하기 힘들었음   모듈을 통해 도메인의 경계를 뚜렷하게 만들어가다보면 추후에 MSA로 할 수 있을것이란 기대를 하게됨   이는 추후 서비스의 독립성을 보장할 것이라 기대   모듈을 통한 기대     모듈간의 상호작용은 내부 프로세스로 처리   단일 트랜잭션 관리로 인해 강력한 일관성확보            함께 변경해야할 데이터는 함께 변경되고, 예외 발생시 함께 롤백되는 트랜잭션을 보장           IDE 통한 손쉬운 리팩토링 작업            단일 프로젝트/ 단일 코드끼리 객체기반으로 참조하기 때문에 IDE를 통해 일관적으로 리팩토링이 가능했음           또 다른 모놀리식 시스템화 현상     모듈화를 통한 도메인 구성이 어느정도 성공되었다고 평가함   그럼에도 계속해서 기능이 추가되면서, 모듈간에 직접참조시 서로가 너무 연관성이 크게됨   입출하에 재고관리 기능 추가시 &gt; 재고관리는 구매/생산 연관 등등 서로간에 강하게 결합성이 높을 수 밖에 없음   상호간의 의존관계를 단순하게 만들기위해서 어떻게 해결해야할까?     이벤트를 통해 모듈간의 결합을 낮출 것이라 기대함      이벤트 생산과 소비를 통한 느슨한 결합(Loose coupling)   이벤트 기반의 아키텍처는 이벤트를 생산 / 소비 / 이벤트를 전달하기 위한 채널     생산 : 이벤트 발행   소비 : 관심 이벤트가 오면 소비   채널 : 생산자와 소비자의 역할을 전달해주는 역할   스프링은 이러한 이벤트를 손쉽게 사용할 수 있도록 도와줌   스프링 애플리케이션 이벤트 매커니즘    이벤트 기반의 모듈을 통해 결합도를 낮출 수 있었다. 의존성도 단순해짐     원격 시스템의 등장, 통합을 위한 숙제거리..  SCM시스템 외에도 주문/상품 시스템 등 서비스가 확대되었다   분산된 시스템을 결합할 아키텍처를 새롭게 형성할 필요가 있었음      객체지향에서 중요한 2가지 요소   강합응집력, 느슨한 결합    시스템에서도 마찬가지였음   시스템 또는 서비스를 통합하기 위한 세가지 방법       원격 프로시저 호출(Remote Procedure Call)   레스트풀(RESTful API)   메시징(Messaging)      원격 프로시저 호출(Remote Procedure Call)            시스템간의 연결을 위해서 공유된 라이브러리가 필요함 &gt; 결합도 상승           레스트풀(RESTful API)            웹이 가진 장점을 가질 수 있는 기술, 분산 시스템에서 적합한       네트워크를 넘어서 넘어가는 과정에서 장애가 발생할 수 있는 통제 시스템 / 트랜잭션 분기시 예외처리 등 관리가 필요함           메시징(Messaging)            메시징 시스템을 통해 견고한 시스템을 반들 수 있음       비동기 메시지를 통해 전달되기 때문에 결합도도 낮출 수 있고       시스템이 커질 수록 메시지를 파악하기 힘들 수 있음           기술 외적으로.. 컨텍스트(시스템,서비스)간 협업을 위한 두가지 방식     동기(요청 후 응답을 기다림) / 비동기(응답과 상관없이 역할 수행)   배민찬은 각 방법의 특성을 고려하여  - 메시징과 레스트풀 API를 적용한 아키텍처 적용   어떤 메세징을 쓸 것인가     카프카와 같은 강력한 오픈소스가 존재함, 그밖에도 AWS SQS등     이후로는 Amazon SNS / Amazon SQS 를 이용한 메시징 아키텍처에 대한 내용과 적용 과정을 다루었다.   메시징 모듈이 어떻게 적용되었는지 소스코드까지 직접 참고해서 설명해주었기 때문에 모든 내용을 담지 못했다. 박용권님 슬라이드 참고   첫번째 세션에서는 MSA 도입과 설계의 과정을 보여주었다면, 이번 세션에서는개발자가 도메인을 이해하면서 모듈간의 역할 분담과 리팩토링하는 과정을 엿볼 수 있었다.   아직은 이렇게 전체적인 아키텍처를 하는 것에 대한 감이 오지 않는다.   지금 이런 기록들이 추후에 설계하게 되는 그 날의 밑거름이 되길 기대해본다.   ","categories": ["CONFERENCE"],
        "tags": ["Spring Camp","우아한 형제들"],
        "url": "http://localhost:4000/conference/2018-spring-camp_2/",
        "teaser":null},{
        "title": "Call by reference in Java",
        "excerpt":"포스팅에 앞서 오늘도 역시나 무지함을 깨닫고 시작한다.   평소에도 기초가 부족함을 많이 느꼈지만, 최근 인스턴스 또는 객체 간 접근의 흐름이 헷갈리면서 call by reference / call by value 라는 개념을 확실히 익히기 위해서 업무 중에 기록해 두고 여유가 있을때 포스팅 하기로 했다.   자바에서 이 두 매커니즘이 어떻게 적용되는지 조사를 시작했다.   call by value와 call by reference 를 검색하면 가장 많이 볼 수 있는 C기반의 swap 함수로 그 개념을 이해할 수 있다.       void valSwap(int a, int b){         int temp = a;         a = b;         b = temp;     }          int main(int args, char** argv){         int a = 3;         int b = 5;         valSwap(a,b);         cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; \"|| b: \" &lt;&lt; b &lt;&lt; endl;     }                             결과 :  a: 10                   b:20                  너무나 당연한 결과이지만 valSwap함수를 호출했지만 스왑이 이루어지지 않는다. 이를 stack 그림으로 참고해 보면 이해가 쉽다.      swap 이라는 함수는 호출되지만 각 변수(a,b,temp)가 할당하는 메모리 주소는 공유되지 않는다.   때문에 main함수에서 선언한 argument a와 b의 값에 영향을 주지 않는다.    argument vs parameter   우리는 흔히 argument와 parameter를 혼용해서 쓰기도한다. 하지만 엄밀히 따지면 두 단어가 갖는 의미는 다르다.   두 단어 모두 인자를 표현하는 단어지만 구분해서 쓰자면 formal-parameter(형식인자) 와 actual-parameter(실인자) 로 이해하는 것이 적당하다.   다음 코드를 통해 그 차이를 살펴보자.    public class ArgumentAndParameter{     public void runFunc(String param) {          System.out.println(\"this is \" + param);      }      public static void main(String[] value) {          String args = \"I am Arguments\";          runFunc(args);      }  }    위 샘플코드에서 runFunc(String param) 함수에 선언된 변수 param은 formal-parameter(형식인자) 즉, Parameter이다. (우리 말로 ‘매개변수’ 라고 표현한다.)   그리고 main함수에서 선언한 변수 args는 actual-parameter(실인자) 즉, Argument이다. (우리 말로 ‘인자’ 로 표현한다)     다시 본론으로 돌아와 call by reference 를 위의 swap 함수를 통해 살펴보자.         void swap(int *a, int *b)     {         int temp = *a;         *a = *b;         *b = temp;     }          int main(int args, char** argv){         int a = 10;         int b = 20;         swap(&amp;a, &amp;b);         cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; \"|| b: \" &lt;&lt; b &lt;&lt; endl;     }                                 결과 : a: 20                   b:10                  이전과 다른 것은 포인터를 통해 변수에 접근했다. 그 결과 스왑이 정상적으로 이루어졌다.   어떻게 이런 결과가 나왔는지 다음의 그림을 참고해보자.      위 그림에서 눈여겨 볼 것은 1번 변수 a,b가 생성되며 표기된 좌측의 100, 104 라는 메모리 주소이다.   call by value 의 예제처럼 일반적으로 Parameter(매개변수)를 선언하여 사용한다면, 각 매개변수는 저마다 다른 메모리를 참조한다.   하지만 포인터를 통해 생성된 매개변수는 그림과 같이 변수명이 같은 메모리를 참조하게 되어 결과적으로 변수 a, b의 결과가 스와핑되는 것을 볼 수 있다.     여기까지가 일반적으로 알고 있는 C를 통한 call by value 와 call by reference의 차이점이었다.   이렇게 끝나면 참 평화롭겠지만, 자바는 조금 더 설명이 필요하다.   Call by value in Java     Data type in Java  그림에서 보이는 좌측의 Primitive 타입(원시타입)만이 소위 call by value 라는 매커니즘이 적용된다.    public class CallByInJava{     public static void runValue(){          int a = 1;          int b = a;          b = 2;          System.out.println(\"runValue, \"+a);       }                  public static void main(String [] args){         runValue();      }  }      결과 : runValue, 1    위 예제의 결과 a는 당연히 ‘1’이 출력된다. 너무 당연해서 설명을 하기도 어렵지만, runValue에서 변수 b는 변수 a를 복제한 것이고, 복제한 b 의 값만 변경했기 때문에 a의 결과에 영향을 주지 않는다.    public class RefClass{     public int id;     RefClass(int id){         this.id = id;     }  }    public class CallByInJava{     public static void runValue(){          int a = 1;          int b = a;          b = 2;          System.out.println(\"runValue, \"+a);       }            public static void runRef(){         RefClass ref = new RefClass(5);         RefClass subRef = ref;         subRef.id = 10;         System.out.println(\"runRef, \"+ref.id);      }            public static void main(String [] args){          runValue();          runRef();       }  }       결과 : runValue, 1 , runRef, 10    subRef.id를 변경하였는데 ref.id의 결과가 바뀌었다. 여기서 우리는 ‘참조(Reference)’라는 개념을 이해해야 한다.   이는 앞서 살펴보았던 C 의 포인터를 통해 메모리 주소를 가리키는 것과 유사한 개념이다.   흔히 자바에서 new 를 통해 생성되는 객체를 ‘인스턴스’라고 표현한다. 이 모든 인스턴스들은 저마다 메모리를 참조하고 있다.   따라서 위 예제와 같이 RefClass ref=new RefClass(5) 를 통해 생성된 RefClass 의 인스턴스는 특정한 메모리를 참조한다.   그리고 새로운 변수 subRef 는 ref 를 참조한다.        RefClass subRef = ref; &lt;/pre&lt;  이것은 ref 와 subRef 두 변수가 모두 같은 인스턴스를 **참조** 하고 있다는 것이다.  따라서 subRef를 변경했지만 ref의 id값이 변경되는 것이다.  이처럼 자바의 데이터타입을 보여주는 위 그림 중 Primitive 타입을 제외한 모든 경우 Call by reference 방식을 통해 인자가 전달된다.   ---  - [이미지 참고](http://choieun.tistory.com/entry/Call-by-value%EC%99%80-Call-by-reference)  - [내용 참고_머루의 개발 블로그](http://wonwoo.ml/index.php/post/1679) - [내용 참고_Mussebio's HuRrah Blog](http://mussebio.blogspot.kr/2012/05/java-call-by-valuereference.html) - [내용 참고_생활코딩 강좌](https://opentutorials.org/course/1223/5375)    ","categories": ["JAVA"],
        "tags": ["Call by reference","Call-by-{Value | Reference}"],
        "url": "http://localhost:4000/java/call-by-reference-in-java/",
        "teaser":null},{
        "title": "2018년 중간에 서서",
        "excerpt":"주말출근에 바쁘다는 핑계로 시작한지도 얼마 안된 블로그 활동이 뜸했다.   일하면서 몰랐던 부분을 알아가며, 포스팅하겠다고 기록해둔 것이 벌써 꽤 많이 쌓였는데 언제정리해야지 하는 ‘언제’는 오지 않았다.   이쯤되면 경각심을 일으키기 위해서 흔히 등장하는 초심을 돌아봐야 한다.   사실 올 초에 이것을 고민하면서 블로그 가장 메인으로 기록해서 되새길것을 생각했는데 급한 마음에 시작한 블로그는 주먹구구식으로 적어가는 낙서장이 되었다.     각설하고, 지금 메이저리그에서 가장 뜨거운 남자인 오타니 쇼헤이가 활용한 훈련법으로 유명한 만다라트기법을 차용해봤다.      지난해 12월에 신년 목표를 고민하며 크리스마스 즈음에 작성했던 것으로 기억한다.   정말 엊그제 같은데 벌써 반년이란 시간이 흘러버렸다.   그리고 그 짧다면 짧은 시간동안 꽤 많은 변화 또는 성장과 성장통이 있었다.      1월, 1day 1commit 본격 시작   2월, TDD 스터디모임(토모) 시작   3월, 한빛미디어, ‘비전공자가 프로그래머 되기까지’ 기고   4월~현재, Node.js 및 Vue.js 환경 프로젝트 도입   지난 반년간 나의 생활은 거의 변하지 않았다.   주말에 특별한 약속이 없으면 항상 카페에서 코딩을 해왔고,   일상적으로도 특별히 새로운 사람을 만나거나, 새롭거나 흥미로운 일은 일어나지 않았다.   하지만 ‘개발자의 삶’은 조금 이야기가 다르다.   1day 1commit  사실 이 활동을 하며 이게 옳은 건가 반신반의 하곤 한다.   특히 아쉬운 것은, 1월 초에 처음 시작했던 토이 프로젝트를 다시 구성한다고 아무 생각없이 깃 레파지토리를 삭제하면서 커밋 히스토리 중간에 큰 이가 빠져버리면서 시작과 동시에 이가 빠져버려서 상실감이 들었다.   그리고… 하루에 하나씩 커밋을 하는것이 과연 유의미한 코딩활동인지를 자문해보면 대답하기 부끄럽다. 가끔은 그저 깃 프로필에 색칠공부나 하고 있는게 아닌가 싶기도 하다.   하지만 매일매일 코드를 한 줄이라도 보고, 단 1분이라도 내 코드에 대한 고민을 한다는 것에 의미를 부여하자면 스스로 합리화를 하는 정도는 될 것 같다.   생산적인 코드를 생산하기 위한 과정이라고 믿고 싶다.   이것이 옳고 그른지는 올 해를 마무리하며 다시 돌아보는 것이 좋을 것 같다.   TDD 스터디 : 토모  올해 가장 큰 수확 중 하나이지 않을까.   작년에도 몇개의 스터디에 몸을 담았었다. 알고리즘, 웹 프로젝트, Node.js 스터디 등…   하지만 어느 하나 2달 이상 유지된 스터디가 없었다. 나의 부족함이 가장 컸을 것이고 궁극적으로 내가 정말 무엇을 공부하고 싶은지 모르고   그냥 뭔가 해야겠다는 의욕만 앞서 시작했던것의 당연한 결과이지 않을까 싶다.   사실 TDD스터디도 시작은 그러했다.   스터디 직전에 테스트 주도 개발을 읽은 후 한글로 된 책인데 영어로 읽은것보다 이해가 안되는 큰 좌절감을 맛 본 직후에 우연히 TDD 스터디 모집글을 보게 되었고,   여전히 앞선 의욕만 갖고 스터디를 신청하게 되었다.   사실 몇번의 스터디를 통해서 미지근함을 맛보았기 때문에 큰 기대를 하지 않고 시작했지만 이 스터디는 달랐다.   주니어 개발자로만 모였던 구성 자체도 좋았고, 일반적으로 관심 밖이었던 TDD라는 주제는 꽤나 신선했다.   (주로 웹 프로젝트나 알고리즘 스터디 등으로 포트폴리오나 결과가 당장의 눈에 보이는 취업을 위한 스터디…)   TDD라는 것의 중요성은 여기저기서 많이 들었지만, 주변에서 TDD기반으로 개발하는 모습을 본적도 없고, 과연 이걸 어떻게 써야할지 감도 오지 않았다. 너무나 추상적이고 막연한 작업이었기 때문에 어떻게 시작해야할지 손도 쓰지 못했다.   하지만 이러한 주제보다 좋았던건 역시 구성원이었다.   2년차부터 많게는 3~4년차 로 구성된 개발자들은 의욕도, 서로 추구하고자 하는 방향도 너무 잘맞았다.   서로 존중하고, 배려하고 무엇보다 더 좋은 코드를 생산하기 위해 고민하고, 고충을 나누었다.   일하는 중에도 서로 알게된 정보나 도움이 필요하면 너나 할 것 없이 적극적으로 고민해주고 생산적이 대화가 오고 간다.   일주일에 한번씩, 귀중한 주말 시간을 내어 만나서 코딩도하고, 정보를 공유하기도 하고, 코드를 리뷰하기도 한다.   처음은 TDD를 설계하여 우리가 하는 작업에 적용해보자는 취지로 시작했지만,   아직은 이 TDD가 그렇게 간단하게 느껴지지 않는다. TDD는 단순히 테스트를 하는 것이 아니고 설계를 하는 최초의 과정인데   아직 나에겐 그런 설계 능력이 부족하다.   설계에 대해서 고민하다보면 디자인 패턴을 찾게 되고, 디자인 패턴을 찾다보면 아키텍처를 위한 UML을 그려볼 필요도 있으며, 무엇보다 주력으로 사용하는 ‘자바’를 아주 잘 이해하고 있다는 것을 기본으로 한다.(자바 뿐만아니라, 객체지향의 기본적인 개념)   아주 먼길을 돌아 돌아서…여기서 특이점이 왔다.      ‘자바’를 잘 모르고 있었다는 것이다.    인정하고 싶지 않았지만, 자바를 쓸 줄 몰랐다.   매일 아무 생각없이 사용하던 String 이라는 객체가 갖고 있는 특징도 제대로 이해하지 못하고 있었고,   클래스를 생성하면서 고려할 것들, 특히 접근제어자(public, private, protected)를 고민해본적도 없었다.   그러다 보니, TDD보다 자바라는 언어를 이해하는 것이 급선무라는 아주 원론적인 부분으로 돌아오며 매일같이 자괴감을 느끼곤 한다.   스터디를 이야기하려다가 너무 많은 이야기가 돌고 돌았다.   아무튼 스터디는 언제나 옳다. 그리고 나에게 맞는, 좋은 사람들과 함께할 수 있는 스터디를 할 수 있다는 것은 정말 ‘행운’이다.   ‘비전공자가 프로그래머 되기까지’ 기고  어느날 친구가 링크하나를 보내주었다.   내용인즉슨, 비전공자에서 프로그래머되기까지의 과정을 기고하는 것이다.   평소 글쓰는 것도 좋아하고, 프로그래밍이라는 것을 공부하면서 큰 목표로 삼았던 것 중에 하나가 나와 같은 비전공자나, 코딩을 하고싶어하는 어린 친구들에게 도움이 될 수 있는 사람이 되고자 했다.   구체적으로 어떤 방법으로 활동할지는 몰랐지만, 어떤 방법으로도 그들에게 도움을 줄 수 있는 사람이 되고 싶었다.   하지만 막상 기고를 앞서 두려움이 컸다.     이제 시작한지 얼마 되지도 않는 내가 하는 이야기를 누가 들어줄까.   과연 내 이야기가 설득력이 있을까   다른 개발자가 보기에 나의 이야기가 얼마나 우습게 들릴까   등등 걱정도 앞섰고, 자신도 없었다.   하지만 쓰는건 나의 몫이고, 내 글을 읽는건 독자의 몫이다. 똥이면 뱉을것이고 된장이면 삼킬것이다.   내 똥글을 보고 누군가 힘이 되거나 도움이 된다면 너무나 감사할 일이고,   또한 누군가 나의 이야기에 질책 또는 비평을 해준다면 그것 또한 최고의 피드백이될 것이다.   사실 나에게 실이 될건 없다. 그래서 썼다.   한달정도 틈틈히 이야기를 정리했지만, 지금 읽어봐도 너무나 부끄럽고 첨언하거나 수정하고 싶은 부분 투성이다.   하지만 저게 나인걸.   어쨌든 내 부족한 글이 한빛미디어라는 걸출한 출판사의 웹북에 실렸다는 것 자체가 나에겐 꽤나 의미있고 재밌는 일이다.      글을 쓰면서 코딩하는 것과 똑같은 작업이라는 것을 느꼈다.         어떤 내용을 담을지 구상한다 - 기획     단락 또는 목차를 구상한다 - 인터페이스 설계     인터페이스를 토대로 내용을 작성한다 - 클래스 &amp; 메인 로직 작성     작성된 이야기 부분 또는 전체를 검토한다 - 유닛 및 통합 테스트      무역학도에서 개발자가 되기까지   앞으로도 무엇이 됐던, 내 안에만 갖고 있지 말고 활용하자. 정말 피가 되고 살이 된다.   Node.js &amp; Vue.js  Vue.js는 작년부터 조금씩 활용해봤지만, 사실 거의 JSTL 쓰듯이 정말 덕지덕지 써왔다.   하지만 이 어설펐던 작업 역시 나에게 살이 되었던 것 같다.   작은 단위의 기본적인 문법만 사용했지만 그 작은 사용 자체가 새로운 프레임워크를 사용한다는 두려움을 없애주었고, 왜 이것을 사용하는 것이 좋은지를 깨닫게 해주는 좋은 계기가 되었다.   현재 진행하는 프로젝트는 처음으로 ‘back-end’(tomcat)와 ‘front-end’(node) 서버를 독립시켜서 진행한다.   말로만 듣던 webpack도 사용하고 있고, Vue.js를 이용하여 나름대로 프레임워크를 구성하여 컴포넌트 단위로 작업을 진행한다.   SPA를 만들며, 웹 페이지와 Vue.js가 랜더링되는 라이프사이클을 이해해야했고   컴포넌트 또는 모듈 단위로 작업을 쪼개어 필요한 부분에서 손쉽게 재사용할 수 있도록 작업을 진행할 수 있었다.   이것 또한 누군가에겐 너무나 당연하고 손쉬운 작업이겠지만, 이제 만 1년차 신입에겐 모든게 새롭고 재밌고 흥미롭다.   이부분에 대해서도 담을 이야기가 많지만, 프로젝트가 끝나는 시점에 다시한 번 정리하는 시간을 갖는게 좋을 것 같다.     2018년의 절반을 향하고 있는 현재 시점에서, 2년차 개발자로서의 삶은 매우 안녕하다.     ","categories": ["ETC"],
        "tags": [],
        "url": "http://localhost:4000/etc/2018_%EC%A4%91%EA%B0%84%EC%A0%90%EA%B2%80/",
        "teaser":null},{
        "title": "[펌]Javascript style guide Google",
        "excerpt":"최근 자바스크립트에 미진함을 많이 느끼던 중 과거 스터디원 중 한 분이 구글에서 정의한 자바스크립트 스타일가이드를 언급했던 것이 생각나, 내 블로그에 정리하여 이따금씩 스스로 환기시키기 위해서 기록해 둔다.   해당 내용은 Early adopter 의 디자인 번역 공장 의 내용을 발췌했다.       아직 익숙하지 않은 사람들을 위해, 구글은 깨끗하고 이해할 수 있는 코드를 쓰는 데 있어 가장 좋은 lays out을 제시하는 자바 스크립트(JavaScript) 작성을 위한 스타일 가이드를 내놓았다. 이러한 규칙은 유효한 JavaScript를 작성하기 위한 어렵고 빠른 규칙이 아니며 원본 파일 전체에 걸쳐 일관되고 매력적인 스타일 선택 사항을 유지하기 위한 규정만 있습니다. 이것은 자바 스크립트에서 특히 흥미 롭습니다. 자바 스크립트는 다양한 스타일 선택을 허용하는 유연하고 관대 한 언어입니다. Google과 Airbnb는 가장 인기 있는 스타일 가이드 2개를 보유하고 있습니다. 나는 JS 작성에 많은 시간을 할애한다면 그들 모두를 확인하는 것을 추천합니다. 다음은 Google의 JS 스타일 가이드에서 가장 흥미롭고 관련있는 규칙이라고 생각되는 13가지입니다. 그들은 논쟁 거리가 많은 이슈 (탭과 스페이스, 그리고 세미콜론의 사용 방법에 대한 논란이 많은 논점)에서 저를 놀라게 한 몇 가지 더 명확하지 않은 사양에 이르기까지 모든 것을 처리합니다. 그들은 앞으로 JS를 쓰는 방식을 확실히 바꿀 것입니다. 저는 이글에서 각 규칙마다 사양에 대한 내용을 정리하고 규칙을 자세히 설명하는 스타일 가이드를 예로하는 예시를 제공하겠습니다. 해당하는 경우 실제로 사용하는 스타일의 예를 제공하고 규칙을 따르지 않는 코드와 대조하겠습니다.   탭이 아닌 공백을 사용하십시오. (Use spaces, not tabs)      줄 경계선 시퀀스와는 별도로 ASCII 수평 공백 문자-horizontal space character (0x20)는 소스 파일의 모든 곳에 나타나는 유일한 공백 문자입니다. 탭 문자는 들여 쓰기에 사용되지 않습니다.        // bad     function foo() {     ∙∙∙∙let name;     }          // bad     function bar() {     ∙let name;     }          // good     function baz() {     ∙∙let name;     }    세미콜론이 필요합니다. (Semicolons ARE required)      모든 명령문은 세미콜론으로 끝나야합니다. 자동 세미콜론 삽입에 의존하는 것은 금지되어 있습니다.    왜 누군가가이 아이디어에 반대하는지 상상할 수는 없지만 JS에서 세미콜론을 일관되게 사용하는 것이 새로운 ‘공간 vs 탭’ 논쟁이 되고 있습니다. 구글은 세미콜론을 방어하기 위해 이곳에 단호하게 나왔습니다.       // bad     let luke = {}     let leia = {}     [luke, leia].forEach(jedi =&gt; jedi.father = 'vader')     // good     let luke = {};     let leia = {};     [luke, leia].forEach((jedi) =&gt; {       jedi.father = 'vader';     });   ES6 모듈을 사용하지 마십시오 (아직은..)-Don’t use ES6 modules (yet)      의미론이 아직 확정되지 않았으므로 ES6 모듈 (즉, 내보내기(export) 및 가져 오기(import) 키워드)을 사용하지 마십시오. 이 정책은 의미가 완전히 표준화되면 다시 검토됩니다.        // Don't do this kind of thing yet:     //------ lib.js ------     export function square(x) {         return x * x;     }     export function diag(x, y) {         return sqrt(square(x) + square(y));     }          //------ main.js ------     import { square, diag } from 'lib';    가로 정렬(Horizontal alignment)은 권장되지 않습니다 (그러나 금지되지는 않음).      이러한 관행은 허용되지만 일반적으로 Google 스타일에서는 권장하지 않습니다. 이미 사용 된 위치에서 가로 정렬(Horizontal alignment)을 유지할 필요가 없습니다.  Horizontal alignment는 코드에 추가 공백을 가변적으로 추가하여 이전 줄의 특정 토큰 바로 아래에 특정 토큰을 표시하는 연습입니다.        // bad     {       tiny:   42,         longer: 435,      };     // good     {       tiny: 42,        longer: 435,     };    더 이상 var를 사용하지 마십시오. - Don’t use var anymore      모든 로컬 변수를 const 또는 let으로 선언하십시오. 변수를 재 할당해야하는 경우가 아니면 const를 사용하십시오. var 키워드는 사용하지 않아야합니다.    StackOverflow 및 다른 곳에서 코드 샘플에서 var를 사용하는 사람들은 여전히 볼 수 있습니다. 누가 그것으로 인해 사건을 만들지, 아니면 단지 열심히 죽어 가고있는 옛 습관의 사건 일지는 알 수 없습니다.       // bad     var example = 42;     // good     let example = 42;   화살표 기능 선호 - Arrow functions are preferred      arrow functions는 간결한 구문을 제공하고 this에 대한 많은 어려움을 수정합니다. function 키워드보다 arrow functions를 선호합니다. 특히 nested functions의 경우 유용합니다.    나는 솔직히 말해서, 나는 arrow functions이 더 간결하고 보기에 더 좋았 기 때문에 좋다고 생각했다. 그들이 중요한 목적을 달성하는 것으로 밝혀졌습니다.       // bad     [1, 2, 3].map(function (x) {       const y = x + 1;       return x * y;     });          // good     [1, 2, 3].map((x) =&gt; {       const y = x + 1;       return x * y;     });    연결 대신 템플릿 문자열 사용 - Use template strings instead of concatenation      multiple string literals이 관련되어있는 경우 특히 complex string 연결에 대해 Template string (`로 구분)을 사용하십시오. Template strings은 여러 줄에 걸쳐있을 수 있습니다.        // bad     function sayHi(name) {       return 'How are you, ' + name + '?';     }          // bad     function sayHi(name) {       return ['How are you, ', name, '?'].join();     }          // bad     function sayHi(name) {       return `How are you, ${ name }?`;     }          // good     function sayHi(name) {       return `How are you, ${name}?`;     }    긴 문자열에는 줄 연속을 사용하지 마십시오. - Don’t use line continuations for long strings      일반 또는 template string literal에서 줄 연속을 사용하지 마십시오. 즉, string literal에서 backslash로 줄을 끝냅니다. ES5에서는 이것을 허용하지만 slash 뒤에 공백이 오는 경우에는 까다로운 오류가 발생할 수 있으며 독자에게는 덜 분명합니다.    흥미롭게도 이것은 Google과 Airbnb가 동의하지 않는 규칙입니다 (Airbnb’s spec 참조). Google은 긴 strings을 연결하는 것을 권장하지만 (아래 그림 참조) Airbnb의 스타일 가이드는 본질적으로 아무 것도하지 말고 긴 문자열을 필요할 때까지 계속 사용할 것을 권장합니다.       // bad (sorry, this doesn't show up well on mobile)     const longString = 'This is a very long string that \\         far exceeds the 80 column limit. It unfortunately \\         contains long stretches of spaces due to how the \\         continued lines are indented.';              // good     const longString = 'This is a very long string that ' +          'far exceeds the 80 column limit. It does not contain ' +          'long stretches of spaces since the concatenated ' +         'strings are cleaner.';   “for … of”는 ‘for loop’의 올바른 유형입니다.      ES6에서 이 언어는 이제 3 가지 다른 종류의 forloops를 갖습니다. 가능한 경우for-of loops를 선호해야하지만 모두를 사용할 수 있습니다.    당신이 나에게 묻는다면 이것은 이상한 것이지만, Google이 for loop의 기본 유형을 선언하는 것이 꽤 흥미 롭기 때문에 그것을 포함시킬 것이라고 생각했습니다. 저는for… in loops는 객체에 더 좋았고 for… of 는 배열에 더 적합하다고 생각했습니다. 올바른 직업을위한 올바른 도구 유형의 상황. Google의 사양은 반드시 그 아이디어와 상반되는 것은 아니지만, 특히이 loop에 대한 선호도가 있다는 것을 아는 것은 여전히 흥미 롭습니다.   eval ()을 사용하지 마십시오.      eval 또는 Function(…string) 생성자를 사용하지 마십시오 (code loaders제외). 이러한 기능은 잠재적으로 위험하며 단순히 CSP 환경에서 작동하지 않습니다.    eval()의 MDN page에는 “eval을 사용하지 마십시오!”라는 섹션이 있습니다.       // bad     let obj = { a: 20, b: 30 };     let propName = getPropName();  // returns \"a\" or \"b\"     eval( 'var result = obj.' + propName );          // good     let obj = { a: 20, b: 30 };     let propName = getPropName();  // returns \"a\" or \"b\"     let result = obj[ propName ];  //  obj[ \"a\" ] is the same as obj.a   Constants는 underscores로 구분 된 ALL_UPPERCASE에 명명되어야합니다.      Constant 이름은 CONSTANT_CASE를 사용합니다. 단어는 모두 underscores로 구분하여 대문자로 모두 사용하십시오.    변수(variable)가 변경되지 않아야한다고 절대적으로 확신하는 경우, 상수(constant)의 이름을 대문자로 표시하여 이를 나타낼 수 있습니다. 이렇게하면 상수(constant)의 불변성이 코드 전체에서 사용됨에 따라 명확 해집니다. 이 규칙의 주목할만한 예외는 상수(constant)가 함수 범위(function-scoped) 인 경우입니다. 이 경우 camelCase로 작성해야합니다.       // bad     const number = 5;          // good     const NUMBER = 5;    선언(declaration) 당 하나의 변수(variable)      모든 지역 변수( local variable) 선언은 하나의 변수만(only one variable) 선언합니다. let a = 1, b = 2; 가 사용되지 않습니다.    변수(variable)가 변경되지 않아야한다고 절대적으로 확신하는 경우, 상수(constant)의 이름을 대문자로 표시하여 이를 나타낼 수 있습니다. 이렇게하면 상수(constant)의 불변성이 코드 전체에서 사용됨에 따라 명확 해집니다. 이 규칙의 주목할만한 예외는 상수(constant)가 함수 범위(function-scoped) 인 경우입니다. 이 경우 camelCase로 작성해야합니다.       // bad     let a = 1, b = 2, c = 3;          // good     let a = 1;     let b = 2;     let c = 3;   Use single quotes, not double quotes      Ordinary string literals은 큰 따옴표-double quotes ( “) 대신 작은 따옴표-single quotes ( ‘)로 구분됩니다.  팁 : string에 작은 따옴표(single quotes) character가 포함되어 있으면 따옴표를 escape하지 않아도 되도록 template string을 사용하는 것이 좋습니다.    변수(variable)가 변경되지 않아야한다고 절대적으로 확신하는 경우, 상수(constant)의 이름을 대문자로 표시하여 이를 나타낼 수 있습니다. 이렇게하면 상수(constant)의 불변성이 코드 전체에서 사용됨에 따라 명확 해집니다. 이 규칙의 주목할만한 예외는 상수(constant)가 함수 범위(function-scoped) 인 경우입니다. 이 경우 camelCase로 작성해야합니다.       // bad     let directive = \"No identification of self or mission.\"          // bad     let saying = 'Say it ain\\u0027t so.';          // good     let directive = 'No identification of self or mission.';          // good     let saying = `Say it ain't so`;     최종 메모   제가 처음에 말했듯이, 이것들은 명령이 아닙니다. Google은 많은 기술 대기업 중 하나 일뿐입니다. 즉, 우수한 코드를 작성하는 데 많은 시간을 할애하는 훌륭한 사람들을 고용하고있는 Google과 같은 회사가 제안한 스타일 권장 사항을 살펴 보는 것이 흥미 롭습니다. ‘Google 준수 소스 코드(‘Google compliant source code’ )’에 대한 가이드 라인을 따르고 싶다면 이 규칙을 따라야합니다. 물론 많은 사람들이 동의하지 않을 수 있으며 이 중 일부 또는 전부를 마음껏 쓸 수 있습니다. 저는 개인적으로 Airbnb의 사양이 Google보다 더 매력적이라고 생각합니다. 이러한 특정 규칙을 취하는 태도에 상관없이 모든 종류의 코드를 작성할 때 문체의 일관성을 염두에 두는 것이 중요합니다.    원본 링크 https://www.vobour.com/@early-adopter  ","categories": ["ETC"],
        "tags": ["Javascript"],
        "url": "http://localhost:4000/etc/js_google_standard/",
        "teaser":null},{
        "title": "Cookie 와 Session 에 대한 이야기",
        "excerpt":"얼마전 Cache에 대한 정확한 정의를 공부해야 겠다고 생각하던 찰나 중 어떤 평소 즐겨 보는 창천향로님의 블로그에서 기술면접 질문을 접하게 되었다.   질문의 내용인 즉슨   String user = httpSession.getAttribute(\"user\");     질문 1)    여기서 session의 값을 가져오는 key는 “user”입니다.    사용자 A가 접속해도 “user”로 값을 가져오고, 사용자 B가 접속해도 “user”로 가져오는데 어떻게 A와 B가 접속했을때 서로 다른 결과값을 받을수 있나요?       질문 2)    본인이 만든 프로젝트는 톰캣을 내렸다가 올리면 로그인이 풀리지 않나요?    톰캣을 내렸다가 올려도 로그인이 풀리지 않으려면 어떻게 해야할까요?       질문 3)    세션은 서버에 저장되고, 쿠키는 클라이언트에 저장된다고 하셨는데, 그럼 쿠키가 안되는 상황에서도 세션은 사용할 수 있나요?      질문을 고민하기전에 가장 먼저 ‘왜’ 쿠키와 세션이라는 개념이 필요한지 살펴보는 것이 중요할 것 같다.   세션과 쿠키는 네트워크 망에서 서버와 클라이언트가 상호간 통신을 할 때 사용하는 수단을 말한다.  이 기술들의 목적은 “상태 유지” 에 있다. 웹 환경에서 사용되는 HTTP 프로토콜은 서버와 클라이언트가 통신을 완료하면 연결을 끊어버린다.   한번의 통신에 요청과 응답을 하나로 묶고 연결을 끊어버리는 프로토콜을 무상태 프로토콜 (Stateless Protocol) 이라고 한다.   그러면 이 무상태 프로토콜이 필요한 이유는 무엇일까?   무상태 프로토콜의 가장 큰 장점은 통신을 하면서 발생하는 수많은 리소스를 절약할 수 있다는 것이다.  무상태 프로토콜의 가장 대표적인 프로토콜은 HTTP이며, 주 목적은 웹 상에서 HTML 문서를 서빙하는 것이다.   세션과 쿠키는 하는일과 목적은 같지만 저장하는 방법에 따라 둘을 구분 짓는다. 쿠키는 클라이언(사용자) 로에 저장(보관), 세션은 서버에 저장하므로,   쿠키는 사용자의 민감한 정보를 다루는 것은 매우 위험하고, 쇼핑몰로 예로들면 장바구니에 담는 사용자 쇼핑 기록 정도를 저장시 쿠키를 활용한다라고 말한다.        그러면 다시 질문으로 돌아가서, 세션과 쿠키를 적절히 이용한다면 이 질문에 답을 할 수 있지 않을까   부끄럽지만 사실 위 질문 3개를 모두 처리해본 적이 없다.  우선 내가 아는 선에서 1번 문제에 대한 답변을 정리해보았다.   1. 이것이 질문의 요지에 맞는지 모르겠지만, 기본적으로 사용자가 해당 도메인에 접근시 톰캣(다른 WAS는 확인하지 못했다.)에서 클라이언트 고유의 SESSION ID를 할당해준다.  이는 로그인 유무와도 무관하게 모든 사용자에게 부여되는 고유 ID이다. 따라서 \"name\"이라는 session 키 값에 해당 session id 값을 value로 하여 활용한다면, 유저간에 구분된 결과를 처리할 수 있지 않을까. 이를 계속 유지시키기 위한다면 쿠키에 해당 SESSION ID 정보를 저장하여 활용할 수 있을 것이다.    2. 이부분은 내용이 생소하여 검색을 해보니, 톰캣 내 설정으로 세션을 유지시키는 방법이 가능한 것 같다. 톰캣의 server.xml 에 다음의 설정을 추가하자.     &lt;Manager className=\"org.apache.catalina.session.PersistentManager\"                      saveOnRestart=\"true\"                      maxActiveSessions=\"-1\"                      minIdleSwap=\"-1\"                      maxIdleSwap=\"-1\"                      maxIdleBackup=\"-1\"&gt;               &lt;Store className=\"org.apache.catalina.session.FileStore\" directory=\"/session\" /&gt;   &lt;/Manager&gt;   saveOnRestart 이 부분이 세션을 유지시킬지 설정하는 것이기 떄문에 해당 부분을 false로 저장한다면, 서버 재구동시마다 세션 정보를 저장하지 않도록 처리할 수 있다.   3. **Q. 세션은 서버에 저장되고, 쿠키는 클라이언트에 저장된다고 하셨는데, 그럼 쿠키가 안되는 상황에서도 세션은 사용할 수 있나요?** 음.. 처음 질문을 보고 몇초간 질문의 의도가 파악되지 않아 당혹스러웠다. 쿠키가 안되는 상황.. 이라고하면 위에 표에 있는 쿠키 제한 사항 중 - 현재 도메인에 20개 이상의 쿠키를 사용하는 경우 - 쿠키의 사이즈가 4KB 이상인 경우 - 해당 클라이언트에 300개 이상의 쿠키가 적재된 경우  위 경우 쿠키의 사용이 제한되는것일 텐데, 이런 클라이언트의 환경이 세션이 저장되는 서버와 연관이 있을까?   ","categories": ["WEB"],
        "tags": ["Cookie","Session"],
        "url": "http://localhost:4000/web/cookie_and_session/",
        "teaser":null},{
        "title": "반복문 성능 이야기",
        "excerpt":"뒤늦게 Java Stream에 관심이 생기면서, forEach의 성능에 대한 이슈를 접하게 되었다. for-loop를 Stream.forEach()로 바꾸지 말아야 할 3가지 이유   그래서 비교해보았다. 일반적으로 사용하는 반복문     While   Iterator   for   for-loop   for each   총 5개의 반복문에 대한 이야기이다.   테스트 케이스는 iterator 및 for-each를 위해서 List로 정의했으며, 100개의 난수 리스트를 생성하여, 리스트 각 인덱스의 총 합을 반복문으로 구현했다.   우선 시간을 계산해야하니까 결과를 ms으로 반환해주는 시간 측정 메서드이다.   class TimerUtil {     long time;      public void start(){         time = System.nanoTime();     }      public double end(){ //        System.out.println(\"compute result : \" + (System.nanoTime()-time)/ 1000000.0);         return (System.nanoTime()-time)/ 1000000.0;     } }     다음은 난수를 저장하는 리스트이다.       private static List&lt;Integer&gt; intStream(){         List&lt;Integer&gt; arrList = new ArrayList&lt;&gt;();         IntStream.range(0, 100)                 .forEach(i -&gt; arrList.add(generator(100)));          return arrList;     }      private static int generator(int max){         Random random = new Random();         return random.nextInt(max);     }   그리고 각 반복문 내용이다.      private static double performanceByWhile(List&lt;Integer&gt; array){         /*             while          */         result = 0;          timer.start();         int s=0;         while(s&lt;array.size()){             result += array.get(s);             s++;         }         return timer.end();     }      private static double performanceByFor(List&lt;Integer&gt; array){         /*             for          */         result = 0;          timer.start();         for(int i=0; i&lt;array.size(); i++){             result += array.get(i);         }         return timer.end();     }      private static double performanceByForLoop(List&lt;Integer&gt; array){         /*             for loop          */         result = 0;          timer.start();         for(int temp : array){             result += temp;         }         return timer.end();     }      private static double performanceByForEach(List&lt;Integer&gt; array){         /*             for each          */         result = 0;          timer.start();         array.forEach((temp) -&gt; {             result += temp;         });          return timer.end();     }       private static double performanceByIterator(List&lt;Integer&gt; array){         /*             iterator          */         result = 0;          timer.start();          Iterator&lt;Integer&gt; itr = array.iterator();         while( itr.hasNext() ){             result += array.get(itr.next());         }          return timer.end();compare_Repetition.jpeg     }    최종적으로 이 모든 과정을 테스트하는 메인 메서드.       public static void main (String [] args){         List&lt;Integer&gt; sumArr = intStream();          int maxCnt = 10000;         double sumTimes = 0;         for(int cnt = 0; cnt&lt;maxCnt; cnt++){         sumTimes += performanceByFor(sumArr);         // sumTimes += performanceByWhile(sumArr);         // sumTimes += performanceByIterator(sumArr);         // sumTimes += performanceByForLoop(sumArr);         // sumTimes += performanceByForEach(sumArr);                  }         sumTimes *= 1000;         System.out.println(\"Result Time : \"+resultAvg(sumTimes, maxCnt));      }   각 반복문의 평균 수행 시간(ms) 결과이다.        테스트 결과로는 While=for &gt; For-loop &gt; For-each &gt; Iterator 순으로 보인다.    올바른 방법으로 테스트한것인지는 검증이 필요하겠지만, 서두에 링크로 참고해두었던 본문 내용에서도 말했듯이 for-each와 같이 Stream을 사용할 경우 누적되는 오버헤드 비용이 많이 발생하기 때문에 큰 사이즈를 반복문 처리할때는 유의해야할 필요가 있을 것으로 보인다.   각각의 역할이 필요한 곳에 따라 유연하게 사용할 수 있도록 보다 확실하게 개념을 공부해야 할 것 같다.  ","categories": ["JAVA"],
        "tags": [],
        "url": "http://localhost:4000/java/java_performance/",
        "teaser":null},{
        "title": "도서 리뷰 시작하기",
        "excerpt":"책과 아주 친하진 않지만 의식적으로 친해지기 위해 노력해왔다.   매달 발생했던 은근히 부담되는 책 값은 알라딘 중고서점이라는 유용한 곳에서 어느정도 해결할 수 있었다.      하지만 중고서점의 한계상 내가 보고싶은 책이 아닌, 서점에 구비되어 있는 책 중에서 골라야만 했고 온라인 검색을 통해 원하는 책이 있는 곳으로 찾아 다녀야 했다.   5천원짜리 커피는 아무렇지도 않게 사먹으면서, 책 값을 얼마나 아끼겠다고 이렇게 궁상을 떨었는지 모르겠지만 그래도 책을 찾으러 이동네 저동네에 있는 알라딘 매장을 찾아 다니는 것, 무심코 놀러간 동네에 알라딘 매장이 보이면 괜히 반가워하며 들어가서 책을 찾아보던 즐거운 기억이 남아있다.   그러던 중     읽고 싶은 책을 읽지 못한다는 한계   ‘내 책’이 되어버리면, 책장에 꽂아 놓고 언제 봐야지.. 생각하며 쉽게 책에 손을 대지 못하던 것   예를들어 나는 TDD에 관해 공부하고 싶은데 알라딘에서 팔지를 않기도 했으며, 어떤 책은 거의 2주 동안 반도 읽지 못하며 차일피일 읽기를 미루고 지루한 독서를 이어가던 고민이 있었다.   그러던 어느 주말, 문득 도서관에는 이 책들이 있을까 호기심에 찾아가봤다.      정말 놀랍도록 읽고싶었던 거의 모든 책들이 너무 잘 정리되어 있었고, 무엇보다 책 상태도 매우매우 양호했다.   너무 기뻤다.   요즘은 인프라도 잘 갖추어져 있어서, 역사마다 도서관 책을 반납하는 곳도 있다.   도서관에서 책을 빌려보면 위에 고민했던 두 가지 고민을 말끔히 해결해준다.      내가 원하는 대부분의 책이 구비되어 있고   2주라는 반납 기간이 있기 때문에, 빌린 책은 2주 안에 봐야 한다는 압박아닌 압박으로 의식적으로 책을 읽게 된다.   그렇게 몇 달간 도서관 덕분에 유용한 독서를 할 수 있었다.        그런데 또… 또.. 문득 특이점이 왔다.   이 좋은 책들, 그리고 어려워서 한 번 읽는 것으로 이해가 되지 않는 책들을   단 한 번만 읽고 반납하는게 나한테 실제로 얼마나 영향을 줄까? 에 대한 의문이 들었다.   어찌보면 형식적으로 독서를 하기위한 독서, ‘나 그 책 읽었어요!’ 뿐인 겉핥기식 독서는 그리 효과적이지 못하다고 생각이 들었다.   그래서 우여곡절끝에 다시 전략을 바꿨다.   서점에서 ‘새 책’을 구매하고, 그 책을 읽고 빨리 다음 책을 읽을 것이 아니라 그 책에 대한 내용 또는 느낀것들을 간단히 남겨보자고.   이전에는 한 달에 2권씩 읽기를 목표로 했지만, 지난 시간 읽었던 책 중 무엇이 가장 좋았고 왜 좋았는지 누군가 물어본다면   정말 대답하기 어려울 것 같다. 솔직히 특별히 기억에 남는 내용이 없다.   특히 개발도서는 소설책 읽듯이 감정을 느끼고, 심장을 울리는 글 귀에 감동하는 것이 아니라 한 문장씩 곱씹으며, 왜 그런 결과가 나오고 내가 무엇을 놓치고 있었는지 깊이 이해하며 읽어야 한다.   그렇기 떄문에 일반적인 책들보다 읽는데도 많은 시간이 필요하고, 그만큼 어려운 부분이 많아 금방 잊혀지기도 한다.   아깝다.   출,퇴근 시간에 공들여 읽은 책들이 내 머릿속에 하나도 남지 않고 지워져 버린다는 것은 너무나 아깝다.   그래서 조금 더 공을 들여보기로 했다.   한 달에 한권이라도 제대로 읽고. 나쁜 머리로 기억하려 하지말고 기록하는 것으로.   어렵고, 번거로운 작업이 될 수 있겠지만 이 또한 내가 한단계 성장할 수 있는 계기가 되리라 믿는다.  ","categories": ["REVIEW"],
        "tags": [],
        "url": "http://localhost:4000/review/%EB%8F%84%EC%84%9C%EB%A6%AC%EB%B7%B0_%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/",
        "teaser":null},{
        "title": "Process와 Thread",
        "excerpt":"Process와 Thread이야기  Process 와 Thread 에 대한 개념은 흔히 언급되는 내용이다. 언뜻 비슷해보이지만, 큰 차이가 있는 이 두 개념을 혼용하지 않기 위하여. 그리고 기본 개념을 다지기 위하여 기록한다.   일반적으로 프로세스와 스레드에 대하여 쉽게 정의하면 다음과 같다.      Process : 운영체제로부터 자원을 할당받는 작업의 단위       Thread : 프로세스가 할당받은 자원을 이용하는 실행 단위    Process  말장난 같은 이야기지만, 일반적으로 프로세스는 우리가 흔히 운영체제(윈도우 또는 리눅스와 같은)에서 프로그램을 실행하는 행위에 동작한다.   프로그램 구동시 운영체제에서는 프로세서를 할당하여 운영에 필요한 주소 공간, 메모리 등의 자원을 할당받는다. 프로그램은 하나의 프로세스에 의해 실행이 될 수도 있으며,  어떤 작업을 하나 이상의 프로세스에서 병렬로 처리하는 것을 ‘멀티 프로세싱(Multi Processing)’ 이라고 한다.   또한 과거 MS-DOS시절과 달리, 최근 사용되는 운영체제는 여러개의 프로세스를 동시에 실행할 수 있는데, 이것을 ‘멀티 태스킹(Multi Tasking)’ 이라고 한다.   프로세스는 각각의 독립된 메모리 영역에서 작동한다.      이러한 메모리 구조를 사용하는 프로세스는 CPU에서 적재된 프로세스의 로테이션을 돌며 ‘멀티 프로세싱’하는 과정에서 문제점을 보인다.   A라는 프로세스가 동작 후 대기중이던 B 프로세스가 실행될 때, A프로세스의 상태(context)는 보관되며 B프로세스의 상태(context)로 교환하는 Context Switching 작업이 일어 난다.   이 과정에서 각각 독립된 메모리 영역에 존재하는 프로세스들은 캐쉬 메모리 초기화 등의 무거운 작업을 반복하며 Overhead 를 발생시킬 수 있다.   Thread  스레드는 프로세스 내에서 실행되는 흐름의 단위이다. 다시 말해, 하나의 프로세서에서 진행되는 각각의 일의 단위이다.   기본적으로 프로세스 당 최소 1개의 스레드가 존재하며, 그것을 Main Thread 라고 부른다. (프로세스 상에 2개 이상의 스레드가 존재한달 경우 멀티 스레드(Multi Thread)라고함.)   스레드는 프로세스상에 실행되기 때문에 하나의 프로세스에 적재되어 Stack 영역만 따로 할당받으며, Code, Data, Heap 영역은 공유되어 사용된다.      메모리를 공유하는 스레드는 전역변수를 통해서 데이터를 공유하고, 시스템의 자원 소모를 줄일 수 있어 효율을 높일 수 있다.   특히 프로세스의 경우 Context Switching이라는 높은 비용을 감수해야 하지만, 스레드의 경우 이런 큰 처리 비용은 고려하지 않아도 된다.   하지만, 멀티 스레드를 사용할 경우 공유된 데이터간의 충돌과 까다로운 디버깅, Dead-Lock 등을 유의하여 사용해야 한다.   간단한 스레드의 예시   public class ThreadTest {      public static void main(String [] args) throws InterruptedException{         final Thread separateThread = new Thread(new ThreadPrinter());         separateThread.start();         for(int i=0; i&lt;5; i++){             System.out.println(\"Main Thread...\" + Thread.currentThread().getName());              Thread.sleep(1000);         }      } }    public class ThreadPrinter implements Runnable{     @Override     public void run(){         for(int i=0; i&lt;5; i++){             System.out.println(\"new Thread...\" + Thread.currentThread().getName());             try{                 Thread.sleep(1000);             }catch (InterruptedException e){                 e.printStackTrace();             }         }     } }        Dead Lock  Dead Lock에 대해서는 유명한 ‘철학자의 식사문제’ 이야기가 있다.      [다섯 명의 철학자와 포크]           다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 포크가 하나 씩 있다.            그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다.            철학자가 스파게티를 먹기 위해서는 양 옆의 포크 두개를 동시에 들고 있어야 한다.            이때 각각의 철학자가 왼쪽의 포크를 들고, 그 후 오른쪽의 포크를 들어야 하는 규칙이 있다고 할 때,            다섯 철학자가 동시에 왼쪽의 포크를 든다면, 오른쪽에 있는 포크는 손에 쥘 수 없으므로(옆의 철학자가 쥐고 있이므로) 무한정 기다려야 하는 교착 상태(Dead Lock) 에 빠지게 될 수 있다.            또한 어떤 경우에는 동시에 포크 양쪽을 집을 수 없어 식사를 하지 못하는 기아 상태가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.         [참고]     https://brunch.co.kr/@kd4/3   https://magi82.github.io/process-thread/   http://icednut.github.io/2016/08/06/20160806-about_deadlock/   ","categories": ["JAVA"],
        "tags": ["Process","Thread"],
        "url": "http://localhost:4000/java/Proces_Thread/",
        "teaser":null},{
        "title": "기본 회고",
        "excerpt":"가까이 있지만 먼 당신들…   분명 현업에서 많이 언급되기도, 직접 내가 표현하기도 하지만   실제로 그게뭐야? 라고 했을때 말문이 막히는 것들이 많다.(사실 대부분이다.)   제대로 알지도 못하고 내가 아는 것처럼 흉내내고 쓰고 있는 것들이 참 많다.   그리고 그때마다 ‘이게 뭐였지?’ 하며 찾아보지만, 뒤돌아 서면 또 까먹는다.   그래서 기록한다.   그리고 또 까먹을 것이다.   그러면 또 이걸 보자.     - ‘RESTful 하다’의 의미는 무엇인가?      RESTful에 대해서 조사를 해보면 참 많은 내용들이 나온다. 대게는 RESTful에서 말하는 REST의 개념 특징을 상당히 어렵게 표현하고 있다.   REST는 Representational State Transfer라는 용어의 약자이며, URI를 이용하여 HTTP Method를 어쩌고..   그러면서 특징으로 유니폼 인터페이스, 무상태성, 캐시 처리 등등.. 을 소개한다.   표현도 어렵고 와닿지 않는다.   사실 이 모든 개념들은 개발자들이 혹은 사용자들이 얼마나 더 유용하고 쉽게 사용할 것인지 고민을 거듭하며 나온 결과라고 접근하면 조금 더 친숙하게 다가올 수 있을 것이다.   많은 자료들을 보며 느낀 REST api를 이용하는 궁극적인 이유는 ‘편리성’ 혹은 ‘규약’ 이라는 느낌이 강했다.   우선 우리는 API라는 인터페이스를 통해 서버와 클라이언트가 소통한다. 그리고 이 API에는 우리의 메세지가 담겨 있어야 한다.   그리고 우리는 REST api 라는 개념을 통해서 어떤 리소스를 다룰 것인지 URI에 표현하고, 그 URI가 어떤 역할을 수행하는지는 HTTP Method를 통해 표현한다.   HTTP Method는 개발자에게 아주 익숙한 CRUD라는 개념을 말해주기 때문에 개발자들간의 소통에 큰 문제가 없을 것이다.   결국 REST api 라는 것은 URI를 통해 해당 api가 어떤 역할을 하는지 직관적으로 표현하여 서버와 클라이언트간 소통의 편리성을 높일 수 있고,   URI는 어떤 역할을 하는지 직관적으로 표현해야하며, HTTP Method 를 통해 역할을 정의한다는 일종의 규약(또는 표준) 을 통해 업무의 효율을 높이는 역할을 하는 것으로 보인다.   - [도대체 뭐가 RESTful 이라는건가?](http://www.chidoo.me/index.php/2016/06/03/what-is-restful/) - [RESTful API란?](https://nesoy.github.io/articles/2017-02/REST)   - XSS(Cross-site Scripting) 란?  쉽게 말해 ‘브라우저에 스크립트를 삽입하여 사용자를 공격하는 행위’를 말한다.   스크립트를 심어두는 것은 웹 서비스의 게시판이 될수도, 검색창이 될 수도 있다.   이렇게 심어진 스크립트를 통해서 무한 반복되는 alert 을 발생시킬수도 있고, 쿠키 또는 세션의 ID를 탈취하여 사용자로 둔갑할 수도 있는 보안상 중요한 이슈이다.   이에 대응하기 위하여 일반적으로    - 자바의 GC는 어떻게 작동할까?  이를 이해하기 위해선 JVM에 대한 이해가 선행되어야 할 것 같다.   - [성능튜닝_가비지 컬렉터(GC) 이해하기](http://12bme.tistory.com/57) - [네이버_D2_GC](https://d2.naver.com/helloworld/1329)   - 1~100까지 더하는 프로그램   public class SumHundred{     public static void main(String [] args){         System.out.println(sumIteration(100));         System.out.println(sumRecursive(100));     }          public static int sumIteration(int n){         int sum=0;         for(int i=1 ; i&lt;=n; i++){             sum += i;         }                  return sum;     }          public static int sumRecursive(int n){         if(n == 1){             return n;         }         return n + recursive(n - 1);     } }    - OSI 7계층에 대하여 설명하시오   - Stack, LinkedList, List의 차이점. Collection Framework에 대한 개념   ","categories": ["JAVA"],
        "tags": ["REST API","XSS","Garbage Collector"],
        "url": "http://localhost:4000/java/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91/",
        "teaser":null},{
        "title": "시작",
        "excerpt":"나는 오늘 무슨 일을 했는가.   주 5일, 8시간씩 매일같이 일을 한다. 주말에도 시간이 나는대로 책을보기도, 코딩을 하기도, 웹 어딘가를 방황하기도 한다.   근데 그냥 보면 재미없으니까   뭘 봤고, 뭐가 문제였고, 무엇을 느꼈는지, 무엇을 잘못했는지   뭐라도 써보자.  ","categories": ["notes"],
        "tags": ["개발일기"],
        "url": "http://localhost:4000/notes/diary-start/",
        "teaser":null},{
        "title": "빌드",
        "excerpt":"2018.8.21 오전 10   현재 작업 중인 프로젝트는 국내 운영쪽 서버와 해외에서 운영되는 서버 2가지 버전으로 빌드해야 한다.   리눅스의 웹로직 서버하에 배포되는데 서버 환경이 다르다보니 properties 쪽에 약간의 차이가 있어 따로 빌드를 한다.   그러던 중 문제가 발생했다.   정적인 이미지 파일의 경우 서버에 별도로 저장하여 관리중인데, 루트 경로가 다르다보니 해외서버에서 이미지 경로를 찾지 못하는 이슈이다.   예를들어, 국내는 /home/weblogic/~ , 해외는 /home/oracle/~   이와 같은 경로에 위치하는데,   &lt;?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?&gt; &lt;weblogic-web-app         xmlns=\"http://www.bea.com/ns/weblogic/90\"         xmlns:j2ee=\"http://java.sun.com/xml/ns/j2ee\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://www.bea.com/ns/weblogic/90 http://www.bea.com/ns/weblogic/90/weblogic-web-app.xsd\"&gt;        &lt;container-descriptor&gt;         &lt;show-archived-real-path-enabled&gt;true&lt;/show-archived-real-path-enabled&gt;     &lt;/container-descriptor&gt;      &lt;virtual-directory-mapping&gt;         &lt;local-path&gt;/home/weblogic/v2_webresource_file/&lt;/local-path&gt;         &lt;url-pattern&gt;/webresource/*&lt;/url-pattern&gt;     &lt;/virtual-directory-mapping&gt;      &lt;context-root&gt;/v2&lt;/context-root&gt;      &lt;!--     &lt;session-descriptor&gt;         &lt;timeout-secs&gt;7200&lt;/timeout-secs&gt;     &lt;/session-descriptor&gt;     --&gt; &lt;/weblogic-web-app&gt;   이 중  부분을 빌드시 프로파일 환경에 따라 동적으로 구분해줄 필요가 있다.   사실 maven의 dependency 같은거야 mvn-repository 에서 가져다 쓴게 대부분이고, 간단한 프로파일 설정 정도만 수정해봤지   이렇게 빌드 환경을 구체적으로 커스터마이징해본적이 없어서 여전히 삽질 중이다.   일단 힌트는   &lt;plugin&gt;                 &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                 &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;                 &lt;configuration&gt;                     &lt;warSourceDirectory&gt;${basedir}/src/main/webapp&lt;/warSourceDirectory&gt;                     &lt;webResources&gt;                         &lt;resource&gt;                             &lt;filtering&gt;true&lt;/filtering&gt;                             &lt;directory&gt;src/main/webapp/WEB-INF&lt;/directory&gt;                             &lt;includes&gt;                                 &lt;include&gt;weblogic.xml&lt;/include&gt;                             &lt;/includes&gt;                         &lt;/resource&gt;                     &lt;/webResources&gt;                     &lt;warSourceDirectory&gt;src/main/webapp/WEB-INF&lt;/warSourceDirectory&gt;                     &lt;webXml&gt;src/main/resources-${environment}/weblogic.xml&lt;/webXml&gt;                 &lt;/configuration&gt;             &lt;/plugin&gt;   이렇게 설정하니까 /resource-{profile}/weblogic.xml 의 파일이 ~wepapp/WEB-INF/web.xml 로 떨궈지는 것을 확인했다.   그렇다면 저 환경을 통해서  /resource-{profile}/weblogic.xml 의 파일이 web-inf 아래 web.xml로 떨궈졌다는 거니까…   일단 weblogic.xml파일을 읽어 들이는거 까지는 됐다면, 저걸 web.xml 파일로 떨굴 것이 아니라,   web-inf/weblogic.xml 파일로만 떨구는 방법을 찾으면되지 않을까     삽질      자바스크립트내 배열을 초기화하는데 단순히 array = []; 로 초기화가 안돼서 Array.clear(), for loop 으로 빈 객체 삽입, index 별 splice 등 별 짓을 다했는데 리스트의 데이터가 지워지질 않았다.   알고보니 데이터 로딩시 다른 함수가 호출되면서 값을 계속 넣어주고 있었던 것이다.   프로그래밍은 거짓말하지 않는다. 내가 사용한 문법이 확실하다고 생각이 들면, 어디서 문제가 났을지 천천히 되짚어 보자. 하나에만 빠져서 삽질만 하지말고      메이븐 빌드시, 빌드환경에 따라 property 파일을 동적으로 사용해야 했다. maven 설정에 대한 삽질을 거듭하며 조금은 그 원리가 이해되었다. 그리고 마침내 얼추 된 것 같다.   &lt;!-- weblogic 환경 파일 복사--&gt; &lt;plugin&gt;         &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;         &lt;executions&gt;             &lt;execution&gt;                 &lt;id&gt;copy-resources&lt;/id&gt;                 &lt;phase&gt;validate&lt;/phase&gt;                 &lt;goals&gt;                     &lt;goal&gt;copy-resources&lt;/goal&gt;                 &lt;/goals&gt;                 &lt;configuration&gt;                     &lt;overwrite&gt;true&lt;/overwrite&gt;                     &lt;outputDirectory&gt;${basedir}/target/${war.filename}/WEB-INF&lt;/outputDirectory&gt;                     &lt;resources&gt;                         &lt;resource&gt;                             &lt;directory&gt;src/main/resources-${environment}/&lt;/directory&gt;                             &lt;filtering&gt;false&lt;/filtering&gt;                             &lt;includes&gt;                                 &lt;include&gt;weblogic.xml&lt;/include&gt;                             &lt;/includes&gt;                         &lt;/resource&gt;                     &lt;/resources&gt;                 &lt;/configuration&gt;             &lt;/execution&gt;         &lt;/executions&gt; &lt;/plugin&gt;   해당 plugin을 배포시 설정하는 프로파일안에 넣어주면 해당 프로파일 빌드시마다 적용된다  ","categories": ["notes"],
        "tags": ["maven","삽질"],
        "url": "http://localhost:4000/notes/build/",
        "teaser":null},{
        "title": "[Design Pattern] Singleton Pattern",
        "excerpt":"[Singleton Pattern]      싱글턴패턴은 이름 그대로 아주 심플하다.   인스턴스를 하나만 생성하여 설계하는 디자인 패턴이다.   그렇다면 왜, 어떤 상황에서 인스턴스를 하나만 생성하는 것이 유용할까?   흔히 connection pool, thread pool, device settings 과 같은 상황에서 싱글턴패턴은 유용하다.   위와 같은 환경에서 인스턴스를 하나만 만들어, 자원의 낭비를 방지하고 엄격하게 관리해야 할 설정들을 하나의 인스턴스로 관리함으로써 효과적인 관리를 할 수 있다.      개발중인 시스템에서 스피커의 볼륨을 제어하는 클래스가 필요하다면?    만약 이런 클래스의 인스턴스를 100개 만들어 관리한다고 가정할때, 우리는 볼륨을 “1” 만큼 올리는데 100개의 모든 클래스를 찾아 볼륨을 올려줘야 한다.   이는 매우 불필요한 복잡도를 야기시키고, 시스템의 리소스만 잡아먹는 비효율적인 작업일 것이다.   그렇다면 이렇게 시스템의 스피커를 관리하는 클래스를 싱글턴패턴을 통해 하나의 인스턴스로 관리해보자.    public class SystemSpeaker {     // SystemSpeaker의 instance 라는 멤버변수는 유일한 값을 유지해야 하기 때문에 static 으로 생성      static private SystemSpeaker instance;     private int volume;      // Singleton 이기 때문에 외부에서 생성하지 못하도록 private 제한     private SystemSpeaker(){         volume = 5;     }      public static SystemSpeaker getInstance() {         // 하나의 인스턴스만 존재해야 하기 때문에 instance에 null을 체크하여 하나의 시스템 스피커 인스턴스만을 생성함         if(instance == null){             instance = new SystemSpeaker();             System.out.println(\"make new instance\");         }else{             System.out.println(\"instance is already made\");         }         return instance;     }      public int getVolume() {         return volume;     }      public void setVolume(int volume) {         this.volume = volume;     } }    위 클래스를 메인함수에서 호출한다면 아래와 같은 결과를 확인할 수 있다.      동일한 메모리 주소를 바라보고 있는 하나의 인스턴스 이므로 당연히 동일한 결과를 확인할 수 있다.     여기까지는 Single Thread 상에선 문제가 되지 않을 것이다.   하지만 Multi Thread 환경에서는   http://asfirstalways.tistory.com/335  ","categories": ["JAVA"],
        "tags": ["Design pattern","Singleton"],
        "url": "http://localhost:4000/java/Design_Pattern_Singleton/",
        "teaser":null},{
        "title": "현위치",
        "excerpt":"2018.8.22   오늘은 코딩보다는 다른 곳에 집중해야 했다.   redmine에 등록된 이슈를 분배해야 했고, 그 과정에서 각 담당자들한테 발생한 이슈를 함께 고민했고   무엇보다 내일 가득 잡힌 면접과 코딩테스트에 긴장 + 걱정 + 혼란함으로 일이 손에 잡히질 않았다.   하루에 5군데의 회사를 방문해야한다.   오전 9시부터 4시간동안 코딩테스트가 진행될 것이고   그 후 대략 1시간에서 2시간 간격으로 4군데의 면접을 진행한다.   사실 한군데만이라도 연락왔으면 했는데, 어쨋거나 나를 불러주는 곳이 있다는 것은 정말 반가운 일이다.   1년 반 전. 처음 신입으로 입사 도전을 했을때 50여군데의 지원서를 냈지만 나에게 돌아온 피드백은 5군데도 되지 않았다.   특히 내가 원하던 스타트업이나, 젊은 회사에선 더더욱 나에게 관심이 없었다.   심지어 나에게 QA를 해보는 것은 어떻겠냐고 제의한 곳은 아직도 잊혀지질 않는다. 그 답변을 받은 후 더 좋은 자극을 받은 것 같다.   연초부터 취업을 준비하는 과정에서 엄마의 갑작스러운 입원으로 참 탈도 많았지만, 그 중 운좋게 지금의 회사와 인연이되어 1년 반동안 나름 성실하게 근무했던 것 같다.   정말 아무것도 모르는 멍청이를 데려다 놓고, 월급을 주며 내가 개발자의 길로 들어왔다는게 잘못되지 않았다는 것을 느끼게 해준 고마운 첫 직장이지만,   그 감사함을 뒤로한채, 새로운 도전을 앞두고 있다.     작년에 지원했을때 전혀 피드백도 없던 곳에서 나에게 면접의 기회가 주어진다는 것 자체가 큰 성과이기도 하다.   참 보잘것없는 스펙이고 아직도 너무나 모르는 주니어개발자이지만, 나의 어떤 모습에 궁금함을 느껴 귀한 시간을 내주는 것이다.   그 귀한 시간과 소중한 기회를 쉽게 놓쳐버리고 싶지는 않다.   좋은 결과를 보고 얼렁뚱땅 회사를 옮길 것은 아니지만, 내 현재의 위치를 확인하고자 중간 점검차원에서 하는 것이라는 스스로의 위안을 삼으려 한다.   아마 내일 이시간쯤이면 거의 멘탈이 소멸되어 넋을 놓고 있을 것이다.   잡설은 그만하고 공부하러가자.  ","categories": ["notes"],
        "tags": ["준비"],
        "url": "http://localhost:4000/notes/find-myself/",
        "teaser":null},{
        "title": "도전",
        "excerpt":"2018.8.23   이게 하루에 다 있었던 일인가 믿기지 않을 정도로 너무나 정신 없이 흘러간 하루다.   오늘의 일정은 이러했다.      오전 4시간 코딩 테스트   2시 면접   4시 면접   6시 면접   7시 면접   생각을 잘못했다.   면접 보는 곳의 위치가 비슷비슷해서 차를 갖고가는게 유리할 것이란 생각을 했다. 면접 후 이동하는 것도 그렇고 일찍 끝나면 차에서 좀 쉴 수 있으니까.   하지만 오늘 일정은 내 생각처럼 그리 순탄치 않았다.   오전 9시까지 코딩 테스트를 참석해야하는데, 차를 주차하고 나오니까 8시 40분이었다. 최소 10분전에는 가야지 하는 마음에 서둘러 간 덕분에 늦지 않게 도착했고   코딩 테스트를 볼 수 있었다.   4시간, 5문제. 그리고 인터넷 사용금치. 내 뒤에는 감독관이 지켜보고 있다.   이런 환경 자체가 처음이었고, 당황스러웠다. 물론 구글링을 할 정도의 난해한 내용은 아니었지만(그럼에도 모든 문제를 풀지 못했다.)   항상 구글에 의지하며 코딩하는 습관때문인지 검색을 할 수 없다는 것에 당황했고,   무엇보다 내 뒤에 누군가 내가 코딩하는 것을 보고 있다는 것은 정말 숨이 막혀왔다!   주어진 문제를 다 풀지도 못했고, 여전히 알고리즘에 취약한 내 모습을 보며 확실히 부족한 나의 모습.   몇 주전 내가 가장 희망하던 곳의 온라인테스트를 했을때 문제를 제대로 풀지 못한것이 떠오르면서 1년이 지난 지금도 내 알고리즘 실력은 별로 발전이 없었다는 것에 큰 위기감을 느끼며 오전 테스트를 마쳤다.   서둘러 나와서 2시 면접 장소로 이동했다. 서초구라고 해서 조금 인적이 드문 장소인 줄 알았는데 강남역 사거리 근방이었던 것이다.   아 강남역이 서초구지…   여기 부랴부랴 아주 어렵게 주차를 마치고 서둘러 면접장으로 향했다.   다행히 10분전에 입장을 했고, 면접 담당자에게 연락을 했는데 20분 정도 늦을것 같다고 한다.   어차피 면접 준비도 부족했는데 공부나 하고 있어야지 하는 생각으로 그 회사 탕비실에 앉아 열심히 서칭을 하고 있었다   그런데 시간이 40분이 지났다. 그리고 50분.   다음 면접이 4시까지 입장이고 여기서 30분정도 걸리니까 적어도 3시에는 움직여야 차를 빼고, 주차하고, 이동하는 시간까지 맞을 것 같다.   2시 면접에 2시 55분까지 기다렸지만, 처음 들어와서 20분 늦을거라는 말 이후로 그 어떤 연락도 오지 않았고,   한시간여를 기다린 후 다음 면접일정때문에 들어가보겠다는 문자를 남겼지만 답장 조차 오지 않았다.   아까는 너무 바쁘고 정신이 없어 미처 생각하지 못했는데 지금 생각해보면 정말 분하다.   그 곳에 가기 위해서 애썼던 것과 휴가를 내서 그 자리를 참석했는데, 담당자는 어떤 연락도 오지 않았다.   상식적으로 약속된 면접이 진행이 안되면 최소한 ‘죄송하다’ 또는 ‘다음에 기회가 되면 다시 하자’ 정도의 인삿말 정도는 해야하는게 도리가 아닌가.   너무 괘씸해서 그 회사명을 언급하고 싶지만 똑같은 사람이 될 것 같아 참아야 한다.     그리고 이어서 4시와 6시 면접은 모두 정상적으로 진행했다.   결론적으로 매우 나에게 필요한 시간이었다. 면접이라는 압박감 덕분에 다시 한 번 이론적인, 원론적인 내가 놓치고 있던 부분을 다시 살필 수 있었고   1년 또는 주니어 개발자에게 회사에서 요구하는 기본 실력과 개념. 내가 무엇을 놓치고 있는지 깨달을 수 있던 시간이다.   특히 4시에 진행한 면접은 너무나 인상적인 자리었는데, 마지막 면접관님과 단순히 면접관과 면접자 입장이 아닌, 개발자 선배와 후배의 입장으로   내가 앞으로 어떤 방향으로 공부할지, 젊은 개발자들이 간과하고 있는. 소중한 정보를 많이 구할 수 있었다.     마지막으로 오늘 면접에서 받았던 질문들을 다시 곱씹으며 개념을 쌓아야겠다.      무작위로 나열된 수를 정렬할 수 있는 알고리즘을 설명하시오   이진 트리는 무엇인가요   ‘SPRING’ 이라는 글자를 거꾸로(‘GNIRPS’) 출력하려면 어떻게 할까요   in-order / post-order / pre-order 의 개념을 아시나요? pre-order를 in-order로 표현하는 방법은 무엇인가요? (hint : stack)   spring framework 에서 어떤 모듈을 사용해 보셨나요?   DB에서 DML, DDL, DCL 의 개념        DB에서 index는 무엇인가요       자바에서의 this 와 자바스크립트에서의 this를 설명해주세요   커피숍이라는 클래스를 설계해보세요     위에 질문 묶음은 사실 교과서 적인, 그리고 기본적으로 알아야할 개념들이었다.   부끄럽게도 꽤 많은 것들에 좋은 대답을 하지 못한게 너무나 마음에 걸리지만, 무엇보다 ‘커피숍 클래스 설계’에 대한 질문은 지금까지도 그 충격이 남아있다.   문득 빈 종이와 펜을 주며 커피숍 클래스를 설계하라고 했다.   나는 단순히 이 질문을 역할에 따른 객체의 분리 정도로만 생각을 했다.   물론 역할에 따른 분리가 그 모든 구체적인 것을 포함하겠지만 내가 그려낸 것은 그저 ‘손님객체’, ‘직원객체’, ‘메뉴객체’, ‘매장객체’ 등 으로 나누어 어설픈 UML다이어그램을 그려보였다.   그리고 그 클래스 안에 기본적으로 어떤 메서드를 구현할 것인지 간단히 적어 넣었다.   그러자 질문이 들어왔다.   “메뉴라는 클래스를 조금 더 세부적으로 표현해볼 수 있나요?”   질문의 의도를 파악하려 애썼지만, 나는 그저 메뉴를 커피/빵/쥬스 그리고 제조 방법 등 기능을 분리하는 것만 떠올랐고 썩 괜찮은 대답을 못했다.   내가 어려워하자, 정답은 없는 질문이라고 편하게 생각하라고 시간을 충분히 줬지만 만족할 만한 답을 내지 못했다.   그리고 조심스럽게 질문의 의도를 설명해줬다.   예를들어 이런 것이다.   메뉴를 구체화 하다보면 커피안에 여러가지 커피의 종류가 있기 때문에 이것은 템플릿 메서드 디자인 패턴을 통해 구현 가능할 것이고,   커피에 샷을 추가할지, 시럽을 추가할지 등 옵션이 계속 붙는 것은 데코레이터패턴으로 구현이 가능할 것이고   전체적인 구조는 어떻게 가져갈 것이며, DB 스키마는 어떻게 정리하는 것이 좋을 것이고 등등..   처음 듣는 얘기가 아니다. 내가 면접 직전에 보았던 빌더패턴으로 메뉴에 포함되는 매개변수들을 나여할 수도 있는것이다.   내 머리가 트이는 질문을 받고 꽤 큰 충격에 아직도 어안이 벙벙하다.     많은 면접은 진행하지 못했지만 무엇이 부족한지, 내 위치가 어디에 있는지 충분히 느낄 수 있었다.   새로운 기술, 그럴싸해보이는 것들은 그만 좇고 본질을 다시 돌아가자.   기본부터..  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/challenge/",
        "teaser":null},{
        "title": "Life Cycle(...?)",
        "excerpt":"2018.8.24   구성은 이러했다.   A라는 컴포넌트가 있다.      A컴포넌트에서 생성한 모달창에서 save가 성공적으로 이루어지면, B라는 컴포넌트의 화면으로 전환되며, 해당 컴포넌트에 속한 dataLoad 함수를 호출하는 것이다.    머릿속에 그려지는대로, A 컴포넌트의 save 이벤트가 성공하면 router를 통해 B컴포넌트로 이동했고, B컴포넌트의 메서드를 호출해야하기 때문에 EventBus를 태웠다.   정확한 소스는 기억나지 않지만 대략 이런식이다       // A component     EventBus.$emit(\"data-load\");       // B component     mounted (){         EventBus.$on(\"data-load\", function() {             this.dataLoad();         });     }   대략 이런 방법으로 이벤트를 발생시켰는데 여기에는 많은 문제가 있다.   내가 이해한 것이 정확한것인지 모르겠지만   A에서 보낸 EventBus가 B에 도착할때, 과연 B 컴포넌트의 인스턴스는 완전히 생성이 된 후 실행되는 것인가?   우선 위와 같이 메서드에 접근하면 실행이 되지 않는다.   EventBus를 통해 접근하는 dataLoad라는 메서드는 this로 접근할 수 없다.   임시 변수로 this를 받아서 접근하면 가능하다.       mounted (){         var temp = this;         EventBus.$on(\"data-load\", function() {             this.$nextTick(function () {                 temp.dataLoad();             )}         });     }   접근을 굳이하자면 위와같이 접근이 가능한 것으로 보인다.   nextTick을 통해 화면이 랜더링된 후 메서드를 접근했는데, 중요한건 dataLoad()라는 함수를 호출한다고 끝나는 것이 아니다.   그 안에 바인딩되는 데어터들도 모두 B컴포넌트에 직접 접근해야했는데(this) 위와 같이 접근해서 결과를 반환한다고 해도 B컴포넌트의 데이터셋에 바인딩되지 않았다.   EventBus를 통해 보내는 시점에 내가 접근하고자 하는 B component의 인스턴스가 생성되지 못한 상태인 것으로 보인다.   사실 지금 이시점에도 이렇게 접근하는 것이 정확히 왜 잘못됐는지 이해되지 않는다.   하지만 안되는것을 계속 붙잡고 있을 수 없었고 다른 방법을 고민하던 끝에 처음했던 별로 훌륭해보이지 않는(?) 방식으로 해결했다.     이벤트 버스를 보내는 것이 아니라, $Router를 통해 이동할때 parameter를 함께 전달하여 해당 문자가 있을때 내가 호출하고자 하는 메서드를 호출 한다.   기본 URI가 ‘/move-component’ 라면      this.$router.push(‘/move-component/dataLoad’) –&gt; ‘dataLoad’라는 문자를 넘겨주며 B 컴포넌트 이동   B컴포넌트에서 mounted()시 라우팅 props 값 확인 ( if(this.value == ‘dataLoad){} )   가장 심플하고 쉬운 방법이다.   단순히 이벤트를 호출한다는 생각에 빠져 이벤트버스를 태우겠다는 집념으로 3시간여를 삽질을 하다가 결국 10분도 안돼서 저 방법으로 해결되었다.   삽질해보는건 좋은데, 뭘 모르는지 꼭 점검하자      vue.js Life cycle   this   rendering   ","categories": ["notes"],
        "tags": ["vue.js"],
        "url": "http://localhost:4000/notes/vuejs/",
        "teaser":null},{
        "title": "Java Virtual Machine",
        "excerpt":"[Java Virtual Machine]   JAVA를 주력으로 하는 개발자가 JVM을 제대로 알지 못하고 있다.   순서가 잘못된 감이 있지만, 자바를 공부하는데 JVM에 대한 내용을 다루지 않았다. 라고 하지만 솔직히 지금까지 개발하면서 JVM의 메모리까지 고려해가며 설계 또는 코딩할 생각조차 하지 못했다.   하지만 알고 안하는것과 몰라서 못하는 것은 다른 이야기다.   거두절미하고 JVM에 대해서 살펴보자.      그림과 같이 우리가 코딩하는 java 소스코드의 문자를 컴퓨터가 바로 인식할 수 없다.   흔히 말하는 ‘컴파일’ 과정을 거쳐 컴퓨터가 인식시키는 과정이 필요한데,   Java compiler는 이런 .java 파일을 .class 라는 byte code 로 컴파일 한다.   그리고 최종적으로 이 바이트코드들은 JVM을 통해서 OS상에서 실행(인식)된다.   이것이 자바의 슬로건처럼 사용되는 “Write Once, Run Everywhere” 이다. (JVM만 있다면 OS환경에 상관없이 어디서든 작동한다는 의미이다.)      하지만 이 과정에서 문제가 발생하는데, 코드 컴파일 이후 다시 기계어로 변환하는 작업의 비용이 많이 든다는 것이다. 이런 단점을 극복하기 위해 JIT(Just In Time) 방식이 나왔다. 이 내용은 차차 알아보도록 하자.    다시 정리하면 자바의 실행과정은  - 자바 프로그램 실행시 JVM 은 OS로 부터 메모리를 할당 받음. (JVM은 용도에 따라 영역이 분리됨) - 자바 컴파일러(javac)는 자바 소스코드(.java)를 컴파일하여 바이트코드(.class)로 변환 - Class Loader를 통해 class파일들을 JVM에 로딩 - 로딩된 class 파일은 Execution engine을 통해 해석 - 해석된 바이트코드들은 Runtime Data Areas를 통해 수행      출처 : http://egloos.zum.com/newkong/v/4096029     Class Loader  RunTime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 됩니다.   다시 말해 컴파일된 .class 파일을 로드하고, 링크를 통해서 배치 작업을 수행한다. jar파일내에 저장된 클래스들은 JVM위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제한다.(Garbage Collect)   자바는 동적으로 컴파일되는 것이 아닌, 런타임에 참조하기 때문에 클래스를 처음 참조(로딩)할 때 해당 클래스를 로딩하고 참조하는 것이다.   Execution Engine  로드된 클래스의 바이트 코들를 실행하는 런타임 모듈이다.  자바 바이트 코드는 기계가 바로 인식할 수 없는 상태이기 때문에 JVM 내부에서 기계가 인식하여 실행할 수 있도록 다시 변경이 이루어져야 한다. 여기서 위에 언급한 JIT(Just-In-Time) 방식과 Interpreter 방식이 진행된다.   #### Interpreter     인터프리터 언어와 같은 방식으로, 자바 바이트 코드를 명령어 단위(한 줄씩)수행한다.     떄문에 속도가 느리다는 단점이 있다. 이를 보완하기 위하여 JIT 컴파일 방식이 도입되었다.      #### Just-in-time     JIT 방식은 실행 시점에 자주 쓸만한 코드들을 기계어로 변환 시켜놓고 저장해 뒀다가, 재사용 할 때 이미 변환된 기계어 코드를 재 사용 하는 방식을 말한다.      물론 이 과정을 하기 위해 초반에 메모리를 잡아두거나 하는 선행 작업들이 있어서 초기 실행 속도는 다소 느릴 수도 있다.      하지만 그 이후로는 ByteCode를 사용 할 때마다 네이티브 코드로 변환하는 작업이 들어 실행속도가 많이 향상된다.      코드가 재사용될 일이 없거나 규모가 작은 프로그램에서는 배 보다 배꼽이 더 클 수도 있지만 일반적으로 빠른 속도를 자랑한다.   Runtime Data Area         Method (Static) Area:            JVM이 읽어들인 클래스와 인터페이스 대한 런타임 상수 풀, 멤버 변수(필드), 클래스 변수(Static 변수), 생성자와 메소드를 저장하는 공간           Runtime Constant Pool            메소드 영역에 포함되지만 독자적 중요성이 있다.       클래스 파일 constant_pool 테이블에 해당하는 영역이다.       클래스와 인터페이스 상수, 메소드와 필드에 대한 모든 레퍼런스를 저장한다.       JVM은 런타임 상수 풀을 통해 해당 메소드나 필드의 실제 메모리 상 주소를 찾아 참조한다           메소드 영역/런타임 상수 풀의 사용기간 및 스레드 공유 범위            JVM 시작시 생성       프로그램 종료 시까지       명시적으로 null 선언 시       구성 방식이나 GC 방법은 JVM 벤더마다 다를 수 있다.       모든 스레드에서 공유           Heap Area            JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용하는 영역이다.       New 연산자로 생성된 객체 또는 객체(인스턴스)와 배열을 저장한다.       힙 영역에 생성된 객체와 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.       참조하는 변수나 필드가 없다면 의미 없는 객체가 되어 GC의 대상이 된다.       힙 영역의 사용기간 및 스레드 공유 범위                    객체가 더 이상 사용되지 않거나 명시적으로 null 선언 시           GC(Garbage Collection) 대상           구성 방식이나 GC 방법은 JVM 벤더마다 다를 수 있다.           모든 스레드에서 공유한다.                           Stack Area            각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다.       메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다.       선입후출(FILO, First In Last Out) 구조로 push와 pop 기능 사용       메소드 호출 시 생성되는 스레드 수행정보를 기록하는 Frame을 저장       메소드 정보, 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장       기본(원시)타입 변수는 스택 영역에 직접 값을 가진다.       참조타임 변수는 힙 영역이나 메소드 영역의 객체 주소를 가진다.           PC Register            현재 수행 중인 JVM 명령 주소를 갖는다.       프로그램 실행은 CPU에서 인스트럭션(Instruction)을 수행.       CPU는 인스트럭션을 수행하는 동안 필요한 정보를 CPU 내 기억장치인 레지스터에 저장한다.       연산 결곽값을 메모리에 전달하기 전 저장하는 CPU 내의 기억장치           Native Method Stack Area            자바 외 언어로 작성된 네이티브 코드를 위한 Stack이다.       즉, JNI(Java Native Interface)를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택이다.       네이티브 메소드의 매개변수, 지역변수 등을 바이트 코드로 저장한다.           출처: http://hoonmaro.tistory.com/19 [훈마로의 보물창고]     [참고]     https://medium.com/@lazysoul/jvm-%EC%9D%B4%EB%9E%80-c142b01571f2   http://asfirstalways.tistory.com/158   https://namu.wiki/w/Java%20Virtual%20Machine   http://hoonmaro.tistory.com/19  ","categories": ["JAVA"],
        "tags": ["JVM"],
        "url": "http://localhost:4000/java/JVM/",
        "teaser":null},{
        "title": "element...?",
        "excerpt":"오늘의 삽질   A component 안에 A-1 이라는 component를 import 하여 사용중이다.   대략적으로 아래와 같은 구조이다.    &lt;template&gt;     &lt;div&gt;     &lt;button @click=\"nextPage()\"/&gt;     &lt;tiny-slider ref=\"slider\"/&gt;     &lt;/div&gt; &lt;/template&gt;    “template” 는 현재 주 Component이며, “tiny-sldier” 라는 외부 Component를 import 한 형태이다.   이 상황에서 tiny-slider의 이벤트를 발생시키기 위해서는  this.$refs.slider.goTo(); 와 같이 실행한다.   실제로 tiny-slider의 goTo 메서드는 슬라이더 내의 페이징처리를 해주는 역할을 한다.   내가 할 일은 이제 저 페이지가 현재 몇페이지인지만 찍어주면되는 아주 간단한 작업이다.   그래서 다음과 같이 구현했다.    &lt;template&gt;     &lt;div&gt;     &lt;button @click=\"nextPage()\"/&gt;     &lt;p&gt;  /  &lt;/p&gt;     &lt;tiny-slider ref=\"slider\"/&gt;     &lt;/div&gt; &lt;/template&gt;   &lt;sciprt&gt; // Vue 선언부 data : {     currentPage : 1,     totalPage : '' }  method : {     nextPage(){         if(this.currentPage &lt; this.totalPage){             this.currentPage += 1;         }          this.$refs.slider.goTo();     } }  &lt;/script&gt;   현재 페이지가 전체페이지보다 작을때 페이지의 값을 +1 해주는 아주 단순한 함수이다.   그런데… nextPage() 함수를 호출되며 currentPage의 값이 1씩 계속 증가하지만 tiny-slider의 페이지는 넘어가지 않고 제자리에서 돌기만 한다. 그리고 currentPage &gt; totalPage 상태가 되어서야 tiny-slider의 페이징이 이루어 진다.   다시 말해 if문을 통해 this.currentPage 변수에 변화가 일어나지 않을때, 그제서야 화면이 슬라이드된다.   오전에 계속 문제를 해결하지 못했고, 과장님이 담배를 태우러 나가실때 따라나가 여쭤봤다.   늘상 말씀하시듯, ‘잘해봐… 잘생각해봐…’ 라는 짧은 대답과 함께 엘리먼트가 생성이 제대로 됐는지 확인해보라고 하신다.   엘리먼트가 생성이 안됐다…? 버튼 엘리먼트가 생성이 안되었던 것일까   왜 현재의 컴포넌트에서 이벤트가 일어날때 참조된 컴포넌트의 이벤트가 작동되지 않는것일까   이것말고도 오늘은 webpack 빌드시 less파일을 compile하는 이슈도 있었지만 이것 역시 해결하지 못했다.   오늘은 아주 찜찜한 퇴근을 했다.   심지어 키보드에 커피를 쏟아서 고장난 상태이다.   어제부터 계속해서 비가 내리고, 핸드폰에선 비를 조심하라는 재난문자가 폭주한다.   내 마음에도 비가 내리는 적적한 하루다.  ","categories": ["notes"],
        "tags": ["vue.js"],
        "url": "http://localhost:4000/notes/vue-js_2/",
        "teaser":null},{
        "title": "Component의 힘",
        "excerpt":"오늘의 메인작업은 전체 검색필터의 수정이었다.   1차 프로젝트가 거의 막바지에 왔을때, 페이지마다 별도의 필드를 갖고있는 검색 필터를 구현해달라는 요청이 있었다.   ‘필요한 화면이 10개는 족히 넘을텐데 이제와서 이걸 만들어 달라니…’ 혀를 차며 두 손, 두 발 다 들어야할 지경이었다.   하지만 또 안하고 버틸 수 없는 노릇이니 방안을 구색하던 중, 검색필터의 조건이 화면별로 다르지만 그 중 공통되는 영역이 있었다.   그러면 이 공통되는 영역과 기본 틀을 갖고 있는 컴포넌트를 하나 만들어 놓고, 필요한 곳에 이 컴포넌트를 가져다가 필요한 필드만 추가해서 사용하도록 구현했다.   컴포넌트 이것이 vue.js를 쓰며 체감했던 강력한 장점 중 하나이다.  일반적인 jsp 방식으로 했다면, 많은 중복된코드와 각 화면별로 지저분한 코드를 양상하며 많은 시간을 투자하여 개발했을 것이다.   Vue.js를 통해 서비스별로 컴포넌트를 분리하여 필요한 곳에 알맞게 붙여 사용한다.   물론 jsp에서 include를 하거나 moudle화 하여 사용할 수 있겠지만, Vue.js와 같은 front-end framework 들은 이러한 작업의 수고를 덜어주고 코드 관리가 용이하다.     과거 그렇게 컴포넌트화 하여 구현했던 검색필터에 수정 작업이었다.   필터에 새로운 필드가 추가되었고, 다중 선택이 가능한 조건임에도 기존에 ‘=’ 쿼리로 되어 있는 것을 ‘IN’쿼리로 변경했다. 그리고 중간에 저장이 안되는 필드도 존재했다.   이처럼 버그가 산발적으로 일어나는 상황이지만, 결국 하나의 컴포넌트만 처리하여 모든 문제가 말끔히 해결되었다.   혹시 모를 예외상황을 위해서 이 컴포넌트가 적용된 상위 컴포넌트에 테스트가 필요하겠지만, 꽤 오랜 작업이 될 수 있는 것을 수 시간만에 해결했다.   ","categories": ["notes"],
        "tags": ["vue.js","components"],
        "url": "http://localhost:4000/notes/component/",
        "teaser":null},{
        "title": "읽기 좋은 코드가 좋은 코드다(The Art of Readable Code)",
        "excerpt":"읽기 좋은 코드가 좋은 코드다(The Art of Readable Code)   우리가 매일같이 쓰는 코딩 습관, 큰 의미 없이 선언하던 변수, 큰 고민을 하지 않고 양산하는 코드, 테스트 코드 등   책 전반에 걸쳐 효율적이고 생산적인 코딩습관, 그리고 동료와 함께할 수 있는 의미있는 코드를 작성하는 방법에 대하여 새심하게 기술되어 있다.   워낙 알짜배기 책이라 각 파트별 내용을 간추리고 싶지만, 그건 리뷰라기 보다는 그냥 책 요약본일 것이다.   전체적으로 버릴 내용이 없는 책이었지만, 그 중 특히 감명깊은 부분을 표기해두었는데, 그 부분에서 간략히 기록하려한다.      함수의 동작을 명확하게 설명하라       //이 파일에 담긴 줄 수를 반환한다.     int CountLines(Stirng fileName){         ...     }   위 주석은 명확하지 않다. ‘줄’을 정의하는 방법이 여러가지 있을 수 있기 때문이다.     - (빈 파일)은 줄 수가 0인가? 1인가?     - “hello”는 줄 수가 0인가? 1인가?     - “hello\\n” 는 줄 수가 1인가 2인가?   등등 주석 또는 메서드명만 봐서는 정확한 명세를 확인하기 힘들다.       //파일 안에 새 줄을 나타내는 바이트('\\n')가 몇 개 있는지 센다.     int CountLines(String fileName){         ...     }   이 전 주석보다 긴 내용은 아니지만, 훨씬 명확한 설명을 해주는 주석이다.     의미 없는 주석, 형식적인 주석 다는 것을 피하기 위해서 나름 주석을 신경써서 작성하려고 노력했지만, 내가 썼던 주석 수준은 위와 같이 간단하고 추상적인 내용뿐이었다.   구체적으로 구구절절 나열하는 것이 아닌, 코드에 필요한 핵심 기능만 표현할 수 있는 주석으로 조금 더 신경써서 주석을 달아야겠다.      드모르간 법칙 사용하기 동일한 boolean 표현은 다음과 같이 두 가지 방법으로 작성 가능하다.      1) not (a or b or c) &lt;-&gt; (not a) and (not b) and (not c) 2) not (a and b and c) &lt;-&gt; (not a) or (not b) or (not c)    이러한 법칙은 “not을 분배하고 and/or를 바꿔라” 만을 기억하면 된다.       if(!(file_exists || is_protected)){         Error(\"Error, cant not read files\");     }   위 내용은 다음과 같이 수정 가능하다.       if(!file_exists || is_protected){         Error(\"Error, cant not read files\");     }   드모르간 법칙은 생소하게 들리지만, 사실 이런 연산은 아주아주 어렴풋이 기억 한 곳에 남아있는 집합 내용에서 떠올릴 수 있다.   위와 같은 연산을 통해 복잡한 분기를 피하고 최대한 깔끔한 연산을 적용하는 것을 잊지 말자.        생각을 코드로 만들기      “할머니에게 설명할 수 없다면 당신은 제대로 이해한 게 아닙니다.” \\n -알버트 아인슈타인    코드를 명확하게 만드는 간단한 과정     코드가 할 일을 옆의 동료하게 말하듯이 평범한 영어로 묘소하라.   이 설명에 들어가는 핵심적인 단어와 문구를 포착하라.   설명과 부합하는 코드를 작성하라.        var is_admin = is_admin_request(); //true/false     if(document){         if(!is_admin &amp;&amp; is_user('userName') != is_user_session('userName')){             return not_authorized();         }     }else{         if(!is_admin){             return not_authorized();         }     }      // 계속해서 페이지를 렌더링...   위 코드를 살펴보면, 사용이 허가되는 방법은 두 경우이다.     관리자 일 때   만약 문서가 있다면, 유저가 세션의 유저와 같을때   위 경우 가아니면 허가되지 않는다.   위의 논리로 새로운 코드를 작성해보면 다음과 같다.       if(is_admin_reuqest()){         //허가     }else if(document &amp;&amp; is_user('userName') == is_user_session('userName'){         //허가     }else{         return not_authorized();     }      // 계속해서 페이지를 렌더링...   논리대로 정리하면 보다 직관적이고 명확하다. 무엇보다 부정문이 없어서 논리를 파악하기도 좋다.   이 장에서 두가지 큰 깨달음     할머니에게 설명할 수 없다면 제대로 이해하지 못한 것이다.   대화하듯이 논리의 흐름을 정리하고, 이를 단순하고 명료한 코드로 작성하는 것   생각이 복잡하고 정리가 되지 않으면, 그 소스코드 역시 파악하기 어렵고 설득력이 떨어진다.   최근 프로젝트에서 전체적인 비즈니스로직이 이해되지 않는 상황에서 급하게 소스를 작성하며 이런 경험이 있었다.   급한 마음에 일단 눈에 보이는 기능만 작동하도록 코드를 구현한 것이다.   이 코드는 당연히 일주일도 지나지 않아 문제가 발생했고, 꽤 복잡한 로직을 담고 있는 이 기능은 전체적으로 소스를 관리하기도 힘들어져서 결국 모든 내용을 지우고 처음부터 작성하는 것이 나을 것이라 판단되어 2~3일에 걸쳐 다시 작성했던 기억이 난다.      전체 로직을 제대로 이해하지 못했고   내가 이해되지 못했기 때문에 논리의 흐름이 정리될 수 없었고, 지저분하고 복잡한 코드를 낳았다.   세상 모든 일이 그러할 것이다.   무슨 일을 하더라도 내가 이것을 ‘왜’ 해야 하고, ‘무엇을’, ‘어떻게’할 것인지 흐름을 파악해야 한다.        코드 분량 줄이기      가장 일긱 쉬운 코드는 아무것도 없는 코드다.    자기 주변에 있는 라이브러리에 친숙해져라. 이미 대부분의 프로그래밍 언어에서 기본적으로 많은 라이브러리를 제공해준다.   우리는 이미 존재하는 라이브러리를 통해 자신의 문제를 쉽게 해결할 수 있다는 사실을 간과하고 있다.      매일 15분씩 자신의 표준 라이브러리에 있는 모든 함수/모듈/형 들의 이름을 읽어라. *   여기에는 C++의 표준 템플릿 라이브러리(STL), 자바 API 등 모두 포함된다.   전체를 암기할 것이 아니라, 대략적으로 그것들을 파악해 두고 “아! 이런 기능을 하는 API를 봤던 것 같은데!?” 와 같은 훈련이 되어 있다면 우리의 생산력이 보다 나아질 것이다.   Collection Framework를 사용하며 contains 라는 함수를 모르고 있었다.   예를들어 ArrayList 객체안에 내가 찾는 값이 있는지 여부를 찾기 위해서 아래와 같이 검증이 필요했다.       ArrayList&lt;String&gt; arr = new ArrayList&lt;&gt;();     arr.add(\"betterFLY\");     arr.add(\"chungil\");      boolean flag = false;     for(String temp : arr){         if(temp==\"betterFLY\"){             flag = true;         }     }   배열 전체를 검사해서 내가 원하는 값이 있을때 작업을 수행한다.   이 코드는 다음과 같이 간결하게 검증할 수 있다.       if(arr.contains(\"betterFLY\")){         flag = true;     }   전체를 살필 필요 없이 contains 라는 메서드를 통해 아주 간단하게 검증할 수 있다!   이 뿐만 아니라, 우리가 일상적으로 고민하는 많은 것들 중 많은 것들이 이미 잘 정리되어 있다.   물론 그런 과정을 직접 구현하면서 생각하는 훈련을 하는 것도 좋지만, 이미 아주 쉽고 직관적으로 정리되어 있는것을 직접 구현할 만큼 우리는 한가롭지 않다.        좋은 테스트 입력값의 선택   올 초 나에게 가장 혼란과 큰 숙제를 남겨준 것 중 하나가 TDD(Test-Driven Development) 이다.   지금도 해결되지 않은, 앞으로 내가 더 성숙한(?) 개발자가 되어가며 풀어갈 숙제인데, 그 테스트와 관련된 내용이다.   테스트에 알맞은 입력값을 선택하는 기술이 있다.      checkScoreBeforeAfter(\"-5, 1, 4, -99998.43, 3\", \"3334.231, 785\");      가능하면 가장 간단한 입력으로 코드를 완전히 검사할 수 있어야 한다.    위 예제의 값들을 보면 -99998.43, -3334.231, 785 와 같은 ‘시끄러운 값’이 있다. 이 수 들은 단지 ‘임의의 음수’ 또는 ‘매우 큰 음수’ 또는 ‘실수’ 를 표현 하는 것으로 보인다. 음수가 필요하다면 간단한 음수 (‘-9’), 매우 큰 음수가 필요하다면 ‘-1e100’ 과 같이 의미가 뚜렷하고 직관적으로 표현하기 쉬운 수를 선택하는 것이 좋다.   테스트의 정확한 수치는 크게 중요하지 않다.(모든 경우가 그렇진 않겠지만)   자료형 별로 연산을 확인하기 위해서라면 최대한 간단한 수 또는 직관적으로 표현하기 좋은 수를 사용하는 것이 결과를 확인하는 것에도, 테스트를 진행하는 것에도 용이하다.     막상 정리하고 나니 많이 아쉬움이 남는다.   첫 리뷰이기도 하고, 책 내용에 버릴 것이 없어 모든 내용을 기록하고 싶지만   이번에 읽었을때는 이 부분이 눈에 띄었는데, 다음에 다시 읽으니 그때 몰랐던 부분이 다시 보여서 다시 체크한다면   내 자신을 리팩토링 혹은 디버깅하는 좋은 계기가 될 것이다.   읽은 책 중에 리뷰하고 싶은 책들이 너무 많다.   한번 읽고 흘려버리기에 너무나 아까운 내용들이고, 내 안 좋은 머리에 담을 수도 없어 너무 아깝다.   기록하고 상기시켜서 내 것으로 만들어야겠다.  ","categories": ["REVIEW"],
        "tags": ["읽기 좋은 코드가 좋은 코드다"],
        "url": "http://localhost:4000/review/TheArtOfReadableCode/",
        "teaser":null},{
        "title": "slash & back slash",
        "excerpt":"새로운 삽질을 했다.   작업 내역은 Log4j를 통해 기록하는 로그들의 로그레벨을 변경하고(DEBUG -&gt; INFO) 해당 로그파일을 롤링하는 작업이다.   워낙 가이드가 많기 때문에 설정에는 큰 어려움이 없다.   로컬 개발환경은 윈도우니까 내 환경에 맞는 로컬 경로를 설정하면 될것이고, 배포될 웹로직 서버는 리눅스니까 해당 경로만 잡아주면된다.   파일 롤링은      log4j.appender.logfile=com.wily.org.apache.log4j.DailyRollingFileAppender log4j.appender.logfile.DatePattern=’.’yyyy-MM-dd    위 설정과 필요에 따른 설정값을 세팅해주면되는데,      &lt;appender name=\"dailyLog\" class=\"org.apache.log4j.DailyRollingFileAppender\"&gt;         &lt;param name=\"Append\" value=\"true\"/&gt;         &lt;!--&lt;param name=\"ImmediateFlush\" value=\"true\"/&gt;--&gt;         &lt;param name=\"Threshold\" value=\"INFO\"/&gt;         &lt;param name=\"File\" value=\"D:\\logs\\dailyLog.log\"/&gt;         &lt;param name=\"DatePattern\" value=\"'.'yyyy-MM-dd\"/&gt;         &lt;param name=\"MaxFileSize\" value=\"1MB\"/&gt;         &lt;param name=\"MaxBackupIndex\" value=\"1\"/&gt;         &lt;layout class=\"org.apache.log4j.PatternLayout\"&gt;             &lt;param name=\"ConversionPattern\" value=\"%d{HHmmss.SSS} [%-5p] %c{1}.%M():%L %m%n\"/&gt;         &lt;/layout&gt;     &lt;/appender&gt;   대략 위와 같이 설정을 했다.   그런데 아무리 해봐도 파일 생성이 안되는 것이다.   설정값이 잘못되었나 싶어서 구글링해서 나오는 거의 모든 서로 다른 설정은 다 적용해본 것 같다.   문제의 근본적인 원인을 모르니 계속 삽질은 거듭되었다. 몇시간동안 그렇게 사투끝에 다시 한 번 자세히 들여다 보았다.   혹시나 싶었다.       &lt;param name=\"File\" value=\"D:\\logs\\dailyLog.log\"/&gt;   위 경로설정을 아래와 같이 바꾸어 주었다.       &lt;param name=\"File\" value=\"D:/logs/dailyLog.log\"/&gt;   기존에 왜… 굳이 왜 역슬러쉬를 사용했는지 모르겠다. 역슬러쉬를 써야 컴파일하면서 슬러쉬로 인식된다는 이상한 착각에 빠져있던 것 같다.     역슬러쉬의 문제였다.   늘 그렇듯 이런 삽질끝에는 큰 자괴감이라는 쓰나미가 몰려온다.   그래서 조사했다. 역슬러쉬와 슬러쉬의 차이점을…   이건 포스팅 자료에 등록해야겠다…   ","categories": ["notes"],
        "tags": ["log4j","path"],
        "url": "http://localhost:4000/notes/1809_1/",
        "teaser":null},{
        "title": "Slash & Back Slash",
        "excerpt":"##Slash &amp; Back Slash   평소 당연히 그렇게 사용해왔는데, 왜 그렇게 사용했는지에 대해선 생각해보지 않았던 것 같다.   특히 정규식을 사용할때 거의 필수적으로 사용했던 역슬래쉬(\\) 에 대한 내용이다.   지난일기 이전에 이미 크게 삽질을 한 후 스스로의 무지함에 놀라며 기록을 남겨야겠단 생각을 했다.     아주 기본적으로 우리는 개행문자를 파싱할때 다음과 같이 사용한다.     String message = \"Welcome to\\n betterFLY world!\";   System.out.println(message);   위 결과를 찍어보면     Welcome to \\n betterFLY world!    와 같이 결과가 나올것이다.   그리고 개행문자를 공백으로 제거한다면,     System.out.println(message.replaceAll(\"\\n\", \"\"));      Welcome to betterFLY world!    위와 같은 결과를 받아볼 수 있다.   “\\n” 는 그 자체가 개행문자를 표현한다고 생각했을 뿐, 각각의 역슬러쉬(\\)와 문자열(n)에 대해서 깊이 고민해보지 않았다.   그리고 다음과 같은 질답을 찾았다.   질문     답변     출처 : Okky 커뮤니티   그렇다.   역슬래쉬는 그 자체가 이스케이프문자 이므로, 그 자체가 어떤 의미가 있거나 표현할 수 없다.   자바를 비롯한 C계열의 대부분의 언어에서 역슬래쉬는 이스케이프 문자로 사용된다.      Escape Literal 이란?            Escape : 달아나다       Literal : 프로그래밍 언어에서 Literal의 일반적인 의미는 해당 언어가 처리하는 실제 데이터를 의미한다.           이 두 단어를 조합하면 ‘실제 데이터의 의미를 달아나다(벗어나다)’ 정도로 이해할 수 있을 것 갘다.       즉, 이스케이프 문자를 통해 그 다음에 오는 리터럴(문자)가 가지는 의미를 무시한다는 것이다.       그래서 이스케이프 일부 문자에 대해 단일 문자 이스케이프 시퀀스를 제공한다.   Escape Sequence     ","categories": ["JAVA"],
        "tags": [],
        "url": "http://localhost:4000/java/Slash_BackSlash/",
        "teaser":null},{
        "title": "Webpack Memory Leak",
        "excerpt":"웹팩 환경 아래에서 Vue.js 작업을 하며 소스코드를 변경하여 저장하면, 핫 리로드가 되면서 가끔씩 서버가 죽어버리는 현상이 발생한다.   아니 가끔이 아니라, 꽤 자주. 그리고 점점 더 빈번하게.   그리고 콘솔에는 다음과 같은 로그가 찍힌다.   Security context: 0000023290225879      1: fromString(aka fromString) [buffer.js:314] [bytecode=0000028B95FE9031 offset=164](this=00000066F9F822D1 ,string=0000026B6ACAC8C9 &lt;Very long string[44331659]&gt;,encoding=0000023290235001 &lt;String[4]: utf8&gt;)     2: from [buffer.js:177] [bytecode=0000028B95FE8B39 offset=11](this=0000001BB8136359 &lt;JSFunction Buffer (sfi = 000002329027BF81)&gt;,value=0000026B6ACAC8C9 &lt;Very long string[4...   FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory  1: node_module_register  2: v8::internal::FatalProcessOutOfMemory  3: v8::internal::FatalProcessOutOfMemory  4: v8::internal::Factory::NewRawTwoByteString  5: v8::internal::Smi::SmiPrint  6: v8::internal::StackGuard::HandleInterrupts  7: v8::String::WriteUtf8  8: v8::internal::wasm::AsmType::Extern  9: node::Buffer::New  …   사실 정확히 어디서 메모리 누수가 발생하는지 원인은 파악하지 못했지만 (아마도 Node.js 서버환경이 최적화되거나 힙 메모리 초기화를 하지 않은 문제이지 않을까…?)   위와 같이 Memory Leak 현상이 발생했다.   해결법은 의외로 간단했다.   현재 webpack 빌드 환경(package.json)은 다음과 같이 선언되어있다.       \"dev\" : \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\"   위 빌드 환경에 옵션을 조금만 추가해주면 이 문제를 해결할 수 있다.       \"dev\": \"node --max_old_space_size=8000 node_modules/webpack-dev-server/bin/webpack-dev-server.js  --inline --progress --config build/webpack.dev.conf.js \",   대략적으로 Node.js의 힙 메모리가 OS에서 할당하는 메모리를 초과하면서 발생하는 현상으로 강제로 할당량을 늘려버려서(node –max_old_space_size=8000) 문제를 해결한 것으로 보인다.   이게 근본적인 문제를 해결한 것이 아닌 것 같아 영 찝찝한 기분이 남는다.   자바스크립트의 메모리 관리를 찾아보며 Javascript의 GC 프로세스 및 메모리 관리하는 것에 대한 좋은 블로그들을 만날 수 있었다.   자바스크립트는 어떻게 작동하는가: 메모리 관리 + 4가지 흔한 메모리 누수 대처법    Node.js의 GC는 어떻게 동작하는가?   ","categories": ["notes"],
        "tags": ["webpack","memory leak"],
        "url": "http://localhost:4000/notes/1809_2/",
        "teaser":null},{
        "title": "그냥은 없다",
        "excerpt":"Request processing failed; nested exception is org.springframework.jdbc.UncategorizedSQLException: Error setting null for parameter #1 with JdbcType OTHER . Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. Cause: java.sql.SQLException: 부적합한 열 유형: 1111     mybatis를 사용해봤다면 수도없이 많이 봤을 에러.   부적합한 열 유형: 1111   정말 흔하게, 사소한 또는 부주의한 실수로 발생하는 에러다.   대부분 오탈자 또는 데이터타입이 맞지 않아 발생하는 경우다. 사실 이런 에러는 처리하기 그리 까다롭지 않다.   쿼리시 어떤 파라미터가 전달되는지만 꼼꼼히 따져보면 금방 나올 수 있기 때문이다.   이경우는      Error setting null for parameter #1 with JdbcType OTHER    첫번째 파라미터 타입이 null 이라는 것으로 보인다.     그런데…   아무리 뒤져봐도 파라미터 타입이나 내용에 문제가 보이지 않았다.   어떤 컬럼을 접근할때 문제가 발생했는지도 파악했는데 전혀 문제가 없어 보인다.   너무나 답답했다. 분명 별것도 아닌건데… 이런걸로 헤매고 있는 것 자체가 스스로 답답했다.   계속 같은 부분을 테스트하면서 같은 작업을 수도없이 반복했던 것 같다.   그러다 문득 생각이 들었다.   설마…?   이 쿼리는 어떤 필터항목을 저장 후 불러오는 쿼리인데, 저장하는 과정에서 이 컬럼에 엉뚱한 값이 들어가고 있었던 것이다.   애초에 저장자체가 잘못되고 있는 것을 확인하지않고, 너무나 당연하고 기본적으로 먼저 확인할 부분을 안보고 현재 일어나는 현상만 붙잡고 있었던 것이다.   사실 약간 마음이 떠 있어서, 급한 마음에 ‘대충’ 처리하고 싶었던 것 같다.   그 안일한 생각 덕분에 몇시간을 오히려 더 큰 고통을 받으며 시간을 허비해버렸다.   프로그래밍의 가장 큰 매력은 ‘그냥’ 이 없다는 것이다.   ‘그냥’되거나, ‘그냥’ 안되는건 없다.   정말 정확한 input과 output만 있을 뿐이다.   내가 input한 만큼만 output된다.   더 되지도, 덜 되지도 않는다. 정확히 내가 하는 행동에 덜하거나 더해지는 행위를 하지 않는 아주 솔직하고 정확한 작업이다.   중요한건 마음가짐이겠지.  ","categories": ["notes"],
        "tags": ["삽질"],
        "url": "http://localhost:4000/notes/1809_3/",
        "teaser":null},{
        "title": "실용주의 프로그래머(The Pragmatic Programmer)",
        "excerpt":"실용주의 프로그래머(The Pragmatic Programmer)   처음 도서리뷰를 해야겠다고 마음을 먹게 해 준 책이다.   처음 프로그래밍이라는 것을 공부할 때 처음 읽었고, 만 1년을 채우고 올 초에 다시 한 번 읽었다.   처음 읽을땐 무슨 뜬구름 잡는 소린가 90%정도는 소화가 되지 않았고, 올 초에 읽었을때는 50% 정도는 무슨 말을 하고 싶은지 의도를 파악할 수 있었다.   이 책은 이전에 읽었던 읽기 좋은 코드가 좋은 코드다 와 같이 직접적으로 코드를 짜는 것에 힌트를 제공하진 않는다.   하지만 전체적인 큰 그림. 프로그래밍을 대하는 자세. 사소하지만 중요한 것.   이렇게 내가 또 뜬구름 잡는 소리를 하고 있지만   내가 이 책의 마지막 정을 덮을때 가장 크게 든 생각은,   프로그래밍이라는 것이 ‘우리의 삶’ 그 자체를 담고 있다는 생각을 다시 한 번 확고히 느낄 수 있었다.   프로그래밍이라는 것이 대단히 어렵고, 예민한 작업이며, 변화에 민감하고, 효율성이 추구된다.   하지만 동시에 단순하고, 반복적이며, 효율은 생각치않으며 우연하게 구현할 수 있다.   누군가는 자신의 코드 한 줄, 한 줄을 고민하며 생산적이 코드를 구현하는 것에 심혈을 기울일 수도 있고,   누군가는 반복되는 코드는 복사하여 필요한 곳에 붙여 넣거나, 큰 고민 없이 의식의 흐름을 따라 코드를 구현하기도 한다.   갑자기 “삶” 이라는 단어를 언급하는 것이 어색하게 느껴지지만,   우리내 인생도 그러하다.   누군가는 자신이 하는 일의 전체적인 상황을 인식하며, 일정 또는 업무를 정리하여 효율적으로 일을 처리(DRY법칙)하고, 자신의 작업이 다른 팀 또는 다른 사람의 업무에 지장을 주지 않도록 고민(직교성)하는 반면,   누군가는 손에 잡히는 일이라면 보이는 즉시, 반복적이라면 똑같이 반복하여, 문제가 생기면 그 문제만을 바라본다.   우리는 전자와 같이 자신이 무엇을 하고 있는지를 정확히 알고, 잘 정리하여 일을 하는 사람을 일반적으로 ‘일을 잘하는 사람’으로 인정한다.   당연히 프로그래밍을 잘한다는 것은 손이 빠르고, 다양한 언어를 사용할 줄 알며, 장황한 지식만을 늘어놓기를 좋아하는 사람 보다는,   간결한 코드를 통해 자신의 생각을 담아내며, 자신의 코드를 책임질 수 있는 개발자.   그리고 혼자 하는 것이 아니라 좋은 동료를 활용할 줄 아는것, 그리고 프로그래밍에 끝이 없다는 것.     책의 리뷰를 써야하는데 책을 올 초에 읽어 구체적인 내용이 떠오르지 않아 궤변만 늘어 놓는 것 같다.   이 책은 적어도 일년에 한번씩은 꾸준히 읽으며, 내용들을 하나씩 곱씹어야겠다.   다음에 이 책을 읽고 이 리뷰를 볼 때 어떤 생각이 들까.   ","categories": ["REVIEW"],
        "tags": ["The pragmatic Programmer","실용주의 프로그래머"],
        "url": "http://localhost:4000/review/ThePragmaticProgrammer/",
        "teaser":null},{
        "title": "DataBase Index와 Cardinality",
        "excerpt":"Data Base 튜닝에 관해 항상 1 순위로 꼽히는, 가장 중요하고 기본 적인 개념인 Index.   사실 그렇게 중요하다는 것을 익히 알고있고 많이 들어왔지만, 사실 내가 다루는 작업들 중에 데이터양이 그렇게 많지 않아 인덱싱 작업을 한 기억이 많지 않다.   하지만 그만큼 중요한 것을 알기에 다시 한 번 개념을 잡아 놓을겸, 그리고 조만간 사용하게 될 인덱싱에 대해 미리 공부를 하게 되었다.   인덱스의 개념은 간단하다. ‘책갈피’ 라는 표현이 가장 쉽게 인덱스를 이해할 수 있는 표현인 것 같다.   index라는 것이 우리말로 ‘색인’ 이라는 뜻으로 해석되듯이 전체 스키마 중 특정 컬럼에 대해 ‘책갈피’를 꽂아 두는 효과를 갖는다.   그러면 우리는 어떤 컬럼에 인덱스를 걸어야 할까?   좋은 질문과 좋은 답변이 있어 발췌했다.      출처 : http://www.sqler.com/558930  질문 자체를 하나씩 이해해볼 필요가 있다.      컬럼에 nonclustered index 를 생성할 경우, 선택도가 좋은 컬럼에 index를 만들어야 한다.            ‘non-clustered index’는 무엇일까?                선택도 좋은지를 알 수 있는 방법은 통계를 보면 된다.       해당 컬럼의 통계를 보는 방법중 하나는 dbcc show_statistics(table_name, index_name)  ","categories": ["DB"],
        "tags": ["index","cardinality"],
        "url": "http://localhost:4000/db/DB_Index/",
        "teaser":null},{
        "title": "난 놈",
        "excerpt":"   넌 난 놈이니까 어디가서든 잘할거야      일년 반.   절대 길지 않은 시간이다. 짧게 그리고 나름 굵게 한 첫 회사를 마무리하게 되었다.   개발자라고 들어온 (뇌가)뽀송뽀송한 신입이 이제서야 써먹을만큼 가르쳐놨더니 이직을 한다고 하니, 회사 입장에선 큰 손실이고 배신감을 느낄 수 밖에 없을 것이다.   아마 팀장님이 그러한 감정이 가장 심하셨던 것 같고 사실 퇴사를 얘기할때부터 끝까지 협조적이지 않아 원망을 한 시간도 있었다.   하지만 공식적으로 마지막 출근을 마치고 왔다.   회사에서 사용했던 모든 물품들(개인적으로 사용한 다이어리를 제외한)은 회사의 동료들에게 모두 나누어주었다.   주변에선 나름 비용도 나가고 이직해서도 쓸만한 것들인데 왜 안가져 가느냐 했지만   “빈 손으로 왔으니까 빈 손으로 간다” 라고 너스레를 떨면서 동료들에게 나누었지만 사실 그게 내 마지막 감사함의 표현이었다.   특별히 선물을 준비하지 못하고 고작 사용했던 그 물건 몇개로 대신하는게 치사하지만, 내 나름의 감사함을 대신 표현한 것이었다.   인수인계를 다 마치고, 서류 결재도 모두 마무리되고 할 일이 없어졌다.   기술 블로그를 뒤적거리는 중에 자연스럽게 창천향로님의 블로그를 방문하게 되었다.   그리고 정말 우연히도 그 많은 글 중에 2년 전 글인데, 자신의 면접관으로 참관했던 팀장님이 구글로 이직했다는 이야기 였다.   자신이 그분과 함께 있는 2년 가까이 동안 나름 열심히해서 분명 실력이 늘었다는 것을 느꼈고, 조금은 그 분과 가까워 지지 않을까 생각했는데 그 분은 자신의 성장 보다 더 큰 성장을 하여 구글로 입사를 했 그 격차가 더 크게 벌어졌다는 것을 느끼며 자신이 한 노력이 작게 느껴진다는 내용이다.   너무나 공감이 되기도하고 한편으론 조심스럽기도하다.     내가 개발을 하며 가장 크게 마음 먹은 것이 ‘남들이 걸을때 나는 뛰어가자’ 는 생각이었다.   주위에서 보면 조금 조급해보일수도 있고 허둥지둥대는 것으로 보일 수 있겠지만 이것이 내가 개발자로 인정받고 성장하고 싶어 발버둥 치는 것이었다. (사실 발버둥 치는 것에 비해 실속없이 보낸 시간이 많은 것은 함정)   나는 주로 창천항로님의 블로그를 보며 자극 받는다.   창천항로님의 블로그를 보며 매일 새로운 것을 공부하고, 그것을 공유하고 끊임없이 자신을 발전시키고자 노력하는 그 열정이 나에게도 느껴질 정도라면 본인은 정말 얼마나 치열하게 살아가는 것일까 생각이 들기도 한다.   그렇게 치열한 하루 하루를 보내고 있는 분도 자신의 노력이 작게 느껴진다고 회의감을 느끼는걸 보면서 내 모습에 스스로 회의감이 들기도 했다.   여기까진 공감이 되는 부분이다.   하지만 조심스러운 부분은 기준이 ‘남’이 되는 순간 회의감과 자책감, 자괴감들이 몰려온다.   창천향로님이 말했듯 어제의 ‘나’, 연초의 ‘나’와 비교했을때 성장했다면 그걸로 된거다.   나도 열심히 한다고 했지만, 주변에 나보다 더 일취월장하는 사람을 보면 조급해지는 것도 당연하고, 내가 엄한 곳에 삽질을 하고 있나란 생각이 들기도 할 것이다.   하지만 냉정히 그들의 출발선이 나와 다를 수 있을 것이고. 그들이 내가 보이지 않는 곳에서 얼마나 더 큰 노력을 했는지 알 수 없다.   나 스스로 조급하지 않으려고 이렇게 마음속으로 생각을 하곤 한다.   그렇다고 나태해지면 안된다. 이 모든 것은 내가 치열하게 준비해가고 최소한 남들 만큼, 또는 그 이상을 노력했다는 것을 전제로 한다.     그 동안 말을 아끼시던 팀장님이 오늘 퇴사를 앞둔 시점에 마지막으로 악수를 하며 이렇게 말씀하셨다.      넌 난 놈이니까 어디가서든 잘할거야    근래에 내가 들었던 말 중 가장 큰 칭찬이었고, 저 한마디로 내가 지난 1년 반동안 그래도 틀리진 않았구나 라고 보상 받은 기분이었다.   ‘난 놈’ 이란 표현을 좋아한다. 특별하다는 의미일 것이다.   더 열심히 노력해야겠다.   10월부터 개발자로서 두번째 삶이 시작된다.   더 날고 싶다. 더 날기 위해서 훨씬 더 많은 노력이 필요하다. 남들이 걸을때 뛰어야 한다.   일주일간 잘 정비하여 10월부터 새로운 도약을 준비해야겠다.  ","categories": ["notes"],
        "tags": ["퇴사"],
        "url": "http://localhost:4000/notes/1809_5/",
        "teaser":null},{
        "title": "개발 2막",
        "excerpt":"기다리던, 한편으론 걱정스럽기도 했던 첫 출근이었다.   걱정보단 설레임이 컸는지 내심 출근이 기다려지기도 했다.   오전 시간은 가볍게 오티로 시작을 했고, 프로필 사진도 찍었다.   그리고 잠시 후 멘토라는 분들이 와서 우리를 데리러 왔다. 1:1 매칭된다는 멘토는 다름아닌 내 ‘사수’ 이다.   어색한 인사와 함께, 궁금한게 무엇이냐고 하는데 뭐가 궁금한지도 모른다. 가서 무슨일을, 어떤 환경인지도 모르기 때문에.   일단 많은 말은 하지 않았다. 바로 팀으로 이동했다.   이동하여 실장님과 우리 팀분들 그리고 나와 인터뷰를 진행했던 우리 팀장님께 인사를 드렸다.   전체적으로 인상들이 너무 좋았고, 특히 팀장님은 ‘잘 왔어요’ 라며 반겨주셨다. 굉장히 인상적인 인사였다.   그리고 무엇보다 마음에 들었던 것은, 내가 그토록 원하던 개발환경이었다.   내 자리에는 맥북이 있었고, 해상도 좋은 모니터 두 대와 매직 마우스와 키보드까지 세팅해 주었다.   그리고 cloud platform을 이용한 개발.   다 내가 꿈꾸던 개발환경과 구성이다.   첫 날이니 만큼, 기본 환경을 세팅할 것을 주문했고, 무엇보다 사용할 물건들과 소프트웨어들에 대한 권한 요청이 최우선이었다.   각종 계정 접근 권한 및 라이센스 발급에 필요한 결재만 2시간 이상 작성했던 것 같다.   결재라인도 손에 익지 않고, 아직은 헷갈리는 VPN, VDI등과 JIRA와 Confluence와 같은 atlassian 제품을을 사용한 것도 즐거웠다.   모든 과정들이 마냥 즐겁기만하다.   새로워서 좋은 것도 있지만, 이제서야 내가 원하던 밥상이 차려진, 내가 좋아하는 고기만찬들이 상에 올라온 기분이다.   모든 것이 순조롭고, 내가 할 일도 명확하다. 나만 잘하면 된다.   하지만 역시, 기대도 되고 걱정도 된다.   앞으로 할 일이 무엇일까 기대도 되고, 잘할 수 있을까 그리고 잘해야 된다는 걱정도 된다.   잘 할거다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_1/",
        "teaser":null},{
        "title": "IaaS, PaaS, SaaS",
        "excerpt":"IaaS &amp; PaaS &amp; SaaS   “Google Compute Engine 과 Google App Engine의 차이가 무엇인가요?”   질문으로 시작됐다.   현재 우리 서비스는 GCP위에서 구동되기 때문에 그 중 Compute Engine과 App Engine이 코어서비스이다.   그러자 사수분께서 이렇게 말씀하셨다.   “IaaS, PaaS, SaaS 에 대해서 들어보신 적 있으신가요?”   “아니요…”   처음 들어보는 개념이었다. 그리고 곧장 구글에 위 키워드를 검색하자 꽤 많은 결과를 확인할 수 있었고.   요즘 대세로 자리잡은 Cloud Platform 하에서 가장 기본적이고, 중요한 개념이었다.   우리는 우리가 사용한것들을 ‘왜’사용해야 하고, ‘무엇을’ 얻을 수 있는지 명확하게 이해해야 한다.   클라우드 서비스는 왜 이용할까?   간단하다. 대규모 서비스를 지원할 경우 운영서버 또는 DB서버 등 물리적으로 많은 서버자원 또는 가변적인 자원이 요구된다. 하지만 많은 자원을 관리하는데는 그만한 비용과 비효율이 발생할 수 있기 때문에 이를 대신 관리해주는 컴퓨팅 서비스에 일정한 대가를 지불하고 온전히 본인들의 서비스 분야에만 집중하기 위해서이다.   그러면 명확해졌다. 클라우드 컴퓨팅은 우리가 비효율적인 시간에 낭비하는 것을 방지해주고, 보다 간편한 환경구성과 필요에 따라 정확히 필요한 서비스를 효율적으로 사용할 수 있다.   그러면 이 클라우드 환경이 우리에게 무엇을 어떻게 제공해주는지 이해해야한다.   필요한 만큼, 원하는 만큼 컴퓨팅 인프라를 쓰자 ; IaaS(Infrastructure as a Services)   서버사이드 인프라를 구축하기 위해 필요한 자원인 네트워크, 스토리지, 데이터베이스 등을 제공한다.   사용자는 이 모든 환경을 커스터마이징 함으로써, 자신의 스펙에 맞는 서버 환경을 설정하고 로우레벨부터 제어할 수 있다.   기호에 맞춰 SW 개발 돕는, 개발자를 위한 서비스 ; PaaS(Platform as a Services)   쉽게 말해, 웹 개발자가 배포(deploy)만하면 되도록 안정적인 환경을 제공해준다.  응용프로그램을 손쉽게 개발할 수 있도록 API까지 제공해준다.   필요한 소프트웨어, 설치 없이 웹에서 뚝딱 ; SaaS(Software as a Services)   클라우드 환경에서 운영되는 최종 애플리케이션 서비스이다. 다시 말해, 최종 생산물인셈이다.   위 내용을 그림으로 정리하면 다음과 같다.      사실 위 그림을 참고하는 것이 가장 쉽게 참고할 수 있다.   전혀 어려운 개념이아니다.   마지막으로 각각의 서비스 별로 이해하기 좋게 분류한 표가 있다.      출처 : https://www.bmc.com/blogs/saas-vs-paas-vs-iaas-whats-the-difference-and-how-to-choose/  ","categories": ["ETC"],
        "tags": ["IaaS","PaaS","SaaS","Cloud Service"],
        "url": "http://localhost:4000/etc/Iaas_PaaS_SaaS/",
        "teaser":null},{
        "title": "Back-end 개발자",
        "excerpt":"Back-end 개발자  내가 무엇을, 무슨일을 하게 될지 꽤 명확헤 졌다.   우리 실의 역할은 사용자 별 추천서비스를 제공해준다.   사용자의 데이터를 수집하여, 행동을 분석하고 그들에게 필요한 상품을 예측하여 추천해주는 것이다.   궁극적으로는 위처럼 간단하지만 그 안에서 꽤 많은 업무 프로세스가 필요하다.   데이터를 분석하여 예측 및 추천해주는 일련의 과정은 분업화되어 추천서비스팀 등에서 업무를 관할한다.   우리팀의 역할은 레거시 데이터는 제외시키고 유효한 토큰값을 판별하고, 데이터를 가공하여 그들이 분석 및 활용에 사용할 수 있도록 처리하는 Back-end개발 중에서도 Back-end개발이다.   결국은 이 과정에서 많은 데이터를 관리하고 처리해줄 수 있는 성능 좋은 서버 또는 미들웨어가 필요하다.   그러한 미들웨어 역할을 해주는 것으로 우리는 GCP를 사용하는 것이고, 우리팀의 업무는 회사의 업무를 관장하기 위해 필요한 중간 지점의 데이터를 처리하는 미들웨어 역할을 하는 것이다.   개발자 중에서도 무수히 많은 다양한 직군들이 존재하지만  보통 웹개발자라고 하면 프론트엔드-백엔드로 분리가되어 진로를 결정한다.   첫 회사에서는 사실 이러한 경계가 없는 풀스택이라고 하기도 모호한 ‘웹 개발자’였다.   하지만 자바의 매력을 느끼고, 왜인지 모르겠지만 낯선 리눅스 환경에서의 개발 환경을 동경하고 서버 구축등에 관심을 가지며 백엔드개발자가 되리라는 막연한 목표만 갖고 있었다.   하지만 요즘 하나씩 회사에서 업무를 접하며 새로운 개념들, 말로만 듣던 서비스들을 눈 앞에서 목격하면서 조금씩 나의 역할이 무엇인지 눈에 보이고 내가 무엇을 담당하게 될지 알아가는 과정에서 더욱 욕심이 나기 시작한다.   항상 섣부른 의욕이 앞서는 것을 경계해야하지만, 지금 갖고 있는 이 설레임과 열정은 오래 간직하고 싶다.  ","categories": ["notes"],
        "tags": ["gcp"],
        "url": "http://localhost:4000/notes/1810_2/",
        "teaser":null},{
        "title": "ClassNotFoundException && NoClassDefFoundError",
        "excerpt":"ClassNotFoundException 그리고 NoClassDefFoundError   가장 쉽게 접하는 예외상황이기도 하고, 가장 단순한 문제이기도 하다.   그런데 문득 두 다 비슷한 문제로 보이는데 무슨 차이가 있는지 궁금해서 찾아보았다.   그러던 중 NoClassDefFoundError 발생하는 과정은 생소한 부분이 있어 기록하려한다.     ClassNotFoundException  : 클래스 로드 시 지정된 패스에 해당 클래스를 찾을 수 없는 경우   public class TargetClass {     public void execute() throws ClassNotFoundException{         Class c = Class.forName(\"web.ClassNotFoundTestt\");         System.out.println(\"terminated!\");     }       public static void main(String[] args) {         try {             new TargetClass().execute();         } catch (ClassNotFoundException e) {             e.printStackTrace();         }     } }       위와 같이 web패키지아래 ClassNotFoundTestt 라는 클래스를 로딩하지만 해당 클래스가 존재하지 않는 경우이다.   너무나 직관적이고 설명이 따로 필요 없을 정도로 간단하다.   위 예외 상황의 경우   at web.TargetClass.execute(TargetClass.java:10)   TargetClass의 10번째 라인에서 참조하고있는 web.ClassNotFoundTestt 라는 클래스가 존재하는지 확인해보면된다.   일반적으로 우리는 아주 성능좋은 IDE를 사용하기 때문에 컴파일 시 이렇게 참조된 클래스가 존재하지 않는 경우 아주 친절하게 참조하고 있는 클래스 패스 또는 클래스 정보의 문제가 있음을 알기 좋게 표현해준다.   하지만 문제는 NoClassDefFoundError 이다.   다음 예외는 비슷해보이지만 다르다.     NoClassDefFoundError  : 클래스가 Java 컴파일러 단계에서 생성되었지만 런타임시 종속된 클래스가 발견되지 않는 경우   말이 어렵다.   컴파일러 단계, 런타임, 종속된 클래스…   글로 이해하려 하면 이해가 되지 않는다 직접 보면서 확인해보자.   쉬운 예시로 직접 생성해가며 진행해보는게 이해가 빠르다.   (Mac의 터미널 환경에서 테스트를 진행했다. 자바 버전 1.8)      테스트를 하며 정말 큰 삽질을 해서 애를 많이 먹었는데, IDE를 통해 컴파일을 하면 이와 같이 테스트를 진행할 수 없다. IDE툴 마다 정확한 컴파일 원리는 파악하지 못했지만, 인텔리제이의 경우 파일 수정 후 저장을 할 경우 자동으로 컴파일 되며, 컴파일 된 파일은 따로 공간에 저장되는 것 같다.    테스트를 위해 다음과 같이 클래스를 만들었다.    class NoClassDefErrorMain{ \tpublic static void main(String [] args){ \t\tTarget target = new Target(); \t\ttarget.print(); \t} }  class Target extends TargetMain{  }   class TargetMain{ \tpublic void print(){ \t\tSystem.out.println(\"call target main class!!!\"); \t} }    각각 3개의 서로 다른 java(class)파일을 만들었다.   그 후 메인메서드를 갖고 있는 NoClassDefErrorMain 클래스만 컴파일 해주면 해당 클래스에 포함되어 있는 모든 자바파일들이 컴파일된다.      javac NoClassDefErrorMain.java    컴파일하면 다음과 같은 결과를 확인할 수 있다.      NoClassDefErrorMain 클래스에 종속되어 있는 모든 자바 파일들이 컴파일되어 .class 파일로 떨어졌다.   이제 모든 컴파일 작업이 완료되었으니 실행해준다.      java NoClassDefErrorMain       사진과 같이 정상적으로 실행되어 call target main class!!! 를 확인할 수 있다.   여기까지가 정상적으로 컴파일 된 자바파일을 실행한 결과이다.   다시 처음으로 돌아가, NoClassDefFoundError 에러의 정의를 되짚어 보면      클래스가 Java 컴파일러 단계에서 생성되었지만 런타임시 종속된 클래스가 발견되지 않는 경우    라고 한다. 그러면 우리는 지금 “Java 컴파일러에서 단계에서 생성” 까지 진행한 것이다.   그 다음 스탭인 “런타임시 종속된 클래스가 발견되지 않는 경우” 를 진행하기 위하여, 컴파일하여 만들어진 종속된 클래스   TargetMain.class 파일을 삭제 한다.      rm TargetMain.class       절차대로 진행했다면 위와 같이 파일의 결과가 나온다.   그러면 이제 다시 메인 메서드를 호출하자.      java NoClassDefErrorMain       드디어 나왔다. NoClassDefFoundError 이다.   앞서 진행한대로, 컴파일하는 단계에선 존재했지만 실제로 런타임하는 과정에서 참조하고 있는 클래스가 없는 경우 이와 같은 에러를 발생시킨다.   (현재 구조에서 Target.class 파일을 삭제 후 실행하는 경우 ClassNotFoundException 이 발생한다.)   위의 예시를 통해 정리하자면 이렇다.   ClassNotFoundException   JVM의 Class Loader가 NoClassDefErrorMain클래스에서 Target클래스를 로딩하려고 할 때 해당 클래스(Target)찾을 수 없는 경우   NoClassDefFoundError   JVM의 Class Loader가 Target클래스를 로딩 하는 중 TargetMain클래스를 내재적으로 로딩하던 중 TargetMain 클래스를 찾을 수 없는 경우.   다시 말해, Target클래스 내부에 정의된 TargetMain클래스가 class path에 존재하지 않아서 정상적으로 실행할 수 없는 경우를 말한다.     JVM의 구동 원리를 이전에 다루었던 적이 있었는데, 눈으로만 글을 봐서 피부로 와닿는 느낌이 없었는데 이번 이슈를 정리하며 조금은 JVM과 친해진 것 같다.   다음엔 인텔리제이가 어떤식으로 컴파일을 하고 구동되는지를 분석해보는 시간을 갖는 것이 좋을 것 같다.  ","categories": ["JAVA"],
        "tags": ["ClassNotFoundException","NoClassDefFoundError"],
        "url": "http://localhost:4000/java/ClassNotFound_NoClassDef/",
        "teaser":null},{
        "title": "미션-1",
        "excerpt":"첫번쨰 임무   열흘정도 분위기를 파악할 수 있는 시간이 있었다.   우리는 GCP라는 클라우드 플랫폼을 사용하며 서비스를 진행했고, 생소했던 커맨드를 이용한 개발 작업, 쉘 스크립트 그리고 많은 작업이 배치 스케줄을 돌리기 때문에 크론 잡 그 중, embulk라는 훌륭한 오픈소스까지 접해볼 수 있었다.   대부분 말로만 듣던 환경 위에서 작업한다는 설레임과 항상 웹개발(스프링과 메이븐)위주로 작업의 싫증을 느끼던 때 단비같은 이런 작업들은 너무나 즐거웠다.     그러던 중 마침내 첫번째 입무가. 아주 뜬금없이 떨어졌다.   오전에 알 수 없는 스케줄 관련 메일이 전달되었다.   15일 : 푸시 배치 작업   17일 : 연동 테스트   ~~   22일 : 리얼 배포   나랑 상관없는 일인가 싶어 별로 신경을 쓰지 않고 있었는데, 잠시 후 팀장님이 잠깐 회의를 하자고 하신다.   아니나다를까 방금 받은 메일 스케줄을 언급하시며, 15일까지 푸시 배치 프로그래밍 작업이 필요하다고 하셨다.   그리고 작업에 필요한 환경 구성과 전체적인 비지니스 로직에 대해서 설명해주셨다.   사실 그리 복잡한 작업은 아니다.      A서버 a테이블의 정보를 가져와서, B서버 a,b,c 테이블에 분기시키는 작업이다.    위 작업을 위해 다음의 과정이 필요했다.           embulk를 통해 A서버 a테이블을 B서버 a테이블로 데이터 이관 -&gt; cron-job            Google App Engine을 이용한 개발       embulk를 통해 데이터 이관하는 작업은 A서버의 접근이 구글 클라우드 서버를 통해서만 접근이 가능하여, 클라우드 서버에 잡을 돌려 데이터를 이관시키는 작업이 필요했고, 잡을 통해서 가져온 데이터를 프로그래밍하여 B서버의 각 테이블에 적재시키면 된다.   우선 업무 프로세스와 필요한 환경은 얼추 이해되었다.   낯선 개발환경에서 어떻게 개발을 시작해야할지 쉽게 떠오르진 않지만, 열흘만에 주어진 업무도 즐겁고 작업해야하는 내용도 기대된다.   하지만 한편으론 역시 걱정된다. 나는 이해했다고 생각했는데 막상 작업의 진전이 없거나 분명 어느정도 한다고 생각하고 맡겼는데 결과를 내지 못한다면 내 첫 인상, 그리고 신뢰를 쌓을 수 없을 것이다.   처음 맡는 작업이니만큼 더 각별하게 신경써서 작업해야겠다.   ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_3/",
        "teaser":null},{
        "title": "미션-2",
        "excerpt":"첫번쨰 임무 두번째 이야기   embulk를 통해 A서버 a테이블을 B서버 a테이블로 데이터 이관 -&gt; cron-job   embulk는 굉장히 훌륭한 오픈소스이다.   기본으로 제공해주는 docs에도 아주 상세하고 친절하게 사용방법이 나와있어서 어렵지 않게 작업할 수 있었다.   특히 인상싶었던 것은, embulk를 통해 디비 작업을 하면 mysql 기준으로 스스로 merge를 해준다.   예를들어,     A서버 a테이블의 a-1,a-2,a-3의 필드를 B서버 b테이블의 b-1, b-2, b-3 테이블로 이관하고 싶다면,    보내는 서버(in)의 정보와 쿼리, 그리고 받는 서버(out)의 정보와 테이블명을 기입해준다면,   만약에 B서버에 입력받을 b테이블에 대한 스키마 정보가 없다면, 입력하는 스키마 정보(A서버의 a테이블)와 동일한 테이블이 생성되며 데이터까지 적재된다.(단순 insert 뿐만 아니라, merge처리까지 자동으로 됨)   아주 효율적이고 강력한 기능이 아닐 수 없다!   덕분에 첫번쨰 작업 embulk를 이용한 크론잡은 해결됐다.   Google App Engine을 이용한 개발   이제 본격적인 작업이다. GAE(Google App Engine) 사용도 처음이고, 그보다 거의 모든작업은 Spring Framework/Boot 환경을 통해서 작업했는데 스프링을 사용하지 않고 Maven과 servlet환경으로 처리한다는 것 자체가 처음에 감이 잡히질 않는 것이다.   너무나 맹목적으로 ‘Maven-Spring’을 한 세트처럼 사용해왔기 때문에 이 둘을 분리하여 어떤 작업을 한다고 생각도 하지 못했다.   한편으론 이것이 가장 즐거운 일이기도 하다.   servlet만을 사용하여 웹 개발을 한 것은 개발을 거의 처음 배울때 잠시 스쳐지나갔기 때문에   doPost/doGet 이라는 메서드도 정말 오랜만에 본 것이다.   하지만 너무나 즐거운 일인 것이, 사실 Spring이라는 프레임워크들을 사용하는 이유가 바로 이런 불편한 개발환경을 개선하고 효율적인 작업을 위해서 등장했을 것이다.   그러면 무엇이 불편하지를 알아야, 스프링의 참 가치를 느낄 수 있다.   servlet 또는 그것보다 low한 환경에서 개발하지 않고 스프링만 사용하는 사람이 어떻게 스프링이 좋다고 말할 수 있을까?   그러한 물음에 조금이라도 접근할 수 있을 것 같아 아주 즐거운 경험이었다.(물론 초기 프로젝트 환경 구축조차 제대로 하지 못한걸 뺀다면…^^;;)   기계적으로 사용하던 Maven을 통한 라이브러리 구축, web.xml과 dispatcher-servlet을 통한 웹 환경 구축 및 디비커넥션처리 등 작업들은 수동으로 처리하여   JDBC를 직접 컨트롤(커넥션부터 클로즈까지)하고, doGet/doPost로 받는 파라미터도 직접 처리하고, Response type 설정, json 파싱 등등 직접 처리한다.   그래서 어려웠다.   그래서 유익했다.   초안 작업은 되었지만, 단순한 작업인데 mybatis를 쓰지 않다보니 쿼리 관리도 불편했고,   특히 무엇보다 결과를 받아 처리하는 과정이 너무나 비효율적이었다.   또한 급급하게 작업이 될 수 있도록 구현에 집중하다보니 클래스 구조나 로직 자체가 뒤엉킨 느낌도 많이 든다.   처음 작업이니만큼 지속적으로 리팩토링하여 쓸만한 코드로 닦아야 겠다.   이것이 내가 가장 원하던 작업이다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_4/",
        "teaser":null},{
        "title": "개념정리 : Protocol편",
        "excerpt":"What is a ‘Protocol’?      개발자라면, 특히나 웹개발자라면 항상 어디서든 등장하는 단어가 Protocol이다. 하지만 그동안 프로토콜의 정확한 의미를 생각하지 않았던 것 같아 정리하려한다.   대부분의 프로그래밍에서 사용하는 용더들이 그러하듯, 프로토콜이라는 단어 역시 개발자들에만 국한되는 단어가 아니다. 나무위키에 검색해보면 프로토콜은 다음과 같이 소개되고 있다.     출처 : 나무위키  말이 결국 어려워지지만, ‘통신규약’ 정도로 해석하는 것이 가장 자연스러워 보인다.   그럼 우리 개발자들은 이 통신규약(protocol)을 어떻게 사용할까?   깊이 들어가면 책으로 쓸 수 있는 만큼 다양하고 중요한 개념들이 많이 필요하지만 최대한 가볍게 접근해봐야겠다.   [참고]     http://huniv.hongik.ac.kr/~ginnie/communication/%C1%A4%BA%B8%C5%EB%BD%C503_%C7%C1%B7%CE%C5%E4%C4%DD.htm   http://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-9%ED%8E%B8-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%9D%B4%EB%9E%80-Protocol-%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80   http://ji-ggu.tistory.com/entry/Protocol-%EC%9D%B4%EB%9E%80   https://m.blog.naver.com/PostView.nhn?blogId=mes194&amp;logNo=220834219519&amp;proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F   ","categories": ["WEB"],
        "tags": ["Protocol"],
        "url": "http://localhost:4000/web/protocol/",
        "teaser":null},{
        "title": "자바로 배우는 리팩토링 입문(Java Refactoring For Beginner)",
        "excerpt":"자바로 배우는 리팩토링 입문(Java Refactoring For Beginner)   그동안 읽었던 책을 정리하고 싶었는데, 사실 잘 기억이 나질 않는다.   그보다 지금 읽는 것이라도 정리를 해 나가는게 좋을 것 같아 차근차근 업데이트해보려한다.   리팩토링은 개발자가 늘상 고민해야하는 과제이다.   변수명 하나를 바꾸는 것도 리팩토링 과정일 것이며, 보다 나은 프로그래밍을 고민한다면 늘상 고민하고 해결해나가야 하는 과정이다.   리팩토링 관련해서는 거의 바이블과 같은 책이 있지만     리팩토링(마틴 파울러)  위 책은 조금 어렵다.   그러던 중 스터디원이 자바로 리팩토링하는 과정을 쉽게 정리한 책을 추천해주었다.   전체 15개의 챕터로 구성되어있는데, 내용이 잘 정리되었고 예제가 잘 정리되어 있어서 읽기에도 좋았고   역시 이런 기술적인 서적은 금방 잊어먹기 때문에 간단히 기록해 두려한다.      2018.10.17    1장. 매직 넘버를 기호 상수로 치환      매직넘버란?   프로그래밍에서 말하는 매직넘버는 특정한 조건 혹은 필드 등의 값을 숫자로 표현하는 것을 말한다.    예를들어 다음과 같은 코드가 있다면,       if(100 &lt; input.length){         ...     }   위 상황의 경우 내용은 직관적으로 쉽지만 ‘100’이라는 조건이 어떤 값을 의미하는지 파악하기 어렵다.   하지만 다음과 같이 정의해보자.   public class Something{     public static final int MAX_INPUT_LENGTH = 100; }  if(Something.MAX_INPUT_LENGTH &lt; input.length){     ... }   이처럼 상수로 치환하여 사용한다면, 같은 ‘100’ 이라는 값이 정확히 어떤 의미로 사용하는지 이해하기 쉽다.   단순히 직관적으로 값의 의미를 이해하는 것 뿐만 아니다.   다음의 예제를 보자.   public class Sample1{     public void sample(){         if(100 &lt; input.length){             ...         }     } }   public class Sample2{     public void sample(){         if(100 &lt; input.length){             ...         }     } }  public class Sampl31{     public void sample(){         if(100 &lt; input.length){             ...         }     } } ...   이처럼 각각의 클래스에서 input.length를 검증하는 로직을 사용하는데 기준 값이 100이 아니라 200으로 변경된다면…   모든 클래스의 ‘100’ 값을 ‘200’으로 바꿔야 한다.   하지만 ‘기호 상수(symbolic constant)’로 처리한다면, 해당 상수의 값만 바꿔주면 한번에 해결할 수 있다.   최근 작업했던 어떤 프로젝트에서 이처럼 무분별한 매직넘버가 남용된 상황을 본 적이 있다.   알 수 없이 중구난방으로 사용되고 있는 숫자값때문에 정말 크게 애를 먹었던 기억이 난다.   가장 첫 장에 소개된 만큼 간단하지만 아주 중요한 작업이다.   프로그래밍은 혼자하는 것이 아니기 떄문이다.      2018.10.20    2장. 제어 플래그 삭제      제어 플래그란?   프로그래밍에서 ‘상태를 기록하고 처리 흐름을 제어하기 위한 boolean 타입의 변수’      ~~~java boolean flag = true; while(flag){     ...       if(A){         flag = false;     }else{         // do something     } } ~~~  *제어 플래그 삭제*  ~~~java  while(flag){     ...       if(A){         break;     }else{         // do something     } } ~~~  ","categories": ["REVIEW"],
        "tags": ["자바로 배우는 리팩토링 입문"],
        "url": "http://localhost:4000/review/JavaRefactoringForBeginner/",
        "teaser":null},{
        "title": "Maven Dependency Plugin",
        "excerpt":"Maven과 빌드이야기   현재 작업하는 프로그램은 최종적으로 jar파일로 배포하여 실행해야한다.   항상 웹개발을 했기때문에 jar를 패키징하는 것도 처음이었고, 프레임워크의 도움없이 레거시시스템으로 개발하는것도 처음이었다.   그리고 사실 그동안 메이븐은 그저 라이브러리를 디펜던시해주는 역할로만 사용했을 뿐 그 이상의 많은 환경을 손대지 않았었다.   그러다보니 스터디하는 대부분의 내용들은 단순히 코딩을 잘할 수 있는 것에 집중되었고 외부의 환경이나 흐름에 대한 고찰은 하지 못했었다.   무식하면 용감하다고, 이런 모든것들이 결국 프로그래밍이라는 것. 그리고 궁극적으로 이 모든 과정들이 어떻게 빌드되어 구동되는지에 대해서 깊이 알아보지도 않았다.   그러던 중 이렇게 스프링을 제외시키고 순수 메이븐 빌드환경을 구성해서 작업하며 정말 새롭게 깨닫고 배운 부분들이 많아 하나씩 기록해두려한다.     일반적으로 웹 개발에서 메이븐 사용시 빌드환경에 필요한 모듈을 얹어주면 패키징할때마다 필요한 모듈을 가져와서 라이브러리에 jar파일을 준비해준다.   하지만 데몬에서는 어떨까? 웹에서 모듈을 준비하지 못한다면?   때문에 데몬에서 실행되는 jar파일을 생성시 필요한 메이블 설정이 있다.      이와 같은 설정인데,   결과적으로 maven-plugins에 해당 옵션을 삽입해준다.      이처럼 설정 후 패키징을 해주자      clean package    /target 디렉토리에 패키징된 jar파일이 생성된다.   위 설정이 정상적으로 적용되었다면, 기본 artifact-id.jar 파일과 더불어,   [artifact-id]-[descriptorRef].jar 이와 같은 형식으 파일이 떨어진다.   이 파일은 메이븐에 주입해놓은 모든 모듈을 포함한 jar 파일이기 때문에 데몬에서 실행시 해당 jar파일을 실행하면된다.   [참고]     http://javafactory.tistory.com/1490   https://www.lesstif.com/display/JAVA/Maven+Dependency+Plugin  ","categories": ["notes"],
        "tags": ["maven"],
        "url": "http://localhost:4000/notes/1810_5/",
        "teaser":null},{
        "title": "공동체",
        "excerpt":"E05.181019.알쓸신잡3   알쓸신잡이라는 프로그램은 여러모로 너무나 많은 영감과 그 이상의 깊은 울림을 주는 가장 사랑하는 프로그램이다.   알쓸신잡을 한 편 보고나면, 책을 한 권 읽은 듯이 새로운 세상을 간접적으로 접하기도 하고, 전혀 몰랐던 역사적, 과학적 또는 그 밖의 세상의 많은 잡다한 지식들을 얻을 수 있다.   건강에 좋은 식사를 한 끼 마친것과 같은 포만감을 준다.   이번 에피소드에서 최근 내가 고민하던 또는 내가 걱정하던 주제에 대한 이야기가 얼핏 나왔다.     건축과 관련된 이야기를 하던 중 유럽의 광장 문화에 대한 이야기가 나왔다.   유럽에는 광장 문화가 발달하여 대부분의 큰 도시마다 광장들이 존재한다.   개인들이 모여서 합을 이루는 공간이다.   하지만 우리나라에서 광장을 찾아보기란 그리 쉽지 않다.   우리나라는 광장이라는 공간의 모임 보다는 인간적인 공동체 문화가 너무 많이 형성되어 있다.   우리가 속해 있는 집단은 항상 어떤 모임을 형성하여 새로운 그룹문화를 만든다.   그 속에서 우리는 ‘나’에 대해 집중하기 어려워진다. 이런 조직(공동체) 문화는 개인이 무시되는 경향으로 번지기도 한다.   우리는 관계망(network) 속에서 존재한다. 그 관계망을 벗어나는 순간 우리는 사회적으로, 사회적인 시선에서 인정을 받지 못한다.      형성된 관계망을 벗어나는 순간 우리는 곱지 못한 눈총을 받기도하고, 남들과 같지 않다는 것을 느끼며 스스로 괴롭다는 생각이 들기까지 한다.   유럽 문화와 우리 문화의 차이 중 하나는,   유럽은 개인이 있고, 그 위에 관계망들이 존재한다.   그들은 자발적으로 관계망을 형성하고, 그런 관계망을 표현하는 것이 광장 또는 무대로 이어진다.   우리는 어떨까?   우리는 항상 어딘가에 속해있다.   초등학교 동창회, 중학교 동창회 … 군대 동기 모임, 대학 동기 모임, 동호회 등등….   이미 우리는 너무나 많은 공동체에 속해있다. 그리고 그 공동체 속에서 쉽게 피로갊을 느끼기도 한다. 하지만 아이러니하게도 내가 공동체에 속해 있지 않다고 느끼는 순간, 주변과 비교하며 큰 소외감을 느끼기도 한다.   한편으론 공동체라는 틀 안에서 안정감을 느끼기도 하지만, 때로는 그 울타리를 벗어나고 싶억하기도 한다.   이러한 사회적인 성격때문에 굳이 우리는 광장이라는 공간에 모이지 않는다. 오히려 도망치고 싶어한다.     사실 이 이야기는 내가 그간 고민하던 것에 대한 대답과도 같이 들렸다.   원래 그러했지만, 최근들어 더욱. 사람들을 만나는 것에 허망함(?)을 느끼던 떄가 있었다.   누군가를 만난다는 것에 의미를 부여하며 하나씩 따지는 것은 피곤한 일이겠지만, 가끔은 어떤 만남을 가진 후 허무하게 느껴지기도, 이 시간이 정말 내가 좋아서 함께한 시간인가 하는 쓸쓸함마저 몰려올때가 있다.   이런 생각이 들면서도 그런 공간에 있는 다는 것은, 어쩌면 나의 그릇된 행동들이 이 관계망을 해치진 않을까에 대한 두려움이 있을 것이다.   그래서 늘 눈치를 보고, 관계를 살피며 쉽게 피로감을 느끼곤 한다.   답이 없는 고민이지만, 공동체라는 관계망에 너무 큰 의미를 부여하는 것은 나 스스로를 잡아먹는 피로감만 증폭시킬 것이다.   그 다음 재미있는 이야기가 있었는데 내일 이어서 써야겠다.   ","categories": ["notes"],
        "tags": ["알쓸신잡"],
        "url": "http://localhost:4000/notes/1810_6/",
        "teaser":null},{
        "title": "협업",
        "excerpt":"첫 푸시   처음 푸시를 한 날이다. 간단한 api를 수정했다.   화면의 정렬을 바꾸고, 노출되지 않던 데이터를 노출시키는 것 등 사실 크게 무리도 없는 작업이고, 늘 하던 작업이다.   그런데 처음해보는 작업이다.   그동안 했던 일은 사실 프론트/백엔드 구분이 없다. 내가 다 해야했으니까.   대게의 작업 흐름은 이러하다.      사용자의 요청(Request)를 받는다.   서버에서 해당 요청을 받아 DB에 쿼리를 날린다.   쿼리 결과를 담아 다시 사용자에게 전달/응답(Response)한다.   결과가 사용자의 브라우저에 랜더링된다.   특히나 내게 어려웠던 것은 화면단인데,   아이콘 위치의 차이, hover, 색상 등등… 퍼블리셔가 기본은 잡아주지만 보통 작업하다보면 모든 작업이 그렇게 말끔히 분업화되긴 힘들다.   난 이 작업들이 너무 즐겁지 않았다. 미적인 감각도 없었을 뿐만 아니라, 사용자들 저마다 서로 다른 요구를 하기 때문에 그 합의점을 찾는 것은 보통 어려운 일이 아니다.   그것이 결국 내가 back-end 개발자가되리라 굳게 마음먹은 이유 중 하나였지만.   다시 본론으로 돌아와서 오늘 내가 한 작업은 단순히 기존 화면에 1. 검색 기능이 추가되고 결과 정렬을 바꾸는 간단한 작업이었다.   사실 api 작업은 금방 끝났다. 크게 고민할게 없을 정도의 간단한 일이다.   그런데 문제는 그게 아니다.   먼저 처음 애를 먹었던 것은 Git의 사용이다.   그전까지 svn으로만 작업을 했던 것. 그리고 무엇보다 브랜치와 같은 기본 기능은 쓰지 않는다. 그저 main trunk를 고정으로 하여 그 메인 브랜치에 update/commit 이 외에는 거의 다른 작업은 하지 않았기 때문에.   브랜치가 분리되어 있고, 깃은 commit/push 까지 이어져야 하는 모든 과정들이 쉽지 않았다.   혼자 이렇게 블로그에 글을 남기고, 개인 작업을 하는 것도 그저 혼자 개인 깃헙에 날려버리는 것이기 떄문에 소스가 꼬일일도, 브랜치를 따로 따서 사용할 일도 없었다.   작업은 완료되었는데 내 로컬환경에서만 작업이 완료된건 전혀 완료된게 아니였다.   또 하나의 문제.   이렇게 완벽하게 백엔드와 프런트앤드가 분리된 경우 서버에서 제공하는 API는 정확한 명세가 필요하다.   어떤 파라미터를 요청받을 것이며, 어떤 결과를 리턴할것인지 정확한 명세.   우리는 이 api 명세를 Atlassian의 confluence라는 위키와 같은 공간에 공유한다.   이런 작업 역시 처음이었다.   상당히 재미있었다. 명확하게 각자의 포지션에서 정해진(약속된) 결과만 전달해주면 되는 것이다.   익숙했다면, 1시간도 채 안돼서 마무리 될 작업을 거의 반나절을 했다.   그래도 즐겁다. 내가 무엇을 놓치고 있었는지 하나씩 보인다. 그런 과정들을 스스로 찾아가면서 매꾸어 나가는 과정이 꽤 보람차다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1810_7/",
        "teaser":null},{
        "title": "Google Cloud Summit in Seoul",
        "excerpt":"1st. Google Cloud Summit…   기다리던, 그리고 기대했던 구글 클라우드 서밋 행사가 있는 날이다.   팀에서 함께 하는 행사이기 때문에 약간 소풍(?)가는 듯한 느낌도 들었고, 어쨋든 회사에서 권장해서 참여한다는것도 고무적이었다.   Google Cloud Summit은 이번에 한국에서 처음 열리는 행사라고 한다.   올 4월에 AWS Summit을 참석했었는데, AWS에 비해선 조금 작은 규모로 진행됐지만 전체적인 세션 구성은 오히려 더 흥미로웠다.   AWS는 전체적인 세션 구성이 서비스를 소개하고 홍보하는 느낌이 강했다면, 이번 구글 서밋은 이 서비스를 어떻게 적용할 수 있는지에 대한 사례 위주의 세션들로 구성되어 있어서, 실제로 개발자들이 어떻게 활용할 수 있는지 좋은 가이드를 제시해준다는 느낌이었다.   사실 세션에 크게 집중하지 못하여 많으 내용을 기록하지 못했다.   하지만 가장 인상깊었던 2가지 세션이 있다.   가장 먼저 기조연설을 했던 구글의 임직원분들의 발표였는데 그 중 구글 IoT 부사장을 맡고 있는 ‘이인종’ 이라는 분의 연설이었다.   사진을 담아두지 못해 아쉽지만, 굉장히 우리가 생각하는 ‘구글’ 그 자체였다.    출처 :http://news1.kr/photos/view/?3360340   자유분방한 헤어스타일, 기존연설의 연사임에도 후드티를 입고 있는 캐주얼한 복장, 여유있는 모습과 유머러스한 말투들.   겉으로 보여지는 모습만 봐도 절대 평범하지 않다.   그리고 다루는 이야기들은 더욱 흥미로웠는데, 특히 LG전자와 함께 스마트시티를 계획하고 있다는 소식이다.   도심에 설치된 CCTV를 분석하여 교통량을 예상하고, 더 나은 길을 제시해주기도 하고,   동네의 슈퍼, 세탁소 등에 모두 IoT를 결합하여 실시간으로 내가 방문하고자 하는 매장의 정보를 얻을 수 있다는 것이다.   참 멋있다는 생각이 들었다.   아직은 스스로 개발자라고 하기에도 부끄러운 위치이지만, 같은 개발자들이 하는 일들이 세상을 바꾸는데 기여한다는 것이 멋지고 대단하단 생각이 들면서도, 한편으론 나는 무엇에 기여할 수 있을까. 어떻게 하면 저런 고민들을 실천으로 옮길 수 있을까에 대한 막연한 혼자만의 고민속에 빠져들며 나 혼자 진지해지곤 했다.   기조연설을 마친 후 잠시 뒤 점심식사를 했다.   안내받은 공간에 정갈한 도시락들이 놓여있었고, 식사를 하던 중 스트리밍되는 화면에서 아주 흥미로운 화면을 볼 수 있었다.   [주제가 있는 런치] 라는 주제로 진행된 이 행사는,      3D프린터로 만드는 전자 의수   시각장애인을 위한 모바일 어플리케이션   음성을 통한 파킨슨 병 진단 디바이스   잘다니던 일류기업을 나와 3D프린터로 ‘의수’를 만들어 전세계 시장에 뛰어다니며 발품을 파는 멋진 개발자분의 발표로 시작했다.   말씀도 잘하셨고, 아주 멋지고 의미있고 그리고 상당히 가치있는 일을 하는 것에 큰 감명을 받았다.   그리고 다음 주제는 ‘시각장애인을 위한 모바일 어플리케이션’ 이라는 주제로 발표가 이어졌다.      그리고 아주 놀랍게도 고등학교 2학년의 학생이 무대에 올라섰다.   고등학교 2학년이 이 수백명 이상의 개발자들이 모인 공간에서 발표를 한다. 자신이 만든 서비스를.   그리고 그 주제와 실천은 더욱 참신했다.   ‘요즘은 자동차도 사람의 손을 쓰지 않고 움직이는데, 어떻게 사람은 하다못해 안내견의 도움이라도 없으면 가까운 동네조차 다니지 못한다는 것’ 에 착안하여 개발을 시작했다고 한다.   그리고 실제로 이런 어플리케이션을 만들기 위해선 동네의 위치 정보를 제공해주는 api가 있어야 만들 수 있는데, 참고할 만한 데이터가 존재하지 않아 직접 자전거에 카메라를 설치하여 동네 구석구석 직접 촬영하고 누비며 본인이 직접 서비스에 이용할 데이터를 수집했다.   그리고 이 과정에서 검정색은 ‘차도’, 흰색,빨간색,초록색 등의 색상이 있으면 ‘인도’ 라는 패턴을 머신러닝으로 학습시켜 어플리케이션이 스스로 모든 데이터를 분석하여 서비스를 제공하도록 구현해냈다고 한다.   그 과정에서 쓰레기더미, 장애물 등의 변수가 있을때 겪었던 문제들을 어떻게 처리했는지를, 조금은 긴장한채로 조심스럽게 풀어나갔지만 부모님뻘되는 사람들이 수백명 모인 공간에서 자신의 이야기를 풀어나간다는 것 자체만으로도 대단했고 그 모습들이 하나같이 너무나 인상적이었다.   고등학교 2학년의 나이에 그런 생각을 했다는 것도 너무 대단했고, 단순히 생각이나 상상으로 그치는 것이 아니라 실천으로 옮겼고, 실제로 그것을 완성시켰다.   적어도 나에겐 그것이 완벽하게 작동하는 어플리케이션인지는 중요하지 않았다.   지금 나에게 그런 어플리케이션을 만들어보라고 아이디어를 제공해줘도 만들어내기 힘들 것이다.   그 학생이 단순히 그런 어플리케이션을 만들었다는 것이 놀라운 것이 아니라,   그런 생각을 하는 과정과 실천력이 가장 존경스럽기까지 했다.   그 학생의 발표가 끝난 후 약간은 벙찐채로 로비로 나왔다.   여러가지 낯선 감정들이 교차했다. 아주 긍정적이고 가슴 깊은 곳에서 벅차오르는 기분이었다.   그런데 여기서 끝이 아니다.   로비로 나와 1층으로 이동 후 다음 세션을 위해 미리 들어가 있으려 했는데, 그 무대위에 교복을 입은 여자 학생이 발표를 하고 있었다.   말을 너무나 잘했다. 기술적인 용어들도 그렇고 자신이 겪은 문제, 그것 해결 하는 과정 등등 모든 표현이 너무나 정갈하고 정리되어있었다.   처음엔 어떤 기업에서 홍보차 나온 엔지니어라고 생각했지만, 그 학생은 고등학교 3학년의 여학생이었다.   초입에 어떤 계기로 어떻게 시작했는지를 놓쳤지만, 내가 들은 부분은 파킨슨병이 음성의 떨림 정도로 판별이 가능하여 이를 발견할 경우 초기에 조치가 가능한데, 우리나라에 이런 기술이 보급되지 않아 직접 구현해낸 것이다.   그리고 그 과정을 역시 머신러닝 ai를 통해 그 판별해 낼 수 있도록 구현하는 과정을 아무 멋지게 설명해나갔다.   그리고 이 학생은 자신이 소프트웨어만을 개발해왔기 떄문에, 이 소프트웨어를 사용하기 위해서 목소리를 담을 수 있는 디바이스가필요했다고한다.   정확한 모임은 기억나지 않지만, 개발자들이 모이는 캠프에 참여하여 자신의 소프트웨어를 소개한 후 팀을 꾸려서 디바이스와 소프트웨어를 결합시켜 이 도구를 만들어 낸 이야기였다.   그 팀에는 10여명의 팀원이 함께했고, 그 팀원들은 현업에 종사하는 개발자이거나 대학원생 등으로 구성된 전문 인력들이었다.      앞에 남학생과 또 다른 아주 대단한 학생이었다.   혼자의 힘이 아닌, 자신이 무엇이 부족한지를 알고 자신에게 도움을 줄 수 있는 사람을 정확히 찾아냈고, 그들과 아주 좋은 콜라보를 이루어 근사한 어플리케이션을 완성했다.   연속으로 이 두 학생의 이야기를 듣고 나니 정말 망치로 얻어마진 기분이었다.   좌책감이나 좌절감이 아니라, 내가 꿈이 없이 맹목적으로 개발만 잘하고 싶다는 생각으로 살고 있었다는 것을 깨닫게되었다.   사실 ‘개발을 정말 잘하고 싶고, 개발을 잘해서 인정받고 필요한 사람이 되기 싶다’ 정도만 생각했지 궁극적으로 어떤 개발자가 되겠다는 생각은 하지 못했던 것 같다.   오늘 컨퍼런스의 취지는 GCP의 특징이나 서비스의 고도화 등등을 소개하는 자리였을테지만, 내가 느낀 것은 세상에 기여하는 개발자들의 모습을 통해 나는 과연 무엇을 할 수 있을까를 돌아보는 시간이었다.   거창하고 대단해보이는 개발자가 아니라, 어떤 방식으로든 사회에 기여하고, 내가 하는 일에 더욱 가치를 부여할 수 있는 사람이 되고 싶다. 그런 철학이 있고, 생각을 하는 사람이 되어야 한다.   ","categories": ["notes"],
        "tags": ["Google Cloud Summit"],
        "url": "http://localhost:4000/notes/2018_google_summit_in_seoul/",
        "teaser":null},{
        "title": "Vue.js 시작하기",
        "excerpt":"Vue.js 설치 및 기본 환경 구성   참고 : https://medium.com/witinweb/vue-cli-%EB%A1%9C-vue-js-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-browserify-webpack-22582202cd52   https://velopert.com/3007   vue.js는 기본적으로 node.js서버 위에서 돌아간다.   node.js를 설치 후 npm(node package manager)을 통해 손쉽게 vue.js에 필요한 환경을 구성할 수 있다.      node.js 설치      https://nodejs.org/ko/       node -v // 설치 버전 확인    node.js가 정상적으로 설치되었다면, 이제 vue.js를 본격적으로 설치해보자.      npm install -g vue-cli // global에 설치하기 때문에 permission denided 발생할 수 있다. =&gt; sudo로 진행    vue.js 프로젝트 생성하기     // vue init   vue init [webpack/browserify/simple] [my-project]    위 커맨드를 보면, vue 기본 환경을 생성하는데 중간에 템플릿은 본인의 입맛에 따라 고르면된다. (vue list 통해 템플릿 리스트 확인)   webpack또는 borwerify는 모듈번들러 역할을 한다.      *모듈 번들러란? 번들링이란, 쉽게 말해 각각의 파일을 하나로 만드는 것으로 보면된다. 번들링은 여러가지 파일을 모아서 하나로 만드는 것이라고 보면 된다. 이렇게 번들링된 모듈들을 하나로 합쳐서 HTTP Request를 최소화 하여 성능을 향상 시키기 위해 사용된다.    프로젝트 생성시 configuration 설정에 대한 질문이 나오는데 크게 신경쓰지 않아도 된다. enter를 계속 눌러줘서 가볍게 기본 값으로 세팅한다.   끝났다.   필자는 webpack을 통해 프로젝트를 구성했다.      vue init webpack frontend    frontend라는 vue project가 금방 완성된다.      cd frontend    처음 설치한 프로젝트의 모듈들에 혹시나 설치가 안된 부분이 있을 수 있다.      npm install    install 내용이 없거나, 완료된 경우 프로젝트를 실행해주면된다.      npm run dev    특별히 host 또는 port를 변경하지 않았다면      http://localhost:8080    을 통해 접속을 확인할 수 있다.  ","categories": ["JAVA"],
        "tags": ["Vue.js"],
        "url": "http://localhost:4000/java/vuejs/",
        "teaser":null},{
        "title": "[음악게임 만들기] - 01.프로젝트 시작 및 Intro화면 만들기",
        "excerpt":"01. Java Swing을 이용한 음악게임 만들기      소스코드는 깃헙에서 관리한다.  https://github.com/betterfly88/SenseOfRhythm    평소 즐겨보던 유튜버 ‘동빈나’님의 컨텐츠를 보던 중 재미있는 주제가 있어 공부할겸, 그리고 기록으로 남겨 보려 한다.   정말 오랜만에 Java의 Swing컴포넌트를 이용한 프로그램 개발이다.   현재 계획으로는     유튜버의 내용을 그대로 따라간다.   중간 중간 개선이 필요하다고 생각하는 부분은 효율적으로 수정해본다.   실제로 게임의 구실을 하는 프로젝트를 완성한다.   배포 및 서비스 단계까지 실행해본다.   리팩토링을 통해서 전체 소스코드를 최적화한다.   현재 생각을 이러하다. 여유가 있다면 웹에서 실행되도록 진행해보고싶긴한데, 그건 차츰 생각해보자.   우선 프로젝트를 생성한다. 동빈나님은 기본 프로젝트로 생성했지만 추후에 라이브러리를 가져다 쓸 일도 있고, 최종 작업 후 조금 더 편리한 배포를 위해서 메이븐으로 프로젝트를 만들어주자.   프로젝트 생성 후 실행을 위한 메인 메서드부터 생성한다.   나는 다음과 같이 /src/main/java/app/rhythm/player 패키지 하위에 Main 메서드를 위치시켰다.      메인 메서드에서 할 일은 프로그램의 실행이다.     public class Main {     public static final int SCREEN_WIDTH = 1280;     public static final int SCREEN_HEIGHT = 720;      public static void main(String[] args) {         new SenseOfRhythm();     }   }    특별한 내용은 없다.   메인 함수가 할 일은 게임을 실행(new SenseOfRhythm : 게임이름)을 돕는 일 뿐이다.   SenseOfRhythm이라는 클래스의 인스턴스를 생성하면서 게임은 시작된다.   상단에 SCREEN_WIDTH/HEIGHT 값은 Swing 컴포넌트를 통해 그려질 화면의 사이즈다.   기본 사이즈로 1280 * 720 으로 설정했다.   그리고 이제 게임이 시작될 SenseOfRhythm 이라는 클래스를 만들어보자.   상단의 스크린샷처럼 우선 Main클래스와 같은 패키지 안에 클래스를 생성했다.   그리고 이 클래스의 내용은 다음을 포함한다.     public class SenseOfRhythm extends JFrame {     public SenseOfRhythm(){         setTitle(\"Sense Of Rhythm\");         setSize(Main.SCREEN_WIDTH, Main.SCREEN_HEIGHT);         setResizable(false); // 사용자 사이즈 조절 제한         setLocationRelativeTo(null); // 디스플레이 화면의 정 중앙 위치         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 프로그램 종료 후 실제로 프로세스를 종료시킴         setVisible(true); // 디스플레이에 노출 (false 설정할 경우 화면이 그려지지 않음)     }   }   현재 클래스에 몇가지 중요한 부분이 있는데,   우선 JFrame을 상속받았다는 것이다. JFrame은 곧 Java가 제공하는 Swing 컴포넌트를 사용하겠다는 것이다.   그리고      public SenseOfRhythm()    생성자를 통해 해당 클래스가 생성되면서 게임에 필요한 기본 세팅을 설정해두었다. 자세한 내용은 소스코드 옆의 주석을 참고하자.   현재 상태그대로 메인 메서드를 실행하면 1280*720 사이즈의 빈 화면이 출력될 것이다.      화면을 띄우는 것 까지 성공했으면 이제 기본 배경 이미지를 삽입해보자.   http://wallpaperswide.com   위 링크를 통해 본인의 입맛에 맞는 이미지를 다운받아보자.(이미지는 현재 화면에 맞는 1280*720 사이즈로 다운받아야 최적화된다.)   이미지를 띄울때 주의할 점은 기본적인 방법으로 이미지를 띄울때(싱글 버퍼링) 이미지가 바뀌거나, 불러오는 과정에서 버퍼링이 발생하여 깜빡이거나 이미지가 손실되는 문제가 발생할 수있다.   이러한 문제를 방지하기 위해 [더블 버퍼링]을 사용하는 것이 효율적이다.      더블 버퍼링이란  현재 프로그램의 전체 화면 크기에 맞는 이미지를 매 순간마다 생성해서 원하는 컴포넌트만 화면에 출력하는 방식이다. 버퍼에 이미지를 담아서 매 순간마다 이미지를 갱신해주기 때문에, 깜빡이거나 손실되는 이미지를 방지할 수 있어 실시간으로 이미지를 다루는 프로그램에서는 주요하게 사용된다.    우선 다운받은 이미지는 resource경로에 옮겨 두자.      그리고 이미지파일을 읽어서 화면에 출력시켜주면된다.   SenseOfRhythm 클래스의 멤버변수로 다음과 같이 선언한다.   public class SenseOfRhythm extends JFrame {     private Image screenImage;     private Graphics screenGraphic;     private Image introBackground; }    그리고 introBackground를 초기화해주면서 이미지를 삽입시켜주자.       public SenseOfRhythm(){         setTitle(\"Sense Of Rhythm\");         setSize(Main.SCREEN_WIDTH, Main.SCREEN_HEIGHT);         setResizable(false); // 사용자 사이즈 조절 제한         setLocationRelativeTo(null); // 화면의 정 중앙         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // 프로그램 종료 후 실제로 프로세스를 종료시킴         setVisible(true); // 실제로 인터페이스를 표출          // intro images         introBackground = new ImageIcon(Main.class.getResource(\"/images/intro.jpg\")).getImage();     }   이미지는 게임이 시작되면서(=SenseOfRhythm 인스턴스가 생성되면서) 출력되어야 하기 때문에, 이 클래스가 초기화되는 부분에 넣어주면된다.   주의할점은 resources 하위에 이미지를 저장해놓았기 떄문에 Main.class.getResource(“/images/intro.jpg”) 를 통해서 이미지파일에 접근할 수 있다.   자 이제 거의 다 왔다.   이제 실제로 컴포넌트 화면에 이미지를 그려주어야한다.   이미즤를 가져 왔는데 어디에 어떻게 표현할지를 설정해야하지 않는가?   다음 두가지 메서드를 만든다.       @Override     public void paint(Graphics g){         screenImage = createImage(Main.SCREEN_WIDTH, Main.SCREEN_HEIGHT);         screenGraphic = screenImage.getGraphics();         screenDraw(screenGraphic);         g.drawImage(screenImage, 0, 0, null); // 0,0 에 스크린 이미지를 그림     }       public void screenDraw(Graphics g){         // screenDraw 진입시 introBackground를 0,0에 그려준 후 다시 paint함수를 그려준다(this.repaint()) ==&gt; 매 순간마다(프로그램이 종료될때까지) 반         g.drawImage(introBackground, 0, 0, null); //         this.repaint(); //     }    먼저 paint라는 함수는 JFrame이 생성되면서 가장 먼저 화면에 그려지는 기본 함수이다.   안에 내용을 살펴보면, createImage() 그려질 이미지의 사이즈(x,y)   drawImage는 어떤이미지를, 어떤 위치에 그릴 것인지 설정한다.   그리고 screenDraw 함수를 통해 아까 언급했던 더블 버퍼링을 구현했다.   this.repaint()라는 것은 paint() 함수를 호출하는 것이기 때문에,   paint() -&gt; screenDraw() -&gt; paint() 로 돌아오는 재귀적 구조로 볼 수 있다.   위와 같이 설정했다면 화면 출력을 위한 구성이 완료되었다.   다시 메인메서드를 실행해보자.      intro 이미지가 잘 나오는 것을 확인할 수 있다.   다음에는 intro 배경음악이 흘러나오는 것을 구현해볼 것이다.   출처     유튜버 동빈나 : https://www.youtube.com/channel/UChflhu32f5EUHlY7_SetNWw  ","categories": ["JAVA"],
        "tags": ["Swing"],
        "url": "http://localhost:4000/java/toy_rhythmGame_1/",
        "teaser":null},{
        "title": "우선 순위",
        "excerpt":"벌써 한달이 지났다.   꽤 많은 일들이 있었다.   내가 작업한 모듈이 서비스에서 활용되기도 한다.   그리고 최근엔 embulk를 통해 bigquery -&gt; vertica 의 etl 작업을 진행하고 있다.   정확히는 저번주 목요일부터 진행을했다.   noSQL이라는 데이터도 처음 다루어 보았다.   여전히 많은 것들이 새롭고 낯설기만하다.   그런데 이제 그 낯섬에 대해선 극복이 필요할 것 같다.   이슈가 터졌기 때문이다   그것도 양방향에서…   ‘이충일’이라는 스레드는 동시 작업이 들어와서 병목을 겪었다.   이전에 push 모듈을 만들었던 A 라는 프로세스와   현재 진행 중인 빅데이터 etl 하는 B 라는 프로세스의 충돌이다.   나라는 스레드를 관리하는 사람은 나의 사수이다. 나의 사수분께서 내 스레드의 스케줄을 관리한다. 우선순위를 선정하고, 둘 중 무엇을 해야할지 몰라서 작업이 멈춰있는 나는 사수님이 설정한 스케줄대로 잡을 진행한다.   A라는 모듈의 이슈를 먼저할 것으로 스케줄링되었다.     A모듈의 문제는 원 서버에서 보내는 데이터가 제대로 업데이트가 되지 않는 이슈였다.   이 이슈를 겪으며 가장 치명적이고 기본적인 문제를 파악했는데, 다름아닌 작업을 할때 이 일이 어떻게 돌아가는 지 모르고 시작했다는 것이다.   개발자가 개발을 하는데 내가 무엇을 만드는지 모르고 시작한 것이다.   그저 ‘돌아가기만 하는’ 모듈을 만들어 놓은 것이다. 특별히 에러는 발생하지 않았고 로그도 잘 찍혔으며, 입력한 데이터가 제대로 들어온다.   사실 쉽게 생각하면 그것이 전부다.   하지만 디비 각 필드마다 어떤 역할을 하고, 어떤 값을 키 값으로 할것인지. 또 이 디비를 사용하는 클라이언트 개발자는 어떤 필드를 필요로 하는지 등등   참 생각없이 개발했다. 그저 자바코드를 어떻게 짤까. 객체지향적으로 하려면 어떨까. 중복은 어떻게 제거할까.   틀리진 않지만. 우선순위가 잘못됐다.      내가 무엇을 만들어야 하는지   이 서비스를 사용하는 사람은 무엇을 필요로 하는지   그것을 어떻게 만들 것인지   로그는 어떻게 찍을 것인지   등등   당연한 이야기지만, 모든 일에는 순서가 중요한 것 같다.   그 순서를 고민하고, 어떤 방향으로 어떻게 진행할지를 설계하는 모든 과정이 아키텍트겠지.   급하게 결과만을 좇아서 만들어 놓은 결과를 놓고 돌아보면, 결국 처음으로 다시 돌아간다.   처음 시작할때 쫓기는 마음으로 일단 코딩부터 해야겠다고 IDE를 켜는 순간 제대로 세우지 못한 계획 때문에 다시 처음부터 고민해봐야할때가 많다.   아마 그런 훈련이 몸에 익은 사람들을 시니어라고 하지 않을까 싶다.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_1/",
        "teaser":null},{
        "title": "paintComponent",
        "excerpt":"Java Swing component를 이용해서 간단한 음악게임을 만들고있다.   화면을 그리는 중인데   paint 와 paintComponent 간의 순서 또는 버퍼문제로 이미지가 제대로 뜨지 않는다.   백그라운드 이미지 위에 JLabel 또는 JButton이 위치해야하는데,   참고하고 있는 곳에서는 paint()를 이용해서 백그라운드 이미지를 그리고,   paintComponent() 를 이용해서 이미지 위에 버튼이나 레이블같은것을 뿌려준다고 하는데,   이 과정이 이중버퍼를 통해서 이루어지는 것으로 이해했는데   안된다.   아… 답답해        public void paint(Graphics g){         screenImage = createImage(Main.SCREEN_WIDTH, Main.SCREEN_HEIGHT);         screenGraphic = screenImage.getGraphics();         screenDraw(screenGraphic);         g.drawImage(screenImage, 0, 0, null);     }      public void screenDraw(Graphics g) {         paintComponents(g);         g.drawImage(introBackground, 0, 0, null); //        this.revalidate(); //        this.repaint();     }   paintComponents()를 올리면, introBackground가 나오고   내리면 버튼이나 레이블이 나오고 어쩌라는거…  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_2/",
        "teaser":null},{
        "title": "ideation",
        "excerpt":"누군가의 한마디가 큰 울림, 새로운 시발점을 불러오는 경험은 누구나 다 있다.   조금 전 ‘대화의 희열 - 아이유 편’을 보는데,   아이유가 암묵적으로 행해지고 있던 음원 시장의 규칙을 깬 이야기를 했다.   음원 시장은 암묵적으로 오후 12시부터 6시까지 음원발표하는 것을 관행으로 한다고 한다. 이유인즉슨,  그 시간에 스트리밍 집계를 하여 음원 순위에 반영되기 때문에 그 이전/이후에 스트리밍 하는 것은 꽤 큰 손실(Time-loss)가 있을 수 밖에 없다.   하지만 아이유는 ‘가을 아침’ 이라는 곡을 발매할때, 이건 누가봐도 아침 노랜데 오후에 낼 수 없다는 신념으로 모두가 반대하는, 그리고 경제적인 손실을 감수하고 아침에 발표했다고 한다.   (결과적으로 출근/등교 길에 이 노래를 접했던 대중들의 큰 공감을 사서 좋은 음원 순위를 기록하기도 했다고 한다.)   그리고 아이유는 이러한 형식적인 관행은 누군가 깨지 않으면 계속해서 같은 패러다임안에서 굴러가기 때문에, 창의적인 것이 실현되기 어렵다고 한다. 그 위험한 승부수를 내밀 수 있었던 포부와 자신감 그리고 자신의 음악에 대한 자부심까지 느껴져서 멋진 아티스트라는 생각이 들었다.   (아이유 음악은 좋아하지만 아이유를 찬양하는 ‘절대’ 아니다.)   평소 그 생각의 깊이가 얼마나 큰 지 모르겠지만, 아티스트라고 칭하는 사람들은 꽤 다른 영역에. 그리고 아이돌이라는 껍데기에 씌여져 조금은 ‘평가절하’되고 있는(어쩌면 나만 그러고 있을지 모르겠지만) 아티스트들이 많은 것 같다.   ‘어린 친구들이 뭘 알아’ 라는 꼰대식 마인드는 사실 나에게도 있다.   삶의 지혜, 세상을 보는 식견은 어느정도 세월에 비례한다고 생각했지만.   10대 어린 나이부터 활동해온 한 가수가 정신없이 시달리는 스케줄 속에서도 세상을 바라보는 통찰과 자기 내면의 훈련을 해내가는 과정이 대단하다고 생각한다.   흔히 ‘공인’이라고 불리는 대중들의 인지도를 먹고 사는 인물들에 대한 잣대가 엄격하다.   그도 그럴 것이, 그들이 실제로 대중(국민)들에게 미치는 영향력이 생각보다 강력하기 때문이다.   같은 맥락에서 아이유가 했던 저 작은 날개짓이 누군가에게 나비효과가 되어 큰 태풍을 일으킬 수도 있다.   그래서 난 새로운 것. 관행과 벗어난 무언가. 그리고 그것을 접근하는 과정들이 좋다.   같은 이유로 스터디와 같은 모임을 좋아한다. 특히 여러 사람이 모여 이야기 나누는 것이 좋다.   사람들이 모였을떄 재미난 경험들.   내가 불현듯 내뱉은 한마디에 옆에서 한마디씩 살을 붙여주어 풍성한 가지가 달린 나무가 되기도 한다.   예를들어, 스터디 이름을 정하는데 있어서 고민을 하던 중   누군가 ‘우리는 토요일마다 모이니까…’ 라는 한마디에   ‘토모’라는 스터디명이 탄생했다.   1차원적이고 직관적인 이름이라고 우습게 들릴 수 있지만, 우리는 이 이름이 너무 만족스러웠고 가장 우리다운 이름이었다.   또, 스터디 주제에 대한 아이디어를 고민할때도 아무 얘기나 내뱉은 한마디에 불씨가 지펴져 꽤 뜨거운 토론으로 이어지기도 한다.   그 불씨를 누가 집히느냐 이다.   [어떻게, 무엇을]과 같은 형식은 중요하지 않다.   불씨만 집혀주면된다. 판 만 준비해주면 된다는 것이다.   그것이 어떤 형태이든 그 새로운 불씨는 누군가의 심지에 불이 붙을 수 있다.   세상을 조금 더 주의깊게 바라보고 누군가의 소리에 귀기울이고 산다면.   그리고 내 마음 속에 언제든지 불이 붙을 수 있는 심지를 준비해 놓는다면.   언제든지 큰 폭발력을 낼 수 있지 않을까.      2018.11.10 새벽 6시에 뻘글…   ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_3/",
        "teaser":null},{
        "title": "String 이야기 1부",
        "excerpt":"String의 정체   String 이라는 자료형은 자바에서 가장 많이 쓰이는 타입일 것이다.   그 말은 다시 말해서, 많이 쓰기 때문에 중요하다는 것이다.   그리고 중요하다는 것은 제대로 알고 써야한다는 것이다.   그런데 아직 String이 낯설고 어렵게 느껴진다.   String과 StringBuilder 그리고 StringBuffer에 대해서 꽤 많이 검색을 시도해봤다. 정말 많은 비교 글들이 있다.   그리고 대게는 이와 같이 표현한다.            String은 immutable / StringBuilder 및 StringBuffer 는 mutable 이다.     StringBuffer는 동기화(syncronize)를 지원한다.     StringBuilder는 동기화 처리를 하지 않으므로 단일 스레드내에서 성능이 좋다.      벌써 말이 어렵다. immutable/mutable은 무엇이고,   동기화처리를 한다는 것은 어떤 처리를 말하는 것일까? 문자열 데이터를 처리하는데 멀티 스레드 환경이라는게 어떤 영향을 미칠까?   우선 한가지 희소식이 있다.   자바(이하 라이언 갓슬링)에서 이런 고민을 하는 우리를 위해 편의를 제공해주었다.   StringBuilder와 StringBuffer를 얕게 알고 있다면, 문자열을 조합할때 혼란을 겪곤한다. String을 아무 생각없이 조합해서 쓰면 안된다는 것이다.   String str1 = \"hello\"; String str2 = \"world\"; System.out.println(str1+str2);   이런 방식을 말하는 것인데, 이렇게 문자열을 조합하는 경우 과거(JDK 1.5버전 이전)에는 각각의 String 인스턴스가 생성되면서 메모리에 부담을 주기 때문에 많은양의 데이터를 처리하는 경우 성능에 이슈를 주었다고 한다.   하지만 현재(JDK 1.8을 사용 중) 발전한 자바에서는 위와 같은 단순한 String 간의 조합에선 컴파일 단계에서 StringBuilder로 컴파일 되도록 자동으로 처리해준다고 한다.   다음과 같이 말이다.   public class StringStory {       public static void main(String[] args) {           String str0 = \"Hello World\";           String str1 = \"Hello\" + \" World\";         String result = str0 + str1;         String str2 = str1 + \"!!!\";         String str3 = \"Welcome to \" + str0 + \"!!!\";     }   }   JDK1.4  public class StringStory {       public static void main(String[] args) {           String str0 = \"Hello World\";           String str1 = \"Hello World\";         String result = str0 + str1;         String str2 = str1 + \"!!!\";         String str3 = \"Welcome to \" + str0 + \"!!!\";     }   }   JDK1.5  public class StringStory {       public static void main(String[] args) {           String str0 = \"Hello World\";           String str1 = \"Hello World\";         String result = (new StringBuilder(String.valueOf(str0))).append(str1).toString());           String str2 = (new StringBuilder(String.valueOf(str1)).append(\"!!!\").toString());           String str3 = (new StringBuilder(\"Welcome to \").append(str0).append(\"!!!\").toString());     }   }   위와 같이 JDK1.4의 ‘result’ 변수를 보면 str0 과 str1 이라는 각각의 인스턴스를 조합하여 결과를 산출한다.   하지만 JDK1.5에서는 StringBuilder라는 하나의 인스턴스 내에서 추가되는 문자열을 append하는 형식으로 진행되기 때문에 1개의 인스턴스만 사용하므로 메모리 효율이 좋다는 것이다.   이제 다시 본론으로 돌아가 근본적인 내용을 살펴보자.     String의 중요한 성격은 immutable 하다는 것이다.   immutable이란 무엇인가?      ‘변하지 않는 객체’라는 것인데… 사실 잘 와닿지 않는다.   그럼 immutable(불변)과 mutable(가변)의 차이를 알아보면 도움이 될까 싶다.       @Test     public void immutableTest(){         String a = \"immutable\";         String b = a;         System.out.println(\"a.hashCode : \"+a.hashCode());         System.out.println(\"b.hashCode : \"+b.hashCode());         System.out.println(\"a : \"+ a);         System.out.println(\"b : \"+ b);          System.out.println(\"=====change b value=======\");         b += \" add str\";         System.out.println(\"a.hashCode : \"+a.hashCode());         System.out.println(\"b.hashCode : \"+b.hashCode());         System.out.println(\"a : \"+ a);         System.out.println(\"b : \"+ b);     }   먼저 이번 주인공인 immutable한 객체. String이다. 아주 심플하고 직관적인 코드다.   결과는 어떨까?   너무나 쉬운 예제이지만, 우리가 주목할 것은 ‘b’의 hashCode값이다.      hashCode는 해당 객체가 갖고 있는 고유한 ‘주소값’이다.       b의 hashCode값이 변했다   당연히 a의 결과는 변함이 없으며, b라는 변수는 추가한 문자열을 얻게 되었으며 새로운 주소값을 갖게 되었다.   다시 말해 이것은 b라는 새로운 인스턴스가 생성된 것이다.   단순히 b = a 라고 선언하여, a인스턴스를 참조할때는 둘 다 ‘1596987778’ 이라는 주소를 바라보고 있었다.   하지만 변수 b에 “add str” 이라는 문자열을 추가하면서 b는 새로운 주소값을 갖게되며 별도의 인스턴스를 차지하는 것이다.   우리는 이것을 당연하게 생각하지만, 이것이 immutable하다는 것이다.   아직 이해가 힘들다면 mutable한 객체의 변화를 살펴보자.       @Test     public void mutableTest(){         int [] a = {1,2};         int [] b= a;         System.out.println(\"a.hashCode : \"+a.hashCode());         System.out.println(\"b.hashCode : \"+b.hashCode());         for(int x : a){             System.out.println(\"a : \"+x);         }         for(int x : b){             System.out.println(\"b : \"+x);         }          System.out.println(\"=====change b value=======\");         b[1] = 5;         System.out.println(\"a.hashCode : \"+a.hashCode());         System.out.println(\"b.hashCode : \"+b.hashCode());         for(int x : a){             System.out.println(\"a : \"+x);         }         for(int x : b){             System.out.println(\"b : \"+x);         }     }   int 배열을 이용해서 테스트 했다.   이번 결과는 어떨까?   사실 윗 부분은 볼 것도 없을 것이고, 궁금한 것은 b배열의 변화 후 a 배열의 변화이다.   결과는 다음과 같다.      이번엔 어떤가?   a,b 모두 hashCode(주소값)가 변하지 않았다.   그런데 아래쪽 a[1] 배열이 5로 바뀌었다!   b[1]의 값을 변화시켰는데 a[1]의 값이 변한 것이다.   이 역시 당연한가? 이것이 mutable한 객체이다.   사실 이쯤에서 눈치를 챘을 수 있지만 이것은 자바의 중요한 개념 중 하나인 Call-by-Value &amp; Call-by-Reference에 해당하는 내용이다.(필자는 이것을 모르고 정리하다가 발견한 것은 함정)   [이전글]Call by reference in Java   아직 StringBuilder &amp;&amp; StringBuffer 이야기는 꺼내지도 않았는데 이야기가 길어졌다.   다음 포스팅에 본격적으로 String과 StringBuilder &amp;&amp; StringBuffer의 차이 및 활용에 대해서 조사해보도록 하겠다.   참고     https://gist.github.com/benelog/b81b4434fb8f2220cd0e900be1634753   http://limkydev.tistory.com/68   http://egloos.zum.com/iilii/v/3809685   https://www.slipp.net/questions/271   http://www.mimul.com/pebble/default/2015/10/10/1444466677572.html  ","categories": ["JAVA"],
        "tags": ["String","immutable"],
        "url": "http://localhost:4000/java/string_1/",
        "teaser":null},{
        "title": "Role Playing Game",
        "excerpt":"새로운 일을 하는 것은 언제나 즐겁다.   새로운 일을 하는 것은 내 머릿속에 없는 무언가가 나에게 들어오는 과정이다.   처음 그 기술 또는 업무를 익힐때는 숙련도가 낮아 크고 작은 실수도 반복하고, 실제로 이것이 좋은것인지 필요한것인지 판단하기 힘들다.(새로운것이라고 무조건 옳고, 좋은 것은 아닐 것이다)   그리고 그것이 내것이 되었을때. 비로소 똥인지 된장인지 판별이 가능하기도 하다.   내가 가장 좋아했던 WOW(World Of Warcraft)라는 게임이 있다.   캐릭터를 새로 생성하면 기본공격밖에 없다.   처음 시작하는 마을에서부터 퀘스트를 부여 받으며 기본 공격만을 이용해서 레벨업을 하고, 스킬을 익히며 점점 강해진다.   지금은 없지만 과거의 와우에는 공격/스킬 숙련도가 있어서 처음 배웠을때(숙련도가 낮았을 때)는 ‘MISS’도 많이 나고 삽질을 하기 일쑤다.   하지만 거듭 같은 공격/스킬을 사용할수록 해당 숙련도가 상승하고 최대치의 숙련도까지 익히면 거의 ‘MISS’가 나는 일이 없다.   레벨이 높을 수록 많은 스킬을 보유할 수 있다.   우리는 이 보유한 많은 스킬들을 저마다 개성에 또는 특성에 맞게 조합하여 자신만의 스킬트리를 완성한다.   우리는 이렇게 강해지면 던전이라는 곳에서 팀을 이루어 강한 상대를 상대한다. 그리고 그 던전을 클리어하면 좋은 보상이 떨어진다.(레이드는 더욱 큰 조직활동)      어떤가?   저 신규 생성된 캐릭터에 ‘나’를 대입하고, 공격/스킬은 우리가 익히는 언어 또는 기술 등에 대입해보면 우리가 하는 일과 전혀 다르지 않다.   아니, 어쩌면 개발자를 모티브로 만든건 아닌가? 생각이 들 정도로 정확히 같은 패턴이다.   사실 개발자에 국한되는 것이 아니라 우리 인간의 삶과 꼭 닮아 있다.   (사실 우리는 ‘역할 놀이(Role Playing Game)’를 하고 있는 것이다!)   사실 새로운 것을 배운다는 것.   그 즐거운 과정이 게임내에서 케릭터를 육성하는 과정과 다르지 않다는 생각이 들어 포스팅을 시작했는데 결론을 맺기가 어렵다.   쉽게 생각하면 편한 것 같다.   어차피 새로운 것은 다 어렵다. 그래서 두렵기도하다. 때로는 계속 새로운 것들을 접하다보면 지칠 수도 있다.   최근에 몸으로 느끼는 것 중에 ‘롱런’할 수 있는 가장 근본적인 방법 1순위가 ‘(건강한)체력’ 그 다음으로 ‘(본질에 대한)이해’인 것 같다.   이 과정들을 항상 즐길 수 있는 강인한 체력을 길러야겠다.   이제 시작이니까.  ","categories": ["notes"],
        "tags": [],
        "url": "http://localhost:4000/notes/1811_4/",
        "teaser":null},{
        "title": "AWT(Abstract Window Toolkit)",
        "excerpt":"자바와 AWT 그리고…   최근 자바로 비트매니아와 같은 음악 게임을 만들려고 작업을 하고 있었다.   순수 자바로 하기 때문에 GUI는 SWING/AWT를 이용할 수 밖에 없었다.   그리고 열심히 화면을 하나하나 그려갔다.   배경 이미지를 골랐고, 버튼이미지들, 그리고 배경음악으로 깔릴 BGM과 플레이어까지 붙였다.   뭐 딱히 어려운 부분도 아니고 순조롭게 그려나가는 중…   실행을 했는데 화면이 아무리 해도 안뜬다.      실제로 이렇게 배경화면이 죽어버리고 무슨 짓을 해도 화면이 안뜬다.   아무리 인터넷을 뒤져봐도 큰 문제는 없어보이고.     ","categories": ["notes"],
        "tags": ["AWT"],
        "url": "http://localhost:4000/notes/1811_5/",
        "teaser":null},{
        "title": "String 이야기 2부",
        "excerpt":"StringBuilder 와 StringBuffer   조금 식상한 감이 있다. StringBuilder와 StringBuffer 대한 차이 및 비교는 너무나 많은 자료가 많기 떄문이다.   조금 더 의미있는 기록을 남기기 위해서, 그리고 내 것으로 소화하기 위해선 단순히 사실만을 나열할 것이 아니라   실제로 어떻게 사용되고, 적용되는지 조금 더 세밀히 들여다 봐야겠다.     우선 앞선 String 이야기 1부에서 언급했던 Sting문자열을 합칠 때 컴파일 과정을 다시 확인해 볼 필요가 있다.   다시 정리하자면, 단순 String만을 활용하여 문자열을 합친다면 immutable한 속성의 String클래스는 그 자체로 연산이 불가능하기 때문에 계속해서 새로운 String 인스턴스를 생성시킬 것이고, 이것이 결과적으로 메모리 효율을 떨어뜨린다는 것이다.   그리고 JDK1.5 버전 이후로는 이러한 문제를 돕고자 JVM이 컴파일 과정에서 StringBuilder로 처리해준다는 것까지 살펴보았다.   이를 통해 String을 쓰지 않고 StringBuilder를 사용했는지는 이해됐다.   그렇다면 왜 StringBuffer가 아닌 StringBuilder를 사용했을까?   Java docs의 API문서를 통해 두 클래스간 성격을 파악해봐야겠다.   StringBuffer     밑줄친 부분이 StringBuffer의 중요한 특징을 설명해주는 것 같다.     mutable한 객체이다            String과 유사하지만 수정이 가능하다.           thread-safe하다            multiple-threads환경에서 사용하기에 안전하다.(method에 synchronized가 되어 있기 때문에!)           mutable/immuntable에 대한 개념은 지난 String에 대한 고찰에서 살펴보았으니 이해가 된다.       하지만 thread-safe하다는 것은 아직 이해가 되지 않는다.       그 궁금증은 잠시 후 해결하기로 하고 StringBuilder의 특징을 보자.       StringBuilder       mutable한 객체이다.   StringBuffer와 호환되는 API를 사용하지만! synchronization을 보장하지 않는다   StringBuffer 대신 단일 스레드에서 사용하기 위해 설계되었다.            StringBuffer는 synchronization을 지원하기 때문에 멀티스레드에서 안전하지만, StringBuilder는 synchronization을 지원하지 않기 떄문에 단일 스레드에서 효율적이라는 것이다.(Single/Multi thread에 대한 내용은 하단에 다시 정리하겠다.)           마지막 문장이 중요한데, StringBuffer보다 수행속도가 빠르므로 가능하다면 StringBuilder를 사용하는 것을 추천한다.   스레드에 대한 이야기는 차츰 정리하고,   왜 자바에서 String문자열을 조합할때 컴파일과정에서 StringBuffer 대신 StringBuilder를 사용하는지 밝혀졌다.      StringBuilder가 StringBuffer보다 속도가 빠르다는 것이다!   단! Single Thread에서만 유효하다는 거!    그러면 잠깐 테스트를 좀 해봐야겠다. 실제로 얼마나 성능이 차이가 나는지를.     @Test     public void compareWithBuilderNBuffer(){         System.gc();         long start=new GregorianCalendar().getTimeInMillis();         long startMemory=Runtime.getRuntime().freeMemory();         StringBuffer sb = new StringBuffer(); //        StringBuilder sb = new StringBuilder();         for(int i = 0; i&lt;200000; i++){             sb.append(\":\"+i);             sb.insert(i, \"Hi\");         }         long end=new GregorianCalendar().getTimeInMillis();         long endMemory=Runtime.getRuntime().freeMemory();         System.out.println(\"Time Taken:\"+(end-start));         System.out.println(\"Memory used:\"+(startMemory-endMemory));     }      실패다. 거의 차이가 없거나 StringBuffer가 더 빠르기도 하다.   테스트 수치가 잘못되었나 싶다.   실제 성능을 비교한 블로그가 있어 링크를 참고한다. String속도측정   블로그에 따르면 163,840,000번 (약 1억 6천번) append를 하는데 2.65초밖에 걸리지 않는다.(StringBuffer가 2.65초 시간이 더 걸렸다는 것.)   뭐 정석대로 싱글 스레드라면, StringBuilder를 사용하지 않을 이유가 없겠지만. 사실상 드라마틱한 차이 정도는 아닌 것을 알 수 있다.   자 이제 마지막으로 Single/Multi Thread에 대한 이야기다.   StringBuffer의 내부를 들어가보면 append() 메서드가 다음과 같이 선언되어있다.      @Override     public synchronized StringBuffer append(Object obj) {         toStringCache = null;         super.append(String.valueOf(obj));         return this;     }      @Override     public synchronized StringBuffer append(String str) {         toStringCache = null;         super.append(str);         return this;     }   다음은 StringBuilder의 apeend 메서드이다.       @Override     public StringBuilder append(Object obj) {         return append(String.valueOf(obj));     }      @Override     public StringBuilder append(String str) {         super.append(str);         return this;     }   이전에 API문서처럼 동일한 메서드와 파라미터를 받고 있다. 하지만 그 성격이 다르다.(당연하게도 똑같다면 굳이 두 클래스가 존재할 이유가 없다.)   StringBuffer는 synchronized 를 지원하는 것이다!   thread에 대한 기본 개념은 과거포스팅을 참고하시라! Process와 Thread      정리하자면 쉽게 말해 메서드 하나에서 하나의 기능만 순차적으로(동기) 수행할 것이라면(싱글 스레드) StringBuilder를 사용하는 것이 효율적이다.   하지만 멀티스레드 환경에서 비동기적으로 문자열 처리를 한다면 StringBuffer를 처리하면 된다는 간단한 결론이 나온다.   또한 JDK1.5이상의 버전을 사용한다면, String연산에서 굳이 StringBuilder를 고민할 필요도 없다.   즉 우리가 고밀한 것은 문자열 처리를 하는데, 이 환경이 싱글 스레드냐 멀티 스레드냐만을 고민하여 StringBuffer를 적재 적소에 사용하면 된다는 개념만 탑재하면 될 것이다.   참고     https://novemberde.github.io/2017/04/15/String_0.html   https://www.geeksforgeeks.org/stringbuffer-class-in-java/   https://www.journaldev.com/137/stringbuffer-vs-stringbuilder  ","categories": ["JAVA"],
        "tags": ["String","StringBuilder","StringBuffer"],
        "url": "http://localhost:4000/java/string_2/",
        "teaser":null},{
        "title": "Connection pool",
        "excerpt":"징그러운 삽질의 시간이었다.   사건의 발단을 이러했다.   Spring을 쓰지 않는, 그리고 다른 프레임워크에 의존하지 않는 레거시환경에서 내가 맡고 있는 도메인이 운영되고 있고,   해당 도메인의 낡은 쿼리 방식을 걷어내고 myBatis를 도입하는 미션이 주어졌다.       /**      SELECT * FROM sample_table      */     @Multiline     String sqlSelectSampleTable;   이와 같은 방싱그로 전체 쿼리가 구성되어 있었고, 이를 걷어내고 myBatis를 도입시키는 것이다.   Spring을 쓰지 않는 환경에서 myBatis를 활용하는것 자체가 낯설었다.   기존대로 xml에 jdbc configuration파일은 만들었지만, 커넥션이 붙을때 이 환경파일을 어떻게 읽어야 하는지, 그 뿐만 아니라 전체적으로 어떻게 DAO에 쿼리를 주입시킬 것인지 등등 직접 컨트롤해줘야하는 환경은 낯설고 쉽지 않았다.   우선 DB커넥션 환경을 제공하는 SqlSessionFactory 클래스를 다음과 같이 만들었다.   import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder;  import javax.servlet.http.HttpServlet; import java.io.InputStream;  /**  * Created by betterFLY on 2018. 11. 09  */ public class MyBatisConfig extends HttpServlet {     private static SqlSessionFactory sqlSessionFactory;     public MyBatisConfig(){         getInstance();     }      public static synchronized SqlSessionFactory getInstance(){         InputStream config = MyBatisConfig.class.getClassLoader().getResourceAsStream(\"mybatis/mybatis-config.xml\");         if(sqlSessionFactory == null){             sqlSessionFactory = new SqlSessionFactoryBuilder().build(config);         }         sqlSessionFactory.getConfiguration();         return sqlSessionFactory;     }      public static SqlSessionFactory getSqlSessionFactory(){         return sqlSessionFactory;     } }   행여나 connection pool 이 여러개 생성되면 문제가 발생할까 싶어 싱글턴으로 만들었다.   쿼리시 사용될 SqlSession은 이 클래스에서 생성한 커넥션풀을 가져다 사용하도록 설계했다.    import org.apache.ibatis.session.SqlSession;  import java.util.HashMap; import java.util.List;  /**  * Created by betterFLY on 2018. 11. 13  */ public class SampleService extends MyBatisConfig {     private SampleDAO dao;     private SqlSession session;      public SampleService(){         session = MyBatisConfig.getSqlSessionFactory().openSession(true);;         dao = session.getMapper(SampleDAO.class);     }      public List&lt;SampleVO&gt; selectTestToken(SampleVO vo){         HashMap&lt;String, String&gt; query = new HashMap&lt;&gt;();         query.put(\"query\",vo.getSample);          List&lt;SampleVO&gt; resultList = dao.sqlSelectSampleCode(query);         return resultList;     }      public void insertSampleCode(SampleVO vo){         dao.sqlInsertSample(vo);         session.commit();     } }   대략적으로 위와 같은데,   내가 JDBC에 대해서 이해한 바로는     쿼리를 수행하기 위해선 Connection Pool에서 세션을 열어야 쿼리를 날릴 수 있고   그렇게 할당받은 SqlSession에서 어떤 mapper에 선언된 쿼리를 수행할 것인지 맵핑하여   DAO를 통해 해당 쿼리를 수행한다.   정도로 이해했다.   그리고 위와같이 설계한 이유는 각각의 메서드마다 세션을 열고, 매퍼를 주입할 경우 중복이 발생하므로, 어차피 해당 클래스 인스턴스가 생성될때마다 새로운 쿼리가 수행될테니, 생성자에서 처리해주면 될 것이라고 생각했다.   그리고 개발하며 Postman과 같은 도구를 이용하여 API를 테스트해보니 정상적으로 처리 결과를 확인할 수 있었다.   이런식으로 로컬환경에서 하나의 API를 만들고, 테스트하는 방식으로 전체 쿼리를 문제없이 적용했다.   그리고 이제 드디어 메인 소스와 merge를 진행했고, 웹에서 본격적인 테스트를 진행했다.   우리 도메인의 메인 서비스는 ‘푸시 서비스’이다. 잡을 걸어 놓으면 스케줄러는 1분마다 쓰레드를 실행하며 스케줄에 해당하는 푸쉬를 발송하는 것이다.   그런데 이 푸시 서비스만 실행하면 다음와 같은 에러가 발생하는 것이다.      대충봐도 DB Connection에 문제가 있다. connection이 유효하지 않다는 것인데 ‘도대체 왜?’ 커넥션에 문제가 발생했는지 알 수 없었다.   구글링을 수도없이 해봤지만 찾을 수 있는 대답은  ‘SqlSession을 제대로 닫았는지 확인해라’ 정도의 답변만 눈에 띄었다.   그래서 session.close를 쿼리 수행 후 바로바로 진행했지만 결과는 같았다.   정확한 원인을 파악하지 못하고 있는 것이었다.   이틀간 수도 없이 디비 커녁센에 관하여 서칭하며 조금 근접해보이는 해결책을 찾을 수 있었다.   Naver D2; Commons DBCP 이해하기   Connection Pool을 관리해주는 라이브러리다. 커넥션 구성 환경을 설정하여 커넥션 풀의 생명주기를 컨트롤하는 것을 돕는 라이브러리로 보인다.   그런데 이 적용 방법이 모두 스프링프레임워크 환경에 관한 예제밖에없다.     public static synchronized SqlSessionFactory getInstance(){         if(sqlSessionFactory == null){            DataSource dataSource = MyBatisConfig.getDBCPDataSource();            TransactionFactory trxFactory = new JdbcTransactionFactory();            Environment env = new Environment(\"development\", trxFactory, dataSource);            Configuration config = new Configuration(env);             sqlSessionFactory = new SqlSessionFactoryBuilder().build(config);         }         sqlSessionFactory.getConfiguration();         return sqlSessionFactory;     }    public static BasicDataSource getDBCPDataSource() {         BasicDataSource dbcp = new BasicDataSource();         dbcp.setDriverClassName(\"com.mysql.jdbc.Driver\");          dbcp.setUrl(getProperties(\"connectUrl\")+\"?autoReconnect=true&amp;amp;useSSL=false&amp;amp;characterEncoding=UTF-8\");         dbcp.setUsername(getProperties(\"userName\"));         dbcp.setPassword(getProperties(\"userPassword\"));          dbcp.setMaxTotal(30);         dbcp.setMaxIdle(30);         dbcp.setMinIdle(30);         dbcp.setInitialSize(30);          dbcp.setValidationQuery(\"SELECT 1\");         dbcp.setPoolPreparedStatements(true);         return dbcp;     }   이와같이 커넥션 환경을 주입시켜주려고 했지만, 이렇게 할 경우 mapper 클래스에 대한 접근이 불가능하다.   생각처럼 진행이되질 않았다.   그리고 무엇보다 내가 이렇게 삽질을 하는데에는 이유가 있었다.   실제로 쿼리를 요청하는 메서드 각각에서 SqlSession을 하나씩 할당하는 노가다를 하기 싫었던 것이다.   가장 단순한 해결방법이 될 것 같았지만, 중복된 코드를 덕지덕지 붙여넣는 지저분한 코드를 생산하기 싫었다.   그런데…   이건 실제로 이슈가 발생하면 바로 대응해야한다. 실제로 중요한 작업이고 언제 어떤 이슈가 발생할지 모르니 일단은 제대로 돌아가는 환경이 필요하다.   그래서 결국 일단은 해결했다.   이렇게 말이다.   public class SampleService extends MyBatisConfig {     private SampleDAO dao;          public List&lt;SampleVO&gt; selectTestToken(SampleVO vo){         try(SqlSession session = MyBatisConfig.getSqlSessionFactory().openSession()){             dao = session.getMapper(SampleDAO.class);              HashMap&lt;String, String&gt; query = new HashMap&lt;&gt;();             query.put(\"query\",vo.getSample);              List&lt;SampleVO&gt; resultList = dao.sqlSelectSampleCode(query);             return resultList;         }     }      public void insertSampleCode(SampleVO vo){         try(SqlSession session = MyBatisConfig.getSqlSessionFactory().openSession()){             dao = session.getMapper(SampleDAO.class);             dao.sqlInsertSample(vo);             session.commit();         }     } }   생성자를 없앴고, 전역적으로 처리했던 SqlSession도 제거하여 해당 메서드가 생성될때만 하나씩 세션을 열도록 하여 처리했다.   허무하지만 문제없이 돌아간다.     무엇이 정확한 문제였을까 고민해보면,   멀티쓰레드 환경에서, 먼저 생성되어 사용한 SqlSession을 같은 인스턴스에서 해당 session에 접근하면서 커넥션 상태를 잃어버리는 것이었을까.   SqlSession은 커넥션풀에 한번 접근 한 후 스스로 소멸되는 것일까?   그래서 그 세션이 접근할 수 있는 connection pool을 잃어버려 ‘Error Accessing PooledConnection’과 같은 문제가 발생한게 아닐까 생각이든다.   참 공부할게 많다.   스프링이 알아서 해주던, 그리고 스프링 사용시 참고할만한 레퍼런스가 많아 비교적 이슈트래킹이 쉬웠는데   로우레벨로 기본 개념을 이해하며 문제를 해결하는 과정이 쉽지 않다.   하지만 이것은 정말 좋은 기회이다.   잘 만들어진 제품을 사용하는 ‘Consumer’는 관련 레퍼런스 문서를 읽으면 누구나 할 수 있다.   하지만 그것이 왜, 어떤 철학으로 만들어 졌는지 이해하고 사용하는 사람. 또는 필요에 따라 내가 직접 필요한 부분을 만들어서 접목시킬 수 있는 마스터가 된다는 것은 조금 다른 이야기다.   조급하지않게 꼼꼼히 해결해나가보자.  ","categories": ["notes"],
        "tags": ["common dbcp","jdbc","mybatis"],
        "url": "http://localhost:4000/notes/1811_6/",
        "teaser":null},{
        "title": "[Google App Engine] include HTML in JSP",
        "excerpt":"황당한 일을 겪었다.   진행 중인 웹서비스에서 Google App Engine(이하 GAE)에 배포 후 팝업화면 전체가 노출되지 않는 것이다.   로컬에서 테스트시에는 문제가 없던 것들이, GAE 배포만 하면 모든 팝업창이 나타나지 않았다.   어떤 에러로그도 발생하지 않고 아무런 반응이 없다. 네트워크를 보면, 아무리 팝업창을 클릭해도 API가 호출되지 않는다.   API통신 자체가 되지 않는 다는 것은 팝업창에 문제가 있으리라.   꽤 오랜 삽질과 인고의 시간 결과, 현재 우리 프로젝트의 Front-end부분의 팝업창 구현은 모두 각각의 HTML을 include시켜 이벤트가 발생하도록 구현되어 있다.   예를들어 ‘히스토리’ 라는 메뉴가 있다면, history/index.jsp 라는 각각의 메인 서비스에 대한 jsp 기본 화면을 그려놓고.   그 안에   &lt;jsp:include page=\"modal-item-detail.html\" flush=\"true\"&gt;&lt;/jsp:include&gt;   이와 같은 방식으로 각각의 HTML로 구현해놓은 HTML파일들을  jsp:include 를 통해서 삽입했다.   문제는 우리 프로젝트르를 패키징한 후 이렇게 include한 부분이 모두 제거되어 있었던 것이다!!   정상적으로 include된 소스     include되지 않은 소스     이처럼 include 자체에 문제가 있는 것으로 보였다.   jsp:include와 &lt;%@ include%&gt; 의 차이&gt;   위 링크를 보면, ‘jsp:include 특징 중 서블릿 컨테이너에 따라 HTML 페이지는 include가 안될 수 있다.’ 고 한다. 사실 기존에 되던 방식이기 때문에(서블릿 컨테이너가 바뀐것이 없기 때문에) 이걸로 될까 싶어 &lt;%@ include &gt; 방식으로 진행해봤지만 결과는 똑같았다.   …   그러다 문득 servlet 이라는 힌트까 떠올랐다.   app engine에 올릴때 설정을하는 appengine-web-app 의 구성이 의심되었다.   &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;appengine-web-app xmlns=\"http://appengine.google.com/ns/1.0\"&gt;     &lt;version&gt;v1-snapshot&lt;/version&gt;     &lt;runtime&gt;java8&lt;/runtime&gt;     &lt;threadsafe&gt;true&lt;/threadsafe&gt;     &lt;use-google-connector-j&gt;true&lt;/use-google-connector-j&gt;      &lt;warmup-requests-enabled&gt;false&lt;/warmup-requests-enabled&gt;      &lt;env-variables&gt;         &lt;env-var name=\"DEFAULT_ENCODING\" value=\"UTF-8\"/&gt;     &lt;/env-variables&gt;           &lt;resource-files&gt;         &lt;include path=\"/**.xml\"/&gt;     &lt;/resource-files&gt;           &lt;system-properties&gt;         &lt;property name=\"cloudsql\" value=\"${mysql_url}\"/&gt;     &lt;/system-properties&gt;      &lt;static-files&gt;         &lt;include path=\"/**.html\"&gt;&lt;/include&gt;         &lt;include path=\"/**.json\"&gt;&lt;/include&gt;         &lt;include path=\"/**.js\"&gt;&lt;/include&gt;         &lt;include path=\"/**.css\"/&gt;         &lt;include path=\"/**.scss\"/&gt;         &lt;include path=\"/**.png\"/&gt;         &lt;include path=\"/**.jpg\"/&gt;         &lt;include path=\"/**.ico\"/&gt;         &lt;include path=\"/**.gif\"/&gt;         &lt;include path=\"/**.woff\"/&gt;         &lt;include path=\"/**.woff2\"/&gt;         &lt;include path=\"/**.svg\"/&gt;         &lt;include path=\"/**.eot\"/&gt;         &lt;include path=\"/**.ttf\"/&gt;     &lt;/static-files&gt;     ... &lt;/appengine-web-app&gt;   대략적으로 이와 같이 구현되어있었는데…   &lt;resource-files&gt;     &lt;include path=\"/**.xml\"/&gt; &lt;/resource-files&gt;   이 부분은 내가 myBatis를 도입하면서 resources/ 하위에 mapper를 사용하기 위해 설정해놓은 것이다.   사실 jsp/html 쪽에 관련된 작업을 한 것이 아무것도 없는데, 그쪽에서 문제가 난다는 것은 배포 설정에 문제가 있다는 것밖에 안된다.   지워봤다.   그리고 다시 mvn clean package   일단 메이븐 패키징은 문제없이 된다.   혹시 myBatis가 mapper를 찾지 못할까 걱정되었다. 하지만 전혀 문제없이 쿼릴르 날리고 있다.   허무했지만 침착하게 dev deploy를 진행했다.   -Pdev clean appengine:deploy   역시 정상적으로 실행되었고. 팝업창도 정상적으로 출력된다.   당연히 html도 문제없이 include되었다..   &lt;resource-files&gt;     &lt;include path=\"/**.xml\"/&gt; &lt;/resource-files&gt;   resource파일 중 xml만 사용하고 나머지는 제외시키는 것일까?   이 설정이 jsp:include 자체를 막아버린 것일까?   문제는 해결했지만, 근본적인 원인은 파악되지 않아 여전히 찜찜한 상황이다.   우선 기록해두고, 계속 트래킹해보리라.  ","categories": ["GCP"],
        "tags": ["Google Cloud Platform","Google App Engine","JSP"],
        "url": "http://localhost:4000/gcp/gae/",
        "teaser":null},{
        "title": "Open Source 활용기",
        "excerpt":"오픈소스/깃헙 사용하기   https://medium.com/hbsmith/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-%EC%9D%BC%EA%B8%B0-git-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EC%A0%80%EC%9E%A5%EC%86%8C-%EB%8B%A4%EB%A3%A8%EA%B8%B0-9f66c98c1cb5   https://json.postype.com/post/210431   https://www.popit.kr/%EC%98%A4%ED%94%88%EC%86%8C%EC%8A%A4-git-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-pull-request-%EB%B3%B4%EB%82%B4%EA%B8%B0/   http://sanghaklee.tistory.com/30  ","categories": ["JAVA"],
        "tags": ["Open Source","github"],
        "url": "http://localhost:4000/java/OpenSource/",
        "teaser":null}]
